code:00000000 ; ===========================================================================
code:00000000
code:00000000 ; Segment type: Pure code
code:00000000                 ;.segment code
code:00000000
code:00000000 ; =============== S U B R O U T I N E =======================================
code:00000000
code:00000000 ; RESET
code:00000000 ; Attributes: thunk
code:00000000
code:00000000                 ; public RESET
code:00000000 RESET:                                  ; DATA XREF: UpdateStatusLine:PrintOfflineTopLine↓o
code:00000000                                         ; UpdateStatusLine+25↓o
code:00000000                 ajmp    RESET_0
code:00000000 ; End of function RESET
code:00000000
code:00000000 ; ---------------------------------------------------------------------------
code:00000002                 .byte 1
code:00000003
code:00000003 ; =============== S U B R O U T I N E =======================================
code:00000003
code:00000003 ; External interrupt 0
code:00000003
code:00000003                 ; public IE0
code:00000003 IE0:
code:00000003
code:00000003 ; FUNCTION CHUNK AT code:00000029 SIZE 00000015 BYTES
code:00000003
code:00000003                 jnb     EA, code_8      ; Interrupt Enable Register
code:00000006
code:00000006
code:00000006                 ajmp    continue_ie0
code:00000008 ; ---------------------------------------------------------------------------
code:00000008
code:00000008 code_8:                                 ; CODE XREF: IE0↑j
code:00000008                 setb    IE0             ; Timer 0/1 Control Register
code:0000000A                 reti
code:0000000A ; End of function IE0
code:0000000A
code:0000000B
code:0000000B ; =============== S U B R O U T I N E =======================================
code:0000000B
code:0000000B ; Timer 0 interrupt
code:0000000B
code:0000000B                 ; public TF0
code:0000000B TF0:
code:0000000B
code:0000000B ; FUNCTION CHUNK AT code:0000007B SIZE 0000001A BYTES
code:0000000B
code:0000000B                 jnb     EA, code_10     ; Interrupt Enable Register
code:0000000E                 ajmp    ResetT0Count
code:00000010 ; ---------------------------------------------------------------------------
code:00000010
code:00000010 code_10:                                ; CODE XREF: TF0↑j
code:00000010                 setb    TF0             ; Timer 0/1 Control Register
code:00000012                 reti
code:00000012 ; End of function TF0
code:00000012
code:00000013
code:00000013 ; =============== S U B R O U T I N E =======================================
code:00000013
code:00000013 ; External interrupt 1
code:00000013
code:00000013                 ; public IE1
code:00000013 IE1:
code:00000013
code:00000013 ; FUNCTION CHUNK AT code:0000003E SIZE 0000003D BYTES
code:00000013
code:00000013                 jnb     EA, code_18     ; Interrupt Enable Register
code:00000016                 ajmp    DMARefreshFinished
code:00000018 ; ---------------------------------------------------------------------------
code:00000018
code:00000018 code_18:                                ; CODE XREF: IE1↑j
code:00000018                 setb    IE1             ; Timer 0/1 Control Register
code:0000001A                 reti
code:0000001A ; End of function IE1
code:0000001A
code:0000001B
code:0000001B ; =============== S U B R O U T I N E =======================================
code:0000001B
code:0000001B ; Timer 1 interrupt
code:0000001B
code:0000001B                 ; public TF1
code:0000001B TF1:
code:0000001B                 jnb     EA, code_1E     ; Interrupt Enable Register
code:0000001E
code:0000001E code_1E:                                ; CODE XREF: TF1↑j
code:0000001E                 setb    TF1             ; Timer 0/1 Control Register
code:00000020                 reti
code:00000020 ; End of function TF1
code:00000020
code:00000021 ; ---------------------------------------------------------------------------
code:00000021                 djnz    R7, code_26
code:00000023
code:00000023 ; =============== S U B R O U T I N E =======================================
code:00000023
code:00000023 ; Serial port interrupt
code:00000023
code:00000023                 ; public RI_TI
code:00000023 RI_TI:
code:00000023
code:00000023 ; FUNCTION CHUNK AT code:00000095 SIZE 00000034 BYTES
code:00000023
code:00000023                 jnb     EA, code_28     ; Interrupt Enable Register
code:00000026
code:00000026 code_26:                                ; CODE XREF: code:00000021↑j
code:00000026                 ajmp    SerialHandler
code:00000028 ; ---------------------------------------------------------------------------
code:00000028
code:00000028 code_28:                                ; CODE XREF: RI_TI↑j
code:00000028                 reti
code:00000028 ; End of function RI_TI
code:00000028
code:00000029 ; ---------------------------------------------------------------------------
code:00000029
code:00000029 ;
code:00000029 ; It may be noticed on first glance that this ISR does not
code:00000029 ; properly pop its stack and return to the caller.  That's
code:00000029 ; because its purpose is instead, to act as DMA to the CRTC.
code:00000029 ; This ISR is paired with IE1 to drive data retrieval for
code:00000029 ; this purpose.
code:00000029 ;
code:00000029 ; START OF FUNCTION CHUNK FOR IE0
code:00000029
code:00000029 continue_ie0:                           ; CODE XREF: IE0+3↑j
code:00000029                 push    PSW             ; Program Status Word Register
code:0000002B                 push    ACC             ; Accumulator
code:0000002D                 push    B               ; B-Register
code:0000002F                 push    IE              ; Interrupt Enable Register
code:00000031
code:00000031
code:00000031                 mov     IE, #0x84       ; Only enable external interrupt 1
code:00000034
code:00000034
code:00000034                 setb    RS0             ; Switch to register set 1
code:00000036
code:00000036 ;
code:00000036 ; Drop into a program space that parallels the video RAM.
code:00000036 ; We will be falling to an address 0x2000 above the
code:00000036 ; address of the start of the current terminal line to be
code:00000036 ; displayed.  We'll be executing MOV A,#0x74 (essentially
code:00000036 ; a 2-byte NOP) while the hardware activates the VRAM at
code:00000036 ; (PC & 0x4fff) to provide data to the CRTC.
code:00000036 ; We'll return through IE1 to make some updates and then
code:00000036 ; actually return to the caller.
code:00000036 ;
code:00000036                 push    B1R2_CursorLinePtr+1 ; Initialized to 0x4000, video RAM
code:00000038
code:00000038
code:00000038                 mov     A, R2
code:00000039                 add     A, #0x20
code:0000003B                 push    ACC             ; Accumulator
code:0000003D                 reti
code:0000003D ; END OF FUNCTION CHUNK FOR IE0
code:0000003E ; ---------------------------------------------------------------------------
code:0000003E ;
code:0000003E ; We're back from 0x6xxx.  Perform the post-DMA processing.
code:0000003E ;
code:0000003E ; START OF FUNCTION CHUNK FOR IE1
code:0000003E
code:0000003E DMARefreshFinished:                     ; CODE XREF: IE1+3↑j
code:0000003E                 pop     ACC             ; We're not returning to 6XXX space.
code:00000040                 pop     ACC             ; Accumulator
code:00000042
code:00000042 ;
code:00000042 ; Update the row index for the next line to be snarfed
code:00000042 ;
code:00000042                 inc     R1
code:00000043                 cjne    R1, #25, CalcOutputLine
code:00000046
code:00000046
code:00000046                 push    DPL             ; Data Pointer, Low Byte
code:00000048                 push    DPH             ; Data Pointer, High Byte
code:0000004A
code:0000004A ;
code:0000004A ; End of frame.  Reset the counter and do some CRT updates
code:0000004A ;
code:0000004A                 mov     R1, #0
code:0000004C
code:0000004C
code:0000004C                 acall   SendCursorPos   ; Sends the current cursor row and column to the CRTC.  If
code:0000004C                                         ; video is busy, move cursor offscreen.
code:0000004E
code:0000004E
code:0000004E                 mov     DPTR, #CRTC_CREG
code:00000051                 movx    A, @DPTR
code:00000052                 jnb     ACC1, UpdateTime ; Check for DMA underrun
code:00000055
code:00000055
code:00000055                 acall   ResetDisplay    ; Reset the CPU to regain synchronicity
code:00000057
code:00000057 UpdateTime:                             ; CODE XREF: IE1+3F↑j
code:00000057                 acall   TimeBasedUpdates
code:00000059
code:00000059
code:00000059                 jb      VideoSettings.6, RestoreDPTR ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000059                                         ; Bit 1 = Receive buffer is full
code:00000059                                         ; Bit 3 = Serial send register busy
code:00000059                                         ; Bit 4 = Busy drawing to screen
code:00000059                                         ; Bit 5 = Steady/Blink
code:00000059                                         ; Bit 6 = Disable keyboard
code:00000059                                         ; Bit 7 = Standard/Graphics
code:0000005C
code:0000005C
code:0000005C                 lcall   CheckKeyboard
code:0000005F
code:0000005F RestoreDPTR:                            ; CODE XREF: IE1+46↑j
code:0000005F                 pop     DPH             ; Data Pointer, High Byte
code:00000061                 pop     DPL             ; Data Pointer, Low Byte
code:00000063
code:00000063 Each interrupt, R1 is incremented and mapped to its actual
code:00000063 line number.  The line number is multiplied by 96 and added
code:00000063 to the video RAM base.  These values are stored in register
code:00000063 bank 1.  R1 is the line index, R2 is the display high byte,
code:00000063 and R3 is the display low byte
code:00000063
code:00000063 CalcOutputLine:                         ; CODE XREF: IE1+30↑j
code:00000063                 mov     A, #LineNumbers ; In order to make scrolling faster, the system does not
code:00000063                                         ; actually move data around.  Instead, it uses this array of
code:00000063                                         ; lines as a list of indices into VRAM.  To scroll the
code:00000063                                         ; screen, just rotate these numbers so that what was once
code:00000063                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:00000063                                         ; scroll operation.
code:00000065                 add     A, R1
code:00000066                 mov     R0, A
code:00000067                 mov     A, @R0
code:00000068
code:00000068
code:00000068                 mov     B, #96          ; B-Register
code:0000006B                 mul     AB
code:0000006C                 mov     R3, A
code:0000006D
code:0000006D
code:0000006D                 mov     A, B            ; B-Register
code:0000006F                 add     A, #(VideoLine1 >> 8)
code:00000071                 mov     R2, A
code:00000072
code:00000072
code:00000072                 pop     IE              ; Interrupt Enable Register
code:00000074                 pop     B               ; B-Register
code:00000076                 pop     ACC             ; Accumulator
code:00000078                 pop     PSW             ; Program Status Word Register
code:0000007A                 reti
code:0000007A ; END OF FUNCTION CHUNK FOR IE1
code:0000007B ; ---------------------------------------------------------------------------
code:0000007B ; START OF FUNCTION CHUNK FOR TF0
code:0000007B
code:0000007B ResetT0Count:                           ; CODE XREF: TF0+3↑j
code:0000007B                 mov     TH0, #214       ; Reset timer to maintain 50Hz int rate
code:0000007E                 djnz    T0MultACnt, Done ; Counts down until 0 then resets to T0MultA and decrements
code:0000007E                                         ; T0MultB
code:00000081
code:00000081
code:00000081                 djnz    T0MultB, A_Expires ; The end result is that the duration in seconds is
code:00000081                                         ; T0MultA * T0MultB / 50.
code:00000084
code:00000084
code:00000084                 clr     TimerStatus.3   ; Ring the timer bell
code:00000086                 clr     TR0             ; Disable the timer channel
code:00000088
code:00000088 Done:                                   ; CODE XREF: TF0+73↑j
code:00000088                                         ; TF0+85↓j
code:00000088                 acall   DisableAndAckInt ; Disables interrupts before acknowledging the end of this
code:00000088                                         ; one.
code:0000008A                 setb    EA              ; Reenable interrupts.  Delay tactic?
code:0000008C                 ret
code:0000008D ; ---------------------------------------------------------------------------
code:0000008D
code:0000008D A_Expires:                              ; CODE XREF: TF0+76↑j
code:0000008D                 mov     T0MultACnt, T0MultA ; Timer 0 frequency
code:00000090                 ajmp    Done
code:00000092 ; ---------------------------------------------------------------------------
code:00000092
code:00000092 DisableAndAckInt:                       ; CODE XREF: TF0:Done↑p
code:00000092                 clr     EA              ; Disables interrupts before acknowledging the end of this
code:00000092                                         ; one.
code:00000094                 reti
code:00000094 ; END OF FUNCTION CHUNK FOR TF0
code:00000095 ; ---------------------------------------------------------------------------
code:00000095 ; START OF FUNCTION CHUNK FOR RI_TI
code:00000095
code:00000095 SerialHandler:                          ; CODE XREF: RI_TI:code_26↑j
code:00000095                 push    PSW             ; Program Status Word Register
code:00000097                 push    ACC             ; Accumulator
code:00000099
code:00000099
code:00000099                 jnb     RI, code_B3     ; Serial Channel Control Register
code:0000009C
code:0000009C
code:0000009C                 clr     RI              ; Serial Channel Control Register
code:0000009E                 mov     A, SBUF         ; Serial Channel Buffer Register
code:000000A0                 clr     ACC7            ; Accumulator
code:000000A2                 jnb     VideoSettings.0, code_C4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000000A2                                         ; Bit 1 = Receive buffer is full
code:000000A2                                         ; Bit 3 = Serial send register busy
code:000000A2                                         ; Bit 4 = Busy drawing to screen
code:000000A2                                         ; Bit 5 = Steady/Blink
code:000000A2                                         ; Bit 6 = Disable keyboard
code:000000A2                                         ; Bit 7 = Standard/Graphics
code:000000A5                 push    DPL             ; Data Pointer, Low Byte
code:000000A7                 push    DPH             ; Data Pointer, High Byte
code:000000A9                 push    B               ; B-Register
code:000000AB                 acall   AddToSerialInBuf
code:000000AD                 pop     B               ; B-Register
code:000000AF                 pop     DPH             ; Data Pointer, High Byte
code:000000B1                 pop     DPL             ; Data Pointer, Low Byte
code:000000B3
code:000000B3 code_B3:                                ; CODE XREF: RI_TI+76↑j
code:000000B3                 jnb     TI, code_C4     ; Serial Channel Control Register
code:000000B6                 clr     TI              ; Serial Channel Control Register
code:000000B8                 jnb     PrinterStatus.1, code_C2 ; Bit 0 = Printer
code:000000B8                                         ; Bit 1 = Need to send XOFF
code:000000B8                                         ; Bit 2 = Toggle printer state
code:000000B8                                         ; Bit 3 = No writes to status line
code:000000B8                                         ;         No update of time or print status.  Set cursor position ESC
code:000000B8                                         ;         code cannot set cursor to row 1
code:000000B8                                         ; Bit 4 = No writes to status line
code:000000B8                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000000B8                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000000B8                                         ;         position to row 1
code:000000B8                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000000B8                                         ; Bit 6 = Key pressed
code:000000B8                                         ; Bit 7 = Repeat eligible
code:000000BB                 clr     PrinterStatus.1 ; Bit 0 = Printer
code:000000BB                                         ; Bit 1 = Need to send XOFF
code:000000BB                                         ; Bit 2 = Toggle printer state
code:000000BB                                         ; Bit 3 = No writes to status line
code:000000BB                                         ;         No update of time or print status.  Set cursor position ESC
code:000000BB                                         ;         code cannot set cursor to row 1
code:000000BB                                         ; Bit 4 = No writes to status line
code:000000BB                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000000BB                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000000BB                                         ;         position to row 1
code:000000BB                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000000BB                                         ; Bit 6 = Key pressed
code:000000BB                                         ; Bit 7 = Repeat eligible
code:000000BD                 mov     SBUF, #0x13     ; XOFF
code:000000C0                 ajmp    code_C4
code:000000C2 ; ---------------------------------------------------------------------------
code:000000C2
code:000000C2 code_C2:                                ; CODE XREF: RI_TI+95↑j
code:000000C2                 clr     VideoSettings.3 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000000C2                                         ; Bit 1 = Receive buffer is full
code:000000C2                                         ; Bit 3 = Serial send register busy
code:000000C2                                         ; Bit 4 = Busy drawing to screen
code:000000C2                                         ; Bit 5 = Steady/Blink
code:000000C2                                         ; Bit 6 = Disable keyboard
code:000000C2                                         ; Bit 7 = Standard/Graphics
code:000000C4
code:000000C4 code_C4:                                ; CODE XREF: RI_TI+7F↑j
code:000000C4                                         ; RI_TI:code_B3↑j ...
code:000000C4                 pop     ACC             ; Accumulator
code:000000C6                 pop     PSW             ; Program Status Word Register
code:000000C8                 reti
code:000000C8 ; END OF FUNCTION CHUNK FOR RI_TI
code:000000C9
code:000000C9 ; =============== S U B R O U T I N E =======================================
code:000000C9
code:000000C9
code:000000C9 RESET_0:                                ; CODE XREF: RESET↑j
code:000000C9                 clr     EA              ; Interrupt Enable Register
code:000000CB                 mov     SP, #StackTop   ; Stack Pointer
code:000000CE                 clr     A
code:000000CF                 mov     PSW, A          ; Program Status Word Register
code:000000D1
code:000000D1
code:000000D1                 mov     VideoSettings, A ; Bit 0 = ONLINE=1, OFFLINE=0
code:000000D1                                         ; Bit 1 = Receive buffer is full
code:000000D1                                         ; Bit 3 = Serial send register busy
code:000000D1                                         ; Bit 4 = Busy drawing to screen
code:000000D1                                         ; Bit 5 = Steady/Blink
code:000000D1                                         ; Bit 6 = Disable keyboard
code:000000D1                                         ; Bit 7 = Standard/Graphics
code:000000D3                 mov     PrinterStatus, A ; Bit 0 = Printer
code:000000D3                                         ; Bit 1 = Need to send XOFF
code:000000D3                                         ; Bit 2 = Toggle printer state
code:000000D3                                         ; Bit 3 = No writes to status line
code:000000D3                                         ;         No update of time or print status.  Set cursor position ESC
code:000000D3                                         ;         code cannot set cursor to row 1
code:000000D3                                         ; Bit 4 = No writes to status line
code:000000D3                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000000D3                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000000D3                                         ;         position to row 1
code:000000D3                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000000D3                                         ; Bit 6 = Key pressed
code:000000D3                                         ; Bit 7 = Repeat eligible
code:000000D5
code:000000D5
code:000000D5                 clr     TR0             ; Shut off timer 0
code:000000D7                 mov     P1, #10100011b  ; Port 1
code:000000DA                 setb    T0              ; Port 3
code:000000DC
code:000000DC ; Zero the time
code:000000DC                 mov     DPTR, #TimeDigitsEX ; External RAM address 49A1
code:000000DF                 mov     R0, #TimeDigitsINT ; Internal RAM address 54
code:000000E1                 mov     R1, #6          ; 6 bytes
code:000000E3                 mov     A, #'0          ; the character 0
code:000000E5
code:000000E5 code_E5:                                ; CODE XREF: RESET_0+20↓j
code:000000E5                 mov     @R0, A
code:000000E6                 movx    @DPTR, A
code:000000E7                 inc     R0
code:000000E8                 inc     DPTR
code:000000E9                 djnz    R1, code_E5
code:000000EB
code:000000EB
code:000000EB                 clr     A
code:000000EC                 mov     DPTR, #DialStringEncoded
code:000000EF                 movx    @DPTR, A
code:000000F0
code:000000F0
code:000000F0                 mov     DPTR, #PressedKeys ; This is an array of 8x8 bits representing each key on the
code:000000F0                                         ; keyboard.  The system scans from 0 to 8 and marks down
code:000000F0                                         ; each key it finds turned on.  This helps to keep track
code:000000F0                                         ; of which keys were last pressed.
code:000000F3                 mov     B, #8           ; B-Register
code:000000F6                 acall   memset          ; A = value; B = count; DPTR = address
code:000000F8
code:000000F8
code:000000F8                 setb    RS0             ; Switch to register bank 1
code:000000FA                 acall   ResetDisplay    ; Register bank should be 1 at entrance to this call
code:000000FC                 clr     RS0             ; Program Status Word Register
code:000000FE
code:000000FE
code:000000FE                 mov     A, #200         ; Divisor for 300 baud
code:00000100                 lcall   ProgramBaud     ; A = baud rate divisor
code:00000103
code:00000103
code:00000103
code:00000103 Reset:                                  ; DATA XREF: InterpretESC+1A↓o
code:00000103                 mov     SP, #StackTop   ; Stack Pointer
code:00000106
code:00000106
code:00000106                 push    VideoSettings   ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000106                                         ; Bit 1 = Receive buffer is full
code:00000106                                         ; Bit 3 = Serial send register busy
code:00000106                                         ; Bit 4 = Busy drawing to screen
code:00000106                                         ; Bit 5 = Steady/Blink
code:00000106                                         ; Bit 6 = Disable keyboard
code:00000106                                         ; Bit 7 = Standard/Graphics
code:00000108
code:00000108
code:00000108                 push    PrinterStatus   ; Bit 0 = Printer
code:00000108                                         ; Bit 1 = Need to send XOFF
code:00000108                                         ; Bit 2 = Toggle printer state
code:00000108                                         ; Bit 3 = No writes to status line
code:00000108                                         ;         No update of time or print status.  Set cursor position ESC
code:00000108                                         ;         code cannot set cursor to row 1
code:00000108                                         ; Bit 4 = No writes to status line
code:00000108                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000108                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000108                                         ;         position to row 1
code:00000108                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000108                                         ; Bit 6 = Key pressed
code:00000108                                         ; Bit 7 = Repeat eligible
code:0000010A
code:0000010A
code:0000010A                 clr     A
code:0000010B                 mov     PSW, A          ; Program Status Word Register
code:0000010D
code:0000010D
code:0000010D                 mov     R0, #SerialInBufLen
code:0000010F                 mov     R1, #67
code:00000111
code:00000111 code_111:                               ; CODE XREF: RESET_0+4A↓j
code:00000111                 mov     @R0, A
code:00000112                 inc     R0
code:00000113                 djnz    R1, code_111
code:00000115
code:00000115
code:00000115                 pop     ACC             ; Accumulator
code:00000117                 anl     A, #0xC0
code:00000119                 mov     PrinterStatus, A ; Bit 0 = Printer
code:00000119                                         ; Bit 1 = Need to send XOFF
code:00000119                                         ; Bit 2 = Toggle printer state
code:00000119                                         ; Bit 3 = No writes to status line
code:00000119                                         ;         No update of time or print status.  Set cursor position ESC
code:00000119                                         ;         code cannot set cursor to row 1
code:00000119                                         ; Bit 4 = No writes to status line
code:00000119                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000119                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000119                                         ;         position to row 1
code:00000119                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000119                                         ; Bit 6 = Key pressed
code:00000119                                         ; Bit 7 = Repeat eligible
code:0000011B
code:0000011B
code:0000011B                 pop     ACC             ; Accumulator
code:0000011D                 anl     A, #9
code:0000011F                 mov     VideoSettings, A ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000011F                                         ; Bit 1 = Receive buffer is full
code:0000011F                                         ; Bit 3 = Serial send register busy
code:0000011F                                         ; Bit 4 = Busy drawing to screen
code:0000011F                                         ; Bit 5 = Steady/Blink
code:0000011F                                         ; Bit 6 = Disable keyboard
code:0000011F                                         ; Bit 7 = Standard/Graphics
code:00000121
code:00000121
code:00000121                 acall   ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:00000121                                         ; terminal software knows to react to it.  This is called to signal
code:00000121                                         ; a change, such as when the clock updates.
code:00000123
code:00000123
code:00000123                 inc     CursorRow
code:00000125                 inc     SavedCursorRow
code:00000127                 mov     CursorAddr, #(VideoLine2 >> 8)
code:0000012A                 mov     CursorAddr+1, #(VideoLine2 & 0xFF)
code:0000012D                 inc     SecWaitForAnswer ; The actual value is this value*5
code:0000012F                 mov     TimeUpdateCounter, #60
code:00000132                 mov     SerialSelection, #' ; This is a character representing the routing selection for
code:00000132                                         ; serial data.
code:00000132                                         ;   <SPC> = MCU -> MODEM
code:00000132                                         ;   1 = MCU -> RS232 (power plug)
code:00000132                                         ;   2 = MCU -> MODEM with the DE9 listening to the modem
code:00000132                                         ;   3 = MODEM -> DE9 with MCU listening to the modem
code:00000135
code:00000135
code:00000135                 acall   InitLineMap     ; Sets the line numbers to 0-24 in order and clears the screen
code:00000137
code:00000137
code:00000137                 acall   ClearTopLine
code:00000139
code:00000139
code:00000139                 acall   SetNormalInputMode
code:0000013B
code:0000013B
code:0000013B                 lcall   CheckPhoneBookMem
code:0000013E                 jnz     EnableHardware
code:00000140
code:00000140 ;
code:00000140 ; If the phone book memory is trashed, this part
code:00000140 ; restoring settings from there would be skipped
code:00000140 ;
code:00000140                 mov     DPTR, #SavedSerialSettings
code:00000143                 acall   NibblesToByte   ; Read 2 consecutive nibbles as one byte from DPTR.  This is
code:00000143                                         ; used for name and password text stored in phone book memory.
code:00000145                 mov     SerialSettings, A ; Bit 0 = Clock display off
code:00000145                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000145                                         ; Bit 2 = Half/Full duplex
code:00000145                                         ; Bit 3 = Auto Repeat disable
code:00000145                                         ; Bit 4 = Key click disable
code:00000145                                         ; Bit 5 = LF->CRLF
code:00000145                                         ; Bit 6 = CR->CRLF
code:00000145                                         ; Bit 7 = Wrap at EOL off
code:00000147
code:00000147
code:00000147                 movx    A, @DPTR
code:00000148                 inc     DPTR
code:00000149                 anl     A, #0xF
code:0000014B                 mov     SlashPause, A   ; Time to wait when / is seen.  Value is 3*number+12
code:0000014D
code:0000014D
code:0000014D                 movx    A, @DPTR
code:0000014E                 anl     A, #0xF
code:00000150                 mov     SecWaitForAnswer, A ; The actual value is this value*5
code:00000152
code:00000152 EnableHardware:                         ; CODE XREF: RESET_0+75↑j
code:00000152                 mov     IP, #0x15       ; Set priority for serial and external interrupts
code:00000155                 mov     IE, #0x93       ; Enable serial and external 0 and timer 0 interrupts
code:00000158
code:00000158
code:00000158                 mov     BellDurationCounter, #10
code:0000015B                 ljmp    TerminalEntry
code:0000015B ; End of function RESET_0
code:0000015B
code:0000015E
code:0000015E ; =============== S U B R O U T I N E =======================================
code:0000015E
code:0000015E ; If the input is a graphics character, get its VT52
code:0000015E ; equivalent.  Set CharEquivalent when <0x80.  Return an
code:0000015E ; interpretation of the result:
code:0000015E ;
code:0000015E ; Original if 0x80 or higher
code:0000015E ;
code:0000015E ; Value returned is 0 if same class of value, 'G' (leave
code:0000015E ; graphics mode) if transition from graphics to normal, 'F'
code:0000015E ; (enter graphics mode) if transition from normal to
code:0000015E ; graphics
code:0000015E
code:0000015E ScreenToVT52Char:                       ; CODE XREF: SendCharUnderCursor+3↓p
code:0000015E                                         ; SendScreenLineToSerial+10↓p ...
code:0000015E                 cjne    A, #0x7F, TestHighBit
code:00000161
code:00000161
code:00000161                 mov     A, #'^
code:00000163                 setb    CY              ; Program Status Word Register
code:00000165                 ajmp    SaveCode
code:00000167 ; ---------------------------------------------------------------------------
code:00000167
code:00000167 TestHighBit:                            ; CODE XREF: ScreenToVT52Char↑j
code:00000167                 jnc     Done
code:00000169
code:00000169
code:00000169                 cjne    A, #0x20, TestIfGraphics
code:0000016C
code:0000016C TestIfGraphics:                         ; CODE XREF: ScreenToVT52Char+B↑j
code:0000016C                 jnc     SaveCode
code:0000016E
code:0000016E ;
code:0000016E ; The input value is found to be a control character.
code:0000016E ; Turn into its caret equivalent
code:0000016E ;
code:0000016E                 cjne    A, #0x1F, ConvertToGraphics
code:00000171
code:00000171
code:00000171                 mov     A, #-1
code:00000173
code:00000173 ConvertToGraphics:                      ; CODE XREF: ScreenToVT52Char+10↑j
code:00000173                 add     A, #0x60
code:00000175                 setb    CY              ; Program Status Word Register
code:00000177
code:00000177 SaveCode:                               ; CODE XREF: ScreenToVT52Char+7↑j
code:00000177                                         ; ScreenToVT52Char:TestIfGraphics↑j
code:00000177                 mov     CharEquivalent, A
code:00000179
code:00000179
code:00000179                 clr     A
code:0000017A
code:0000017A
code:0000017A                 jc      IsGraphics
code:0000017C
code:0000017C
code:0000017C                 jnb     FormatStatus.2, Done ; Bit 0 = Ctrl-F1 pressed
code:0000017C                                         ; Bit 1 = Save of Disable Status Bar flag
code:0000017C                                         ; Bit 2 = In graphics mode
code:0000017F
code:0000017F
code:0000017F                 clr     FormatStatus.2  ; Bit 0 = Ctrl-F1 pressed
code:0000017F                                         ; Bit 1 = Save of Disable Status Bar flag
code:0000017F                                         ; Bit 2 = In graphics mode
code:00000181
code:00000181
code:00000181                 mov     A, #'G
code:00000183                 ret
code:00000184 ; ---------------------------------------------------------------------------
code:00000184
code:00000184 IsGraphics:                             ; CODE XREF: ScreenToVT52Char+1C↑j
code:00000184                 jb      FormatStatus.2, Done ; Bit 0 = Ctrl-F1 pressed
code:00000184                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000184                                         ; Bit 2 = In graphics mode
code:00000187
code:00000187
code:00000187                 setb    FormatStatus.2  ; Bit 0 = Ctrl-F1 pressed
code:00000187                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000187                                         ; Bit 2 = In graphics mode
code:00000189                 mov     A, #'F
code:0000018B
code:0000018B Done:                                   ; CODE XREF: ScreenToVT52Char:TestHighBit↑j
code:0000018B                                         ; ScreenToVT52Char+1E↑j ...
code:0000018B                 ret
code:0000018B ; End of function ScreenToVT52Char
code:0000018B
code:0000018C
code:0000018C ; =============== S U B R O U T I N E =======================================
code:0000018C
code:0000018C ; A second bit is used to detect online status change so that the
code:0000018C ; terminal software knows to react to it.  This is called to signal
code:0000018C ; a change, such as when the clock updates.
code:0000018C
code:0000018C ForceStatusLineUpdate:                  ; CODE XREF: RESET_0+58↑p
code:0000018C                                         ; DontShowClock+2↓j ...
code:0000018C                 mov     C, VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000018C                                         ; Bit 1 = Receive buffer is full
code:0000018C                                         ; Bit 3 = Serial send register busy
code:0000018C                                         ; Bit 4 = Busy drawing to screen
code:0000018C                                         ; Bit 5 = Steady/Blink
code:0000018C                                         ; Bit 6 = Disable keyboard
code:0000018C                                         ; Bit 7 = Standard/Graphics
code:0000018E                 cpl     C
code:0000018F                 mov     TimerStatus.2, C ; Bit 0 = ESC is tracked as pressed
code:0000018F                                         ; Bit 1 = BREAK is tracked as pressed
code:0000018F                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000018F                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000018F                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000018F                                         ;         handler uses this to look for timeouts in each state.
code:0000018F                                         ; Bit 4 = Use immediate dial buffer
code:0000018F                                         ; Bit 5 = Dial voice
code:0000018F                                         ; Bit 6 = Disabling/Enabling a setting
code:0000018F                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000191                 ret
code:00000191 ; End of function ForceStatusLineUpdate
code:00000191
code:00000192
code:00000192 ; =============== S U B R O U T I N E =======================================
code:00000192
code:00000192 ; Read 2 consecutive nibbles as one byte from DPTR.  This is
code:00000192 ; used for name and password text stored in phone book memory.
code:00000192
code:00000192 NibblesToByte:                          ; CODE XREF: RESET_0+7A↑p
code:00000192                                         ; CheckPhoneBookMem+5↓p ...
code:00000192                 movx    A, @DPTR
code:00000193                 anl     A, #0xF
code:00000195                 swap    A
code:00000196                 inc     DPTR
code:00000197                 mov     R3, A
code:00000198                 movx    A, @DPTR
code:00000199                 anl     A, #0xF
code:0000019B                 inc     DPTR
code:0000019C                 add     A, R3
code:0000019D                 ret
code:0000019D ; End of function NibblesToByte
code:0000019D
code:0000019E
code:0000019E ; =============== S U B R O U T I N E =======================================
code:0000019E
code:0000019E ; Gets a character from the input serial buffer.  Sends XON if
code:0000019E ; needed.
code:0000019E ;
code:0000019E ; At return:
code:0000019E ;
code:0000019E ; A = next character
code:0000019E ; C = next character is valid
code:0000019E
code:0000019E GetNextSerialInChar:                    ; CODE XREF: ReadDigit09:ReadCharLoop↓p
code:0000019E                                         ; ReadDigit09+B↓p ...
code:0000019E                 jb      SerialSettings.1, NoFlowControl ; Bit 0 = Clock display off
code:0000019E                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:0000019E                                         ; Bit 2 = Half/Full duplex
code:0000019E                                         ; Bit 3 = Auto Repeat disable
code:0000019E                                         ; Bit 4 = Key click disable
code:0000019E                                         ; Bit 5 = LF->CRLF
code:0000019E                                         ; Bit 6 = CR->CRLF
code:0000019E                                         ; Bit 7 = Wrap at EOL off
code:000001A1                 jnb     VideoSettings.1, NoFlowControl ; Bit 0 = ONLINE=1, OFFLINE=0
code:000001A1                                         ; Bit 1 = Receive buffer is full
code:000001A1                                         ; Bit 3 = Serial send register busy
code:000001A1                                         ; Bit 4 = Busy drawing to screen
code:000001A1                                         ; Bit 5 = Steady/Blink
code:000001A1                                         ; Bit 6 = Disable keyboard
code:000001A1                                         ; Bit 7 = Standard/Graphics
code:000001A4
code:000001A4
code:000001A4                 mov     A, SerialInBufLen
code:000001A6                 cjne    A, #39, code_1A9
code:000001A9
code:000001A9 code_1A9:                               ; CODE XREF: GetNextSerialInChar+8↑j
code:000001A9                 jnc     StatusQuo
code:000001AB
code:000001AB ; We are in flow control and we think we have enough of a
code:000001AB ; buffer to begin receiving again.  Send XON and clear the
code:000001AB ; ignore bit
code:000001AB                 clr     VideoSettings.1 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000001AB                                         ; Bit 1 = Receive buffer is full
code:000001AB                                         ; Bit 3 = Serial send register busy
code:000001AB                                         ; Bit 4 = Busy drawing to screen
code:000001AB                                         ; Bit 5 = Steady/Blink
code:000001AB                                         ; Bit 6 = Disable keyboard
code:000001AB                                         ; Bit 7 = Standard/Graphics
code:000001AD
code:000001AD
code:000001AD                 mov     A, #0x11        ; XON
code:000001AF                 acall   DispatchTypedValue
code:000001B1
code:000001B1 NoFlowControl:                          ; CODE XREF: GetNextSerialInChar↑j
code:000001B1                                         ; GetNextSerialInChar+3↑j
code:000001B1                 mov     A, SerialInBufLen
code:000001B3
code:000001B3 StatusQuo:                              ; CODE XREF: GetNextSerialInChar:code_1A9↑j
code:000001B3                 jnz     HaveInput
code:000001B5
code:000001B5
code:000001B5                 clr     C
code:000001B6                 ret
code:000001B7 ; ---------------------------------------------------------------------------
code:000001B7
code:000001B7 HaveInput:                              ; CODE XREF: GetNextSerialInChar:StatusQuo↑j
code:000001B7                 push    IE              ; Interrupt Enable Register
code:000001B9                 clr     EA              ; Interrupt Enable Register
code:000001BB                 dec     SerialInBufLen
code:000001BD                 mov     A, SerialInBufPtr
code:000001BF                 mov     B, A            ; B-Register
code:000001C1                 inc     A
code:000001C2                 anl     A, #0x3F
code:000001C4                 mov     SerialInBufPtr, A
code:000001C6
code:000001C6
code:000001C6                 mov     DPTR, #SerialInBuf
code:000001C9                 mov     A, B            ; B-Register
code:000001CB                 add     A, DPL          ; Data Pointer, Low Byte
code:000001CD                 mov     DPL, A          ; Data Pointer, Low Byte
code:000001CF                 pop     IE              ; Interrupt Enable Register
code:000001D1
code:000001D1
code:000001D1                 movx    A, @DPTR
code:000001D2
code:000001D2
code:000001D2                 setb    C
code:000001D3                 ret
code:000001D3 ; End of function GetNextSerialInChar
code:000001D3
code:000001D4
code:000001D4 ; =============== S U B R O U T I N E =======================================
code:000001D4
code:000001D4 ; On return:
code:000001D4 ; A = char
code:000001D4 ; C = set if char valid
code:000001D4
code:000001D4 GetNextSerialOutChar:                   ; CODE XREF: TerminalLoop+29↓p
code:000001D4                 mov     A, SerialOutBufLen
code:000001D6                 jnz     code_1DA
code:000001D8
code:000001D8
code:000001D8                 clr     C
code:000001D9                 ret
code:000001DA ; ---------------------------------------------------------------------------
code:000001DA
code:000001DA code_1DA:                               ; CODE XREF: GetNextSerialOutChar+2↑j
code:000001DA                 dec     SerialOutBufLen
code:000001DC
code:000001DC
code:000001DC                 mov     A, SerialOutBufPtr
code:000001DE                 mov     B, A            ; B-Register
code:000001E0                 inc     A
code:000001E1                 anl     A, #0xF
code:000001E3                 mov     SerialOutBufPtr, A
code:000001E5
code:000001E5
code:000001E5                 mov     DPTR, #SerialOutBuf
code:000001E8                 mov     A, B            ; B-Register
code:000001EA                 add     A, DPL          ; Data Pointer, Low Byte
code:000001EC                 mov     DPL, A          ; Data Pointer, Low Byte
code:000001EE                 movx    A, @DPTR
code:000001EF
code:000001EF
code:000001EF                 setb    C
code:000001F0                 ret
code:000001F0 ; End of function GetNextSerialOutChar
code:000001F0
code:000001F1
code:000001F1 ; =============== S U B R O U T I N E =======================================
code:000001F1
code:000001F1 ; Sends as a hex digit from 0x3008
code:000001F1
code:000001F1 SendAsHex:                              ; DATA XREF: InterpretESC+1A↓o
code:000001F1                 mov     DPTR, #HexChars
code:000001F4                 movx    A, @DPTR
code:000001F5                 anl     A, #0xF
code:000001F7                 add     A, #'0
code:000001F9                 cjne    A, #0x3A, code_1FC
code:000001FC
code:000001FC code_1FC:                               ; CODE XREF: SendAsHex+8↑j
code:000001FC                 jc      DispatchTypedValue
code:000001FE
code:000001FE
code:000001FE                 add     A, #7
code:000001FE ; End of function SendAsHex
code:000001FE
code:00000200
code:00000200 ;
code:00000200 ; When OFFLINE, typing input is interpreted as if it came
code:00000200 ; through serial input.  When ONLINE, typing is sent
code:00000200 ; through serial out.  A bell will sound if serial out
code:00000200 ; buffer fills due to Mavis typing.
code:00000200 ;
code:00000200 ; If we are half-duplex, the character will also be echoed
code:00000200 ; to the serial input buffer.
code:00000200 ;
code:00000200
code:00000200 ; =============== S U B R O U T I N E =======================================
code:00000200
code:00000200
code:00000200 DispatchTypedValue:                     ; CODE XREF: GetNextSerialInChar+11↑p
code:00000200                                         ; SendAsHex:code_1FC↑j ...
code:00000200                 mov     B, A            ; B-Register
code:00000202                 jnb     VideoSettings.0, AddToSerialInBuf ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000202                                         ; Bit 1 = Receive buffer is full
code:00000202                                         ; Bit 3 = Serial send register busy
code:00000202                                         ; Bit 4 = Busy drawing to screen
code:00000202                                         ; Bit 5 = Steady/Blink
code:00000202                                         ; Bit 6 = Disable keyboard
code:00000202                                         ; Bit 7 = Standard/Graphics
code:00000205
code:00000205
code:00000205                 mov     A, SerialOutBufLen
code:00000207                 cjne    A, #16, code_20A
code:0000020A
code:0000020A code_20A:                               ; CODE XREF: DispatchTypedValue+7↑j
code:0000020A                 jc      AddKey
code:0000020C
code:0000020C ExecuteBell:                            ; CODE XREF: AddToSerialInBuf+2A↓p
code:0000020C                                         ; SendPageToSerial+B↓j ...
code:0000020C                 mov     BellDurationCounter, #10
code:0000020F                 ret
code:00000210 ; ---------------------------------------------------------------------------
code:00000210
code:00000210 AddKey:                                 ; CODE XREF: DispatchTypedValue:code_20A↑j
code:00000210                 inc     SerialOutBufLen
code:00000212                 add     A, SerialOutBufPtr
code:00000214                 anl     A, #0xF
code:00000216
code:00000216
code:00000216                 mov     DPTR, #SerialOutBuf
code:00000219                 add     A, DPL          ; Data Pointer, Low Byte
code:0000021B                 mov     DPL, A          ; Data Pointer, Low Byte
code:0000021D                 mov     A, B            ; B-Register
code:0000021F                 movx    @DPTR, A
code:00000220
code:00000220
code:00000220                 jnb     SerialSettings.2, ReturnGate_8 ; Bit 0 = Clock display off
code:00000220 ; End of function DispatchTypedValue    ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000220                                         ; Bit 2 = Half/Full duplex
code:00000220                                         ; Bit 3 = Auto Repeat disable
code:00000220                                         ; Bit 4 = Key click disable
code:00000220                                         ; Bit 5 = LF->CRLF
code:00000220                                         ; Bit 6 = CR->CRLF
code:00000220                                         ; Bit 7 = Wrap at EOL off
code:00000223
code:00000223 ; =============== S U B R O U T I N E =======================================
code:00000223
code:00000223
code:00000223 AddToSerialInBuf:                       ; CODE XREF: RI_TI+88↑p
code:00000223                                         ; DispatchTypedValue+2↑j
code:00000223                 mov     B, A            ; B-Register
code:00000225                 jb      SerialSettings.1, ToSerialIn ; Bit 0 = Clock display off
code:00000225                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000225                                         ; Bit 2 = Half/Full duplex
code:00000225                                         ; Bit 3 = Auto Repeat disable
code:00000225                                         ; Bit 4 = Key click disable
code:00000225                                         ; Bit 5 = LF->CRLF
code:00000225                                         ; Bit 6 = CR->CRLF
code:00000225                                         ; Bit 7 = Wrap at EOL off
code:00000228
code:00000228 ;
code:00000228 ; Doing flow control.  See if we need to send XOFF
code:00000228 ;
code:00000228                 jb      VideoSettings.1, ToSerialIn ; Already marked full, skip check
code:0000022B
code:0000022B ;
code:0000022B ; See if the buffer is almost full
code:0000022B ;
code:0000022B                 mov     A, SerialInBufLen
code:0000022D                 cjne    A, #49, code_230
code:00000230
code:00000230 code_230:                               ; CODE XREF: AddToSerialInBuf+A↑j
code:00000230                 jc      ToSerialIn      ; It's fine.  Move to next stage
code:00000232
code:00000232 ;
code:00000232 ; Mark the buffer full.  Send XOFF immediately if
code:00000232 ; possible.  Otherwise flag it to be sent.
code:00000232 ;
code:00000232                 push    IE              ; Interrupt Enable Register
code:00000234                 clr     EA              ; Interrupt Enable Register
code:00000236                 setb    VideoSettings.1 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000236                                         ; Bit 1 = Receive buffer is full
code:00000236                                         ; Bit 3 = Serial send register busy
code:00000236                                         ; Bit 4 = Busy drawing to screen
code:00000236                                         ; Bit 5 = Steady/Blink
code:00000236                                         ; Bit 6 = Disable keyboard
code:00000236                                         ; Bit 7 = Standard/Graphics
code:00000238                 jnb     VideoSettings.3, SendXOFF ; Serial output register is empty.  Can send immediately.
code:0000023B
code:0000023B
code:0000023B                 setb    PrinterStatus.1 ; Set flag to send later
code:0000023D                 ajmp    DoneInFlowCtrl
code:0000023F ; ---------------------------------------------------------------------------
code:0000023F
code:0000023F SendXOFF:                               ; CODE XREF: AddToSerialInBuf+15↑j
code:0000023F                 setb    VideoSettings.3 ; Mark serial output register as in use
code:00000241                 mov     SBUF, #0x13     ; Send XOFF
code:00000244
code:00000244 DoneInFlowCtrl:                         ; CODE XREF: AddToSerialInBuf+1A↑j
code:00000244                 pop     IE              ; Interrupt Enable Register
code:00000246
code:00000246 ;
code:00000246 ; Now see if there is room to add a byte to the input
code:00000246 ; buffer.  We'll add the new character anyway, but if
code:00000246 ; the buffer is already full we'll be destroying input.
code:00000246 ;
code:00000246
code:00000246 ToSerialIn:                             ; CODE XREF: AddToSerialInBuf+2↑j
code:00000246                                         ; AddToSerialInBuf+5↑j ...
code:00000246                 mov     A, SerialInBufLen
code:00000248                 cjne    A, #64, code_24B
code:0000024B
code:0000024B code_24B:                               ; CODE XREF: AddToSerialInBuf+25↑j
code:0000024B                 jc      code_24F
code:0000024D
code:0000024D ;
code:0000024D ; No room.  Beep.  Then overwrite the oldest character in
code:0000024D ; the receive buffer
code:0000024D ;
code:0000024D                 acall   ExecuteBell
code:0000024F
code:0000024F code_24F:                               ; CODE XREF: AddToSerialInBuf:code_24B↑j
code:0000024F                 inc     SerialInBufLen
code:00000251                 add     A, SerialInBufPtr
code:00000253                 anl     A, #0x3F
code:00000255                 mov     DPTR, #SerialInBuf
code:00000258                 add     A, DPL          ; Data Pointer, Low Byte
code:0000025A                 mov     DPL, A          ; Data Pointer, Low Byte
code:0000025C                 mov     A, B            ; B-Register
code:0000025E                 movx    @DPTR, A
code:0000025F
code:0000025F ReturnGate_8:                           ; CODE XREF: DispatchTypedValue+20↑j
code:0000025F                 ret
code:0000025F ; End of function AddToSerialInBuf
code:0000025F
code:00000260
code:00000260 ; =============== S U B R O U T I N E =======================================
code:00000260
code:00000260 ; If printing, first sends the character to the printer.  Then if the
code:00000260 ; character is CANCEL, returns to normal typing mode instead.
code:00000260 ; Otherwise calls the current context function to handle the keypress.
code:00000260
code:00000260 ProcessInputWithContextFunction:        ; CODE XREF: TerminalLoop+5↓p
code:00000260                                         ; TerminalLoop+8C↓p
code:00000260                 jnb     PrinterStatus.0, CallContextFunction ; If A is 0x18 (CANcel), enters typing mode instead of calling current
code:00000260                                         ; context function
code:00000263                 lcall   SendPrinterChar
code:00000263 ; End of function ProcessInputWithContextFunction
code:00000263
code:00000266
code:00000266 ; =============== S U B R O U T I N E =======================================
code:00000266
code:00000266 ; If A is 0x18 (CANcel), enters typing mode instead of calling current
code:00000266 ; context function
code:00000266
code:00000266 CallContextFunction:                    ; CODE XREF: ProcessInputWithContextFunction↑j
code:00000266                                         ; ConnectMenu:HandleKey↓p
code:00000266                 cjne    A, #0x18, DoContextFunction ; CANcel character
code:00000269
code:00000269 SetNormalInputMode:                     ; CODE XREF: RESET_0+70↑p
code:00000269                                         ; ModifySetting↓p ...
code:00000269                 mov     ContextFunctionPtr+1, #(TypeCharToScreen & 0xFF) ; A = character to print at cursor
code:00000269                                         ;
code:00000269                                         ; Uses cursor position.  Reacts to special characters.
code:00000269                                         ; Updates cursor position.
code:0000026C                 mov     ContextFunctionPtr, #(TypeCharToScreen >> 8) ; A = character to print at cursor
code:0000026C                                         ;
code:0000026C                                         ; Uses cursor position.  Reacts to special characters.
code:0000026C                                         ; Updates cursor position.
code:0000026F                 ret
code:00000270 ; ---------------------------------------------------------------------------
code:00000270
code:00000270 DoContextFunction:                      ; CODE XREF: CallContextFunction↑j
code:00000270                 push    ContextFunctionPtr+1 ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00000272                 push    ContextFunctionPtr ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00000274
code:00000274 ReturnGate_12:                          ; CODE XREF: TypeCharToScreen+11↓j
code:00000274                 ret
code:00000274 ; End of function CallContextFunction
code:00000274
code:00000275
code:00000275 ; =============== S U B R O U T I N E =======================================
code:00000275
code:00000275 ; A = character to print at cursor
code:00000275 ;
code:00000275 ; Uses cursor position.  Reacts to special characters.
code:00000275 ; Updates cursor position.
code:00000275
code:00000275 TypeCharToScreen:                       ; DATA XREF: CallContextFunction:SetNormalInputMode↑o
code:00000275                                         ; CallContextFunction+6↑o
code:00000275                 cjne    A, #0x7F, code_279 ; 7F is NUL
code:00000278
code:00000278
code:00000278                 ret
code:00000279 ; ---------------------------------------------------------------------------
code:00000279
code:00000279 code_279:                               ; CODE XREF: TypeCharToScreen↑j
code:00000279                 cjne    A, #' , code_27C
code:0000027C
code:0000027C code_27C:                               ; CODE XREF: TypeCharToScreen:code_279↑j
code:0000027C                 jnc     NotCtrl
code:0000027E
code:0000027E
code:0000027E                 mov     B, #7           ; B-Register
code:00000281                 mov     DPTR, #jt_SpecialChars
code:00000284                 acall   LookupFunctionByTag ; A = tag to look for
code:00000284                                         ; B = number of tags in list
code:00000284                                         ;
code:00000284                                         ; On return:
code:00000284                                         ;
code:00000284                                         ; C = found tag
code:00000284                                         ; DPTR = function ptr for tag
code:00000286                 jc      ReturnGate_12   ; Ignore unknown control codes
code:00000288
code:00000288
code:00000288                 clr     A
code:00000289                 jmp     @A+DPTR
code:0000028A ; ---------------------------------------------------------------------------
code:0000028A
code:0000028A NotCtrl:                                ; CODE XREF: TypeCharToScreen:code_27C↑j
code:0000028A                 jnb     VideoSettings.7, TypeCharAsIs ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000028A                                         ; Bit 1 = Receive buffer is full
code:0000028A                                         ; Bit 3 = Serial send register busy
code:0000028A                                         ; Bit 4 = Busy drawing to screen
code:0000028A                                         ; Bit 5 = Steady/Blink
code:0000028A                                         ; Bit 6 = Disable keyboard
code:0000028A                                         ; Bit 7 = Standard/Graphics
code:0000028D
code:0000028D
code:0000028D                 cjne    A, #0x5E, IsGraphics ; Chars beyond 5E are graphic chars in VT52
code:00000290
code:00000290
code:00000290                 mov     A, #0x7F        ; Non-breaking space
code:00000292                 ajmp    TypeCharAsIs
code:00000294 ; ---------------------------------------------------------------------------
code:00000294
code:00000294 ;
code:00000294 ; Graphics characters in terminal memory occupy the first
code:00000294 ; 32 character slots
code:00000294 ;
code:00000294
code:00000294 IsGraphics:                             ; CODE XREF: TypeCharToScreen+18↑j
code:00000294                 jc      TypeCharAsIs
code:00000296
code:00000296
code:00000296                 anl     A, #0x1F        ; Apparently the graphics chars are stored in the control char
code:00000296                                         ; slots
code:00000298
code:00000298 TypeCharAsIs:                           ; CODE XREF: TypeCharToScreen:NotCtrl↑j
code:00000298                                         ; TypeCharToScreen+1D↑j ...
code:00000298                 push    ACC             ; Accumulator
code:0000029A
code:0000029A ; Save what's already there
code:0000029A                 mov     DPH, CursorAddr ; Data Pointer, High Byte
code:0000029D                 mov     DPL, CursorAddr+1 ; Data Pointer, Low Byte
code:000002A0                 movx    A, @DPTR
code:000002A1                 mov     B, A            ; B-Register
code:000002A3
code:000002A3 ; Overwrite it
code:000002A3                 pop     ACC             ; Accumulator
code:000002A5                 movx    @DPTR, A
code:000002A6
code:000002A6
code:000002A6                 mov     A, CursorColumn
code:000002A8                 cjne    A, #79, NormalAdvance
code:000002AB
code:000002AB ;
code:000002AB ; Are we wrapping to next line?
code:000002AB ;
code:000002AB                 jb      SerialSettings.7, Done ; Bit 0 = Clock display off
code:000002AB                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000002AB                                         ; Bit 2 = Half/Full duplex
code:000002AB                                         ; Bit 3 = Auto Repeat disable
code:000002AB                                         ; Bit 4 = Key click disable
code:000002AB                                         ; Bit 5 = LF->CRLF
code:000002AB                                         ; Bit 6 = CR->CRLF
code:000002AB                                         ; Bit 7 = Wrap at EOL off
code:000002AE                 ajmp    TypeCRLF
code:000002B0 ; ---------------------------------------------------------------------------
code:000002B0
code:000002B0 NormalAdvance:                          ; CODE XREF: TypeCharToScreen+33↑j
code:000002B0                 jnb     B7, PrevWasNormal ; Was the previous character a special attribute?
code:000002B3
code:000002B3 ;
code:000002B3 ; See if there are at least 2 characters from cursor to
code:000002B3 ; end of line
code:000002B3 ;
code:000002B3                 acall   CalcCursorEndOfLine ; Expects to be in register bank 0
code:000002B3                                         ;
code:000002B3                                         ; Sets R1:R0 to the end of line pointer
code:000002B3                                         ; Sets B to the difference between current address and end of
code:000002B3                                         ; line
code:000002B5                 djnz    B, code_2BA     ; B-Register
code:000002B8
code:000002B8
code:000002B8                 ajmp    LoadAddr
code:000002BA ; ---------------------------------------------------------------------------
code:000002BA
code:000002BA code_2BA:                               ; CODE XREF: TypeCharToScreen+40↑j
code:000002BA                 djnz    B, DeleteAChar  ; B-Register
code:000002BD
code:000002BD
code:000002BD                 ajmp    LoadAddr
code:000002BF ; ---------------------------------------------------------------------------
code:000002BF
code:000002BF ;
code:000002BF ; Delete the character following the attribute modifier that
code:000002BF ; we just overwrote
code:000002BF ;
code:000002BF
code:000002BF DeleteAChar:                            ; CODE XREF: TypeCharToScreen:code_2BA↑j
code:000002BF                 inc     DPTR
code:000002C0                 acall   DeleteCharOnLine ; Pulls a character string left by a cell, simulating
code:000002C0                                         ; backspace
code:000002C0                                         ;
code:000002C0                                         ; DPTR+1 = source address
code:000002C0                                         ; DPTR = destination address
code:000002C0                                         ; B = number of chars to move
code:000002C2
code:000002C2 LoadAddr:                               ; CODE XREF: TypeCharToScreen+43↑j
code:000002C2                                         ; TypeCharToScreen+48↑j
code:000002C2                 mov     DPL, CursorAddr+1 ; Data Pointer, Low Byte
code:000002C5                 mov     DPH, CursorAddr ; Data Pointer, High Byte
code:000002C8
code:000002C8 PrevWasNormal:                          ; CODE XREF: TypeCharToScreen:NormalAdvance↑j
code:000002C8                 inc     CursorColumn
code:000002CA                 inc     DPTR
code:000002CB                 mov     CursorAddr+1, DPL ; Data Pointer, Low Byte
code:000002CE                 mov     CursorAddr, DPH ; Data Pointer, High Byte
code:000002D1
code:000002D1 Done:                                   ; CODE XREF: TypeCharToScreen+36↑j
code:000002D1                 ret
code:000002D1 ; ---------------------------------------------------------------------------
code:000002D2 jt_SpecialChars:.byte 5                 ; DATA XREF: TypeCharToScreen+C↑o
code:000002D2                                         ; Instead of ignoring 5 as an unknown char, we will ignore it
code:000002D2                                         ; as a known char.  Don't ask me...
code:000002D3                 .word nullsub_3
code:000002D5                 .byte 0xD
code:000002D6                 .word MoveBeginning
code:000002D8                 .byte 0xA
code:000002D9                 .word TypeLF
code:000002DB                 .byte 9
code:000002DC                 .word MoveAsTab
code:000002DE                 .byte 0x1B
code:000002DF                 .word SetESCCodeInterpretMode
code:000002E1                 .byte 8
code:000002E2                 .word CursorLeft
code:000002E4                 .byte 7
code:000002E5                 .word ExecuteBell
code:000002E5 ; End of function TypeCharToScreen
code:000002E5
code:000002E7
code:000002E7 ; =============== S U B R O U T I N E =======================================
code:000002E7
code:000002E7 ; A = tag to look for
code:000002E7 ; B = number of tags in list
code:000002E7 ;
code:000002E7 ; On return:
code:000002E7 ;
code:000002E7 ; C = found tag
code:000002E7 ; DPTR = function ptr for tag
code:000002E7
code:000002E7 LookupFunctionByTag:                    ; CODE XREF: TypeCharToScreen+F↑p
code:000002E7                                         ; JmpSpecialFunction↓p
code:000002E7                 mov     R4, A
code:000002E8
code:000002E8 TagLoop:                                ; CODE XREF: LookupFunctionByTag+17↓j
code:000002E8                 clr     A
code:000002E9                 movc    A, @A+DPTR
code:000002EA                 inc     DPTR
code:000002EB                 cjne    A, B0R4, NextTag
code:000002EE
code:000002EE
code:000002EE                 clr     A
code:000002EF                 movc    A, @A+DPTR
code:000002F0                 push    ACC             ; Accumulator
code:000002F2                 inc     DPTR
code:000002F3                 clr     A
code:000002F4                 movc    A, @A+DPTR
code:000002F5                 mov     DPL, A          ; Data Pointer, Low Byte
code:000002F7                 pop     DPH             ; Data Pointer, High Byte
code:000002F9                 mov     A, R4
code:000002FA                 clr     C
code:000002FB                 ret
code:000002FC ; ---------------------------------------------------------------------------
code:000002FC
code:000002FC NextTag:                                ; CODE XREF: LookupFunctionByTag+4↑j
code:000002FC                 inc     DPTR
code:000002FD                 inc     DPTR
code:000002FE                 djnz    B, TagLoop      ; B-Register
code:00000301
code:00000301
code:00000301                 mov     A, R4
code:00000302                 setb    C
code:00000303                 ret
code:00000303 ; End of function LookupFunctionByTag
code:00000303
code:00000304
code:00000304 ; =============== S U B R O U T I N E =======================================
code:00000304
code:00000304
code:00000304 TimeBasedUpdates:                       ; CODE XREF: IE1:UpdateTime↑p
code:00000304                 mov     A, BellDurationCounter
code:00000306                 jz      CheckTimeUpdateCounter
code:00000308
code:00000308
code:00000308                 clr     T1              ; Port 3
code:0000030A                 djnz    BellDurationCounter, CheckTimeUpdateCounter
code:0000030D
code:0000030D
code:0000030D                 setb    T1              ; Port 3
code:0000030F
code:0000030F CheckTimeUpdateCounter:                 ; CODE XREF: TimeBasedUpdates+2↑j
code:0000030F                                         ; TimeBasedUpdates+6↑j
code:0000030F                 djnz    TimeUpdateCounter, ReturnGate_4
code:00000312
code:00000312
code:00000312                 jb      PrinterStatus.4, AdvanceTime ; Bit 0 = Printer
code:00000312                                         ; Bit 1 = Need to send XOFF
code:00000312                                         ; Bit 2 = Toggle printer state
code:00000312                                         ; Bit 3 = No writes to status line
code:00000312                                         ;         No update of time or print status.  Set cursor position ESC
code:00000312                                         ;         code cannot set cursor to row 1
code:00000312                                         ; Bit 4 = No writes to status line
code:00000312                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000312                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000312                                         ;         position to row 1
code:00000312                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000312                                         ; Bit 6 = Key pressed
code:00000312                                         ; Bit 7 = Repeat eligible
code:00000315                 jb      PrinterStatus.3, AdvanceTime ; Bit 0 = Printer
code:00000315                                         ; Bit 1 = Need to send XOFF
code:00000315                                         ; Bit 2 = Toggle printer state
code:00000315                                         ; Bit 3 = No writes to status line
code:00000315                                         ;         No update of time or print status.  Set cursor position ESC
code:00000315                                         ;         code cannot set cursor to row 1
code:00000315                                         ; Bit 4 = No writes to status line
code:00000315                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000315                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000315                                         ;         position to row 1
code:00000315                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000315                                         ; Bit 6 = Key pressed
code:00000315                                         ; Bit 7 = Repeat eligible
code:00000318                 jb      SerialSettings.0, AdvanceTime ; Bit 0 = Clock display off
code:00000318                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000318                                         ; Bit 2 = Half/Full duplex
code:00000318                                         ; Bit 3 = Auto Repeat disable
code:00000318                                         ; Bit 4 = Key click disable
code:00000318                                         ; Bit 5 = LF->CRLF
code:00000318                                         ; Bit 6 = CR->CRLF
code:00000318                                         ; Bit 7 = Wrap at EOL off
code:0000031B
code:0000031B
code:0000031B                 acall   WriteTime       ; Writes the digits specified in RAM location 54 to upper right line on the screen
code:0000031D
code:0000031D AdvanceTime:                            ; CODE XREF: TimeBasedUpdates+E↑j
code:0000031D                                         ; TimeBasedUpdates+11↑j ...
code:0000031D                 mov     TimeUpdateCounter, #60
code:00000320
code:00000320
code:00000320                 mov     R0, #TimeDigitsINT
code:00000322                 mov     A, #'0
code:00000324                 inc     @R0
code:00000325                 cjne    @R0, #':, ReturnGate_4
code:00000328
code:00000328
code:00000328                 mov     @R0, A
code:00000329
code:00000329
code:00000329                 inc     R0
code:0000032A                 inc     @R0
code:0000032B                 cjne    @R0, #'6, ReturnGate_4
code:0000032E
code:0000032E
code:0000032E                 mov     @R0, A
code:0000032F
code:0000032F
code:0000032F                 inc     R0
code:00000330                 inc     @R0
code:00000331                 cjne    @R0, #':, ReturnGate_4
code:00000334
code:00000334
code:00000334                 mov     @R0, A
code:00000335
code:00000335
code:00000335                 inc     R0
code:00000336                 inc     @R0
code:00000337                 cjne    @R0, #'6, ReturnGate_4
code:0000033A
code:0000033A
code:0000033A                 mov     @R0, A
code:0000033B
code:0000033B
code:0000033B                 inc     R0
code:0000033C                 inc     @R0
code:0000033D                 inc     R0
code:0000033E                 cjne    @R0, #'2, Hours09Check
code:00000341
code:00000341
code:00000341                 dec     R0
code:00000342                 cjne    @R0, #'4, ReturnGate_4
code:00000345
code:00000345
code:00000345                 mov     @R0, A
code:00000346                 inc     R0
code:00000347                 mov     @R0, A
code:00000348
code:00000348 ReturnGate_4:                           ; CODE XREF: TimeBasedUpdates:CheckTimeUpdateCounter↑j
code:00000348                                         ; TimeBasedUpdates+21↑j ...
code:00000348                 ret
code:00000349 ; ---------------------------------------------------------------------------
code:00000349
code:00000349 Hours09Check:                           ; CODE XREF: TimeBasedUpdates+3A↑j
code:00000349                 dec     R0
code:0000034A                 cjne    @R0, #':, ReturnGate_4
code:0000034D
code:0000034D
code:0000034D                 mov     @R0, A
code:0000034E                 inc     R0
code:0000034F                 inc     @R0
code:00000350                 ret
code:00000350 ; End of function TimeBasedUpdates
code:00000350
code:00000351
code:00000351 ; =============== S U B R O U T I N E =======================================
code:00000351
code:00000351
code:00000351 ShowClock:                              ; DATA XREF: InterpretESC+1A↓o
code:00000351                 clr     SerialSettings.0 ; Bit 0 = Clock display off
code:00000351                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000351                                         ; Bit 2 = Half/Full duplex
code:00000351                                         ; Bit 3 = Auto Repeat disable
code:00000351                                         ; Bit 4 = Key click disable
code:00000351                                         ; Bit 5 = LF->CRLF
code:00000351                                         ; Bit 6 = CR->CRLF
code:00000351                                         ; Bit 7 = Wrap at EOL off
code:00000353                 jb      PrinterStatus.4, ReturnGate_4 ; Bit 0 = Printer
code:00000353                                         ; Bit 1 = Need to send XOFF
code:00000353                                         ; Bit 2 = Toggle printer state
code:00000353                                         ; Bit 3 = No writes to status line
code:00000353                                         ;         No update of time or print status.  Set cursor position ESC
code:00000353                                         ;         code cannot set cursor to row 1
code:00000353                                         ; Bit 4 = No writes to status line
code:00000353                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000353                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000353                                         ;         position to row 1
code:00000353                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000353                                         ; Bit 6 = Key pressed
code:00000353                                         ; Bit 7 = Repeat eligible
code:00000356                 jb      PrinterStatus.3, ReturnGate_4 ; Bit 0 = Printer
code:00000356 ; End of function ShowClock             ; Bit 1 = Need to send XOFF
code:00000356                                         ; Bit 2 = Toggle printer state
code:00000356                                         ; Bit 3 = No writes to status line
code:00000356                                         ;         No update of time or print status.  Set cursor position ESC
code:00000356                                         ;         code cannot set cursor to row 1
code:00000356                                         ; Bit 4 = No writes to status line
code:00000356                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000356                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000356                                         ;         position to row 1
code:00000356                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000356                                         ; Bit 6 = Key pressed
code:00000356                                         ; Bit 7 = Repeat eligible
code:00000359
code:00000359 ; =============== S U B R O U T I N E =======================================
code:00000359
code:00000359 ; Writes the digits specified in RAM location 54 to upper right line on the screen
code:00000359
code:00000359 WriteTime:                              ; CODE XREF: TimeBasedUpdates+17↑p
code:00000359                                         ; UpdateStatusLine+44↓j
code:00000359                 mov     DPTR, #Time
code:0000035C                 mov     R0, #(TimeDigitsINT+5)
code:0000035E                 acall   TwoBytesToVideoRAM ; Writes memory at R0 and R0-1 to video memory (reverses order)
code:0000035E                                         ;
code:0000035E                                         ; R0 = memory src
code:0000035E                                         ; DPTR = memory dest
code:0000035E                                         ;
code:0000035E                                         ; On return:
code:0000035E                                         ;
code:0000035E                                         ; R0=R0-2
code:00000360                 acall   WriteFormattedTimeString ; Writes a : followed by two bytes from R0 to video RAM.  R0 counts down instead of up.
code:00000362
code:00000362 ;
code:00000362 ; Fall through to write another : and two digits
code:00000362 ;
code:00000362
code:00000362 WriteFormattedTimeString:               ; CODE XREF: WriteTime+7↑p
code:00000362                 mov     A, #':          ; Writes a : followed by two bytes from R0 to video RAM.  R0 counts down instead of up.
code:00000364                 inc     R0
code:00000365                 acall   WriteTheByte    ; A = value to write
code:00000365                                         ; DPTR = memory dest
code:00000365                                         ;
code:00000365                                         ; On return:
code:00000365                                         ;
code:00000365                                         ; R0=R0-1
code:00000367
code:00000367 ;
code:00000367 ; Fall through to write two more digits
code:00000367 ;
code:00000367
code:00000367 TwoBytesToVideoRAM:                     ; CODE XREF: WriteTime+5↑p
code:00000367                 acall   ByteToVideoRAM  ; Writes memory at R0 and R0-1 to video memory (reverses order)
code:00000367                                         ;
code:00000367                                         ; R0 = memory src
code:00000367                                         ; DPTR = memory dest
code:00000367                                         ;
code:00000367                                         ; On return:
code:00000367                                         ;
code:00000367                                         ; R0=R0-2
code:00000369
code:00000369 ;
code:00000369 ; Fall through to load the second digit
code:00000369 ;
code:00000369
code:00000369 ByteToVideoRAM:                         ; CODE XREF: WriteTime:TwoBytesToVideoRAM↑p
code:00000369                 mov     A, @R0          ; R0 = memory src
code:00000369                                         ; DPTR = memory dest
code:00000369                                         ;
code:00000369                                         ; On return:
code:00000369                                         ;
code:00000369                                         ; R0=R0-1
code:0000036A
code:0000036A ;
code:0000036A ; Fall through to write the second digit
code:0000036A ;
code:0000036A
code:0000036A WriteTheByte:                           ; CODE XREF: WriteTime+C↑p
code:0000036A                 movx    @DPTR, A        ; A = value to write
code:0000036A                                         ; DPTR = memory dest
code:0000036A                                         ;
code:0000036A                                         ; On return:
code:0000036A                                         ;
code:0000036A                                         ; R0=R0-1
code:0000036B                 inc     DPTR
code:0000036C                 dec     R0
code:0000036D                 ret
code:0000036D ; End of function WriteTime
code:0000036D
code:0000036E
code:0000036E ; =============== S U B R O U T I N E =======================================
code:0000036E
code:0000036E ; Register bank should be 1 at entrance to this call
code:0000036E
code:0000036E ResetDisplay:                           ; CODE XREF: IE1+42↑p
code:0000036E                                         ; RESET_0+31↑p
code:0000036E                 push    IE              ; Interrupt Enable Register
code:00000370                 clr     EA              ; Interrupt Enable Register
code:00000372
code:00000372
code:00000372                 mov     R1, #2
code:00000374                 mov     R3, #(VideoLine1 & 0xFF)
code:00000376                 mov     R2, #(VideoLine1 >> 8)
code:00000378
code:00000378
code:00000378                 mov     B, #9           ; Set 20 counts per horizontal retrace; Cursor blinks and is
code:00000378                                         ; reverse video; Transparent field attributes
code:0000037B                 jnb     VideoSettings.5, code_380 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000037B                                         ; Bit 1 = Receive buffer is full
code:0000037B                                         ; Bit 3 = Serial send register busy
code:0000037B                                         ; Bit 4 = Busy drawing to screen
code:0000037B                                         ; Bit 5 = Steady/Blink
code:0000037B                                         ; Bit 6 = Disable keyboard
code:0000037B                                         ; Bit 7 = Standard/Graphics
code:0000037E
code:0000037E
code:0000037E                 setb    B5              ; Set blinking underline
code:00000380
code:00000380 code_380:                               ; CODE XREF: ResetDisplay+D↑j
code:00000380                 acall   SetVidMode
code:00000382
code:00000382
code:00000382                 acall   SendCursorPos   ; Sends the current cursor row and column to the CRTC.  If
code:00000382                                         ; video is busy, move cursor offscreen.
code:00000384
code:00000384
code:00000384                 mov     DPTR, #CRTC_CREG
code:00000387
code:00000387
code:00000387                 mov     A, #0xE0        ; Preset counters
code:00000389                 movx    @DPTR, A
code:0000038A
code:0000038A
code:0000038A                 mov     A, #0xC0        ; Disable interrupt
code:0000038C                 movx    @DPTR, A
code:0000038D
code:0000038D
code:0000038D                 setb    IT0             ; Timer 0/1 Control Register
code:0000038F                 clr     IE0             ; Timer 0/1 Control Register
code:00000391                 setb    IT1             ; Timer 0/1 Control Register
code:00000393                 clr     IE1             ; Timer 0/1 Control Register
code:00000395
code:00000395
code:00000395
code:00000395 code_395:                               ; CODE XREF: ModifySetting+A8↓j
code:00000395                 mov     DPTR, #CRTC_CREG
code:00000398
code:00000398
code:00000398                 mov     A, #0x23        ; Start display: 0 delay, 8 char DMA
code:0000039A                 movx    @DPTR, A
code:0000039B
code:0000039B
code:0000039B                 pop     IE              ; Interrupt Enable Register
code:0000039D                 ret
code:0000039D ; End of function ResetDisplay
code:0000039D
code:0000039E
code:0000039E ; =============== S U B R O U T I N E =======================================
code:0000039E
code:0000039E
code:0000039E SetVidMode:                             ; CODE XREF: ResetDisplay:code_380↑p
code:0000039E                                         ; ModifySetting+A3↓p
code:0000039E                 mov     DPTR, #CRTC_CREG
code:000003A1                 clr     A
code:000003A2                 movx    @DPTR, A
code:000003A3
code:000003A3
code:000003A3                 mov     DPTR, #CRTC_PREG
code:000003A6                 mov     A, #0x4F        ; Non-spaced rows, 80 characters
code:000003A8                 movx    @DPTR, A
code:000003A9
code:000003A9
code:000003A9                 mov     A, #0x58        ; 2 counts per retrace, 24 columns
code:000003AB                 movx    @DPTR, A
code:000003AC
code:000003AC
code:000003AC                 mov     A, #9
code:000003AE                 movx    @DPTR, A
code:000003AF
code:000003AF
code:000003AF                 mov     A, B            ; B-Register
code:000003B1                 movx    @DPTR, A
code:000003B2                 ret
code:000003B2 ; End of function SetVidMode
code:000003B2
code:000003B3
code:000003B3 ; =============== S U B R O U T I N E =======================================
code:000003B3
code:000003B3 ; Sends the current cursor row and column to the CRTC.  If
code:000003B3 ; video is busy, move cursor offscreen.
code:000003B3
code:000003B3 SendCursorPos:                          ; CODE XREF: IE1+39↑p
code:000003B3                                         ; ResetDisplay+14↑p
code:000003B3                 mov     DPTR, #CRTC_CREG
code:000003B6                 mov     A, #0x80        ; Load cursor position
code:000003B8                 movx    @DPTR, A
code:000003B9
code:000003B9
code:000003B9                 mov     DPTR, #CRTC_PREG
code:000003BC                 mov     A, CursorColumn
code:000003BE                 movx    @DPTR, A
code:000003BF                 mov     A, CursorRow
code:000003C1
code:000003C1
code:000003C1                 jnb     VideoSettings.4, code_3C6 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000003C1                                         ; Bit 1 = Receive buffer is full
code:000003C1                                         ; Bit 3 = Serial send register busy
code:000003C1                                         ; Bit 4 = Busy drawing to screen
code:000003C1                                         ; Bit 5 = Steady/Blink
code:000003C1                                         ; Bit 6 = Disable keyboard
code:000003C1                                         ; Bit 7 = Standard/Graphics
code:000003C4
code:000003C4
code:000003C4                 mov     A, #26
code:000003C6
code:000003C6 code_3C6:                               ; CODE XREF: SendCursorPos+E↑j
code:000003C6                 movx    @DPTR, A
code:000003C7                 ret
code:000003C7 ; End of function SendCursorPos
code:000003C7
code:000003C8
code:000003C8 ; =============== S U B R O U T I N E =======================================
code:000003C8
code:000003C8 ; Sets the line numbers to 0-24 in order and clears the screen
code:000003C8
code:000003C8 InitLineMap:                            ; CODE XREF: RESET_0+6C↑p
code:000003C8                                         ; CheckAndInitDirectory+1B↓p ...
code:000003C8                 clr     A
code:000003C9                 mov     R0, #LineNumbers ; In order to make scrolling faster, the system does not
code:000003C9                                         ; actually move data around.  Instead, it uses this array of
code:000003C9                                         ; lines as a list of indices into VRAM.  To scroll the
code:000003C9                                         ; screen, just rotate these numbers so that what was once
code:000003C9                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:000003C9                                         ; scroll operation.
code:000003CB                 mov     R1, #25
code:000003CD
code:000003CD LineIndexLoop:                          ; CODE XREF: InitLineMap+8↓j
code:000003CD                 mov     @R0, A
code:000003CE                 inc     R0
code:000003CF                 inc     A
code:000003D0                 djnz    R1, LineIndexLoop
code:000003D0 ; End of function InitLineMap
code:000003D0
code:000003D2
code:000003D2 ; =============== S U B R O U T I N E =======================================
code:000003D2
code:000003D2
code:000003D2 ClearScreen:                            ; CODE XREF: ConnectMenu:ClearTTY↓p
code:000003D2                 mov     DPTR, #VideoLine2
code:000003D5                 mov     R2, #24
code:000003D7
code:000003D7 ClearNLines:                            ; CODE XREF: ClearScreen+7↓j
code:000003D7                                         ; ManualDial+5↓p ...
code:000003D7                 acall   ClearLineBytes  ; DPTR = line pointer
code:000003D7                                         ;
code:000003D7                                         ; Low-level routine to clear a line
code:000003D9                 djnz    R2, ClearNLines
code:000003DB
code:000003DB ReturnGate_13:                          ; CODE XREF: ClearTopLineIfDisabled↓j
code:000003DB                 ret
code:000003DB ; End of function ClearScreen
code:000003DB
code:000003DC
code:000003DC ; =============== S U B R O U T I N E =======================================
code:000003DC
code:000003DC
code:000003DC ClearTopLineIfDisabled:                 ; DATA XREF: InterpretESC+1A↓o
code:000003DC                 jnb     PrinterStatus.4, ReturnGate_13 ; Bit 0 = Printer
code:000003DC ; End of function ClearTopLineIfDisabled ; Bit 1 = Need to send XOFF
code:000003DC                                         ; Bit 2 = Toggle printer state
code:000003DC                                         ; Bit 3 = No writes to status line
code:000003DC                                         ;         No update of time or print status.  Set cursor position ESC
code:000003DC                                         ;         code cannot set cursor to row 1
code:000003DC                                         ; Bit 4 = No writes to status line
code:000003DC                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000003DC                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000003DC                                         ;         position to row 1
code:000003DC                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000003DC                                         ; Bit 6 = Key pressed
code:000003DC                                         ; Bit 7 = Repeat eligible
code:000003DF
code:000003DF ; =============== S U B R O U T I N E =======================================
code:000003DF
code:000003DF
code:000003DF ClearTopLine:                           ; CODE XREF: RESET_0+6E↑p
code:000003DF                                         ; ModifySetting+2E↓j ...
code:000003DF                 mov     DPTR, #VideoLine1
code:000003DF ; End of function ClearTopLine
code:000003DF
code:000003E2
code:000003E2 ; =============== S U B R O U T I N E =======================================
code:000003E2
code:000003E2 ; DPTR = line pointer
code:000003E2 ;
code:000003E2 ; Low-level routine to clear a line
code:000003E2
code:000003E2 ClearLineBytes:                         ; CODE XREF: ClearScreen:ClearNLines↑p
code:000003E2                                         ; ClearLine+D↓j
code:000003E2                 mov     B, #96          ; B-Register
code:000003E5
code:000003E5 memset_spaces:                          ; CODE XREF: ClearHomeToCursor+2C↓p
code:000003E5                                         ; ClearToEndOfScreen+19↓j ...
code:000003E5                 mov     A, #'           ; B = count
code:000003E5 ; End of function ClearLineBytes        ; DPTR = address
code:000003E5
code:000003E7
code:000003E7 ; =============== S U B R O U T I N E =======================================
code:000003E7
code:000003E7 ; A = value; B = count; DPTR = address
code:000003E7
code:000003E7 memset:                                 ; CODE XREF: RESET_0+2D↑p
code:000003E7                                         ; memset+2↓j
code:000003E7                 movx    @DPTR, A
code:000003E8                 inc     DPTR
code:000003E9                 djnz    B, memset       ; A = value; B = count; DPTR = address
code:000003EC                 ret
code:000003EC ; End of function memset
code:000003EC
code:000003ED
code:000003ED ; =============== S U B R O U T I N E =======================================
code:000003ED
code:000003ED
code:000003ED MoveBeginning:                          ; DATA XREF: TypeCharToScreen+61↑o
code:000003ED                 jb      SerialSettings.6, TypeCRLF ; Bit 0 = Clock display off
code:000003ED ; End of function MoveBeginning         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000003ED                                         ; Bit 2 = Half/Full duplex
code:000003ED                                         ; Bit 3 = Auto Repeat disable
code:000003ED                                         ; Bit 4 = Key click disable
code:000003ED                                         ; Bit 5 = LF->CRLF
code:000003ED                                         ; Bit 6 = CR->CRLF
code:000003ED                                         ; Bit 7 = Wrap at EOL off
code:000003F0
code:000003F0 ; =============== S U B R O U T I N E =======================================
code:000003F0
code:000003F0 ; Calculates the cursor address for the start of the line
code:000003F0
code:000003F0 TypeCR:                                 ; CODE XREF: TypeLF:TypeCRLF↓p
code:000003F0                 mov     CursorColumn, #0
code:000003F0 ; End of function TypeCR
code:000003F0
code:000003F3
code:000003F3 ; =============== S U B R O U T I N E =======================================
code:000003F3
code:000003F3 ; Updates the CursorAddr pointer using the cursor row and
code:000003F3 ; column and the line table for calculation.
code:000003F3 ;
code:000003F3 ; Does not account for attributes in the row.  This is a
code:000003F3 ; bug.
code:000003F3
code:000003F3 CalcCursorAddr:                         ; CODE XREF: ClearLineAtCursor+5↓j
code:000003F3                                         ; ConnectMenu-7ED↓j ...
code:000003F3                 acall   CalcCursorLinePtr ; Using CursorRow and the LineNumbers table, calculate the
code:000003F3                                         ; start of the cursor's line from a base of 0
code:000003F3                                         ;
code:000003F3                                         ; Returns value in B:A
code:000003F5
code:000003F5
code:000003F5                 add     A, CursorColumn
code:000003F7                 mov     CursorAddr+1, A
code:000003F9                 mov     A, B            ; B-Register
code:000003FB                 addc    A, #(VideoLine1 >> 8)
code:000003FD                 mov     CursorAddr, A
code:000003FF                 ret
code:000003FF ; End of function CalcCursorAddr
code:000003FF
code:00000400
code:00000400 ; =============== S U B R O U T I N E =======================================
code:00000400
code:00000400 ; Updates the DPTR register using the cursor row and
code:00000400 ; column and the line table for calculation.
code:00000400 ;
code:00000400 ; Does not account for attributes in the row.  This is a
code:00000400 ; bug.
code:00000400
code:00000400 CalcCursorDPTR:                         ; CODE XREF: SendCharUnderCursor↓p
code:00000400                                         ; SendCharUnderCursor+26↓p ...
code:00000400                 acall   CalcCursorLinePtr ; Using CursorRow and the LineNumbers table, calculate the
code:00000400                                         ; start of the cursor's line from a base of 0
code:00000400                                         ;
code:00000400                                         ; Returns value in B:A
code:00000402                 add     A, CursorColumn
code:00000404                 mov     DPL, A          ; Data Pointer, Low Byte
code:00000406                 mov     A, B            ; B-Register
code:00000408                 addc    A, #(VideoLine1 >> 8)
code:0000040A                 mov     DPH, A          ; Data Pointer, High Byte
code:0000040C                 ret
code:0000040C ; End of function CalcCursorDPTR
code:0000040C
code:0000040D
code:0000040D ; =============== S U B R O U T I N E =======================================
code:0000040D
code:0000040D ; Using CursorRow and the LineNumbers table, calculate the
code:0000040D ; start of the cursor's line from a base of 0
code:0000040D ;
code:0000040D ; Returns value in B:A
code:0000040D
code:0000040D CalcCursorLinePtr:                      ; CODE XREF: CalcCursorAddr↑p
code:0000040D                                         ; CalcCursorDPTR↑p ...
code:0000040D                 mov     A, CursorRow
code:0000040F
code:0000040F CalcLinePtr:                            ; CODE XREF: ClearLine+2↓p
code:0000040F                 add     A, #LineNumbers ; A = line index
code:0000040F                                         ;
code:0000040F                                         ; Using line index and the LineNumbers table, calculate the
code:0000040F                                         ; start of the cursor's line
code:00000411                 mov     R0, A
code:00000412                 mov     A, @R0
code:00000413                 mov     B, #96          ; B-Register
code:00000416                 mul     AB
code:00000417                 ret
code:00000417 ; End of function CalcCursorLinePtr
code:00000417
code:00000418
code:00000418 ; =============== S U B R O U T I N E =======================================
code:00000418
code:00000418
code:00000418 TypeLF:                                 ; DATA XREF: TypeCharToScreen+64↑o
code:00000418                 jnb     SerialSettings.5, NextLine ; Bit 0 = Clock display off
code:00000418                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000418                                         ; Bit 2 = Half/Full duplex
code:00000418                                         ; Bit 3 = Auto Repeat disable
code:00000418                                         ; Bit 4 = Key click disable
code:00000418                                         ; Bit 5 = LF->CRLF
code:00000418                                         ; Bit 6 = CR->CRLF
code:00000418                                         ; Bit 7 = Wrap at EOL off
code:0000041B
code:0000041B TypeCRLF:                               ; CODE XREF: TypeCharToScreen+39↑j
code:0000041B                                         ; MoveBeginning↑j
code:0000041B                 acall   TypeCR          ; Calculates the cursor address for the start of the line
code:0000041D
code:0000041D NextLine:                               ; CODE XREF: TypeLF↑j
code:0000041D                 mov     A, CursorRow
code:0000041F                 jz      ReturnGate_2
code:00000421
code:00000421
code:00000421                 inc     A
code:00000422                 cjne    A, #25, UpdateCursor
code:00000425
code:00000425 ;
code:00000425 ; Line number is 25, so time to scroll up and become 24 again
code:00000425 ;
code:00000425                 mov     B, #1           ; B-Register
code:00000428                 lcall   ClearLine       ; B = line index
code:00000428                                         ;
code:00000428                                         ; Clear the line
code:0000042B
code:0000042B
code:0000042B                 mov     A, #(LineNumbers+1) ; In order to make scrolling faster, the system does not
code:0000042B                                         ; actually move data around.  Instead, it uses this array of
code:0000042B                                         ; lines as a list of indices into VRAM.  To scroll the
code:0000042B                                         ; screen, just rotate these numbers so that what was once
code:0000042B                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:0000042B                                         ; scroll operation.
code:0000042D                 mov     R0, A
code:0000042E                 mov     R1, A
code:0000042F                 inc     R1
code:00000430                 mov     B0R5_MappedCursorRow, @R0 ; Save previous line 1 index
code:00000432
code:00000432 ;
code:00000432 ; Copy line indices up
code:00000432 ;
code:00000432                 mov     R4, #23
code:00000434                 clr     EA              ; Interrupt Enable Register
code:00000436
code:00000436 LineCopyLoop:                           ; CODE XREF: TypeLF+22↓j
code:00000436                 mov     A, @R1
code:00000437                 mov     @R0, A
code:00000438                 inc     R0
code:00000439                 inc     R1
code:0000043A                 djnz    R4, LineCopyLoop
code:0000043C
code:0000043C
code:0000043C                 mov     @R0, B0R5_MappedCursorRow ; Move previous line 1 index to 24 place
code:0000043E                 setb    EA              ; Interrupt Enable Register
code:00000440
code:00000440
code:00000440                 mov     A, CursorRow
code:00000442
code:00000442 UpdateCursor:                           ; CODE XREF: TypeLF+A↑j
code:00000442                 mov     CursorRow, A
code:00000444
code:00000444 CalcColumnPtr:                          ; CODE XREF: ReverseLineFeed+26↓j
code:00000444                                         ; CursorLeft+6↓p ...
code:00000444                 acall   CalcCursorLinePtr ; Find the address of the row and column, accounting for
code:00000444                                         ; attributes
code:00000446                 mov     DPL, A          ; Data Pointer, Low Byte
code:00000448                 mov     A, B            ; B-Register
code:0000044A                 add     A, #(VideoLine1 >> 8)
code:0000044C                 mov     DPH, A          ; Data Pointer, High Byte
code:0000044E
code:0000044E
code:0000044E                 mov     R0, #0
code:00000450
code:00000450 FindColumnLoop:                         ; CODE XREF: TypeLF+49↓j
code:00000450                 mov     A, R0
code:00000451                 cjne    A, CursorColumn, SkipFormat
code:00000454
code:00000454
code:00000454                 mov     CursorAddr+1, DPL ; Data Pointer, Low Byte
code:00000457                 mov     CursorAddr, DPH ; Data Pointer, High Byte
code:0000045A
code:0000045A ReturnGate_2:                           ; CODE XREF: TypeLF+7↑j
code:0000045A                                         ; ReverseLineFeed+2↓j
code:0000045A                 ret
code:0000045B ; ---------------------------------------------------------------------------
code:0000045B
code:0000045B SkipFormat:                             ; CODE XREF: TypeLF+39↑j
code:0000045B                                         ; TypeLF+45↓j
code:0000045B                 movx    A, @DPTR
code:0000045C                 inc     DPTR
code:0000045D                 jb      ACC7, SkipFormat ; Accumulator
code:00000460
code:00000460
code:00000460                 inc     R0
code:00000461                 ajmp    FindColumnLoop
code:00000461 ; End of function TypeLF
code:00000461
code:00000463
code:00000463 ; =============== S U B R O U T I N E =======================================
code:00000463
code:00000463 ; If cursor is at top of screen, scroll everything down.
code:00000463 ; Otherwise just move cursor up one.
code:00000463
code:00000463 ReverseLineFeed:                        ; DATA XREF: InterpretESC+1A↓o
code:00000463                 mov     A, CursorRow
code:00000465                 jz      ReturnGate_2
code:00000467
code:00000467
code:00000467                 dec     A
code:00000468                 jnz     code_487
code:0000046A
code:0000046A ;
code:0000046A ; Scroll everything down
code:0000046A ;
code:0000046A                 mov     B, #24          ; B-Register
code:0000046D                 lcall   ClearLine       ; B = line index
code:0000046D                                         ;
code:0000046D                                         ; Clear the line
code:00000470                 mov     A, #(LineNumbers+0x18) ; In order to make scrolling faster, the system does not
code:00000470                                         ; actually move data around.  Instead, it uses this array of
code:00000470                                         ; lines as a list of indices into VRAM.  To scroll the
code:00000470                                         ; screen, just rotate these numbers so that what was once
code:00000470                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:00000470                                         ; scroll operation.
code:00000472                 mov     R0, A
code:00000473                 mov     R1, A
code:00000474                 dec     R1
code:00000475                 mov     B0R5_MappedCursorRow, @R0
code:00000477
code:00000477 ;
code:00000477 ; No we're not actually moving video data.  Instead we're
code:00000477 ; rotating the line mapper around.
code:00000477 ;
code:00000477                 mov     R4, #23
code:00000479                 clr     EA              ; Interrupt Enable Register
code:0000047B
code:0000047B code_47B:                               ; CODE XREF: ReverseLineFeed+1C↓j
code:0000047B                 mov     A, @R1
code:0000047C                 mov     @R0, A
code:0000047D                 dec     R0
code:0000047E                 dec     R1
code:0000047F                 djnz    R4, code_47B
code:00000481
code:00000481
code:00000481                 mov     @R0, B0R5_MappedCursorRow
code:00000483                 setb    EA              ; Interrupt Enable Register
code:00000485
code:00000485
code:00000485                 mov     A, CursorRow
code:00000487
code:00000487 code_487:                               ; CODE XREF: ReverseLineFeed+5↑j
code:00000487                 mov     CursorRow, A
code:00000489                 sjmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:00000489 ; End of function ReverseLineFeed       ; attributes
code:00000489
code:0000048B
code:0000048B ; =============== S U B R O U T I N E =======================================
code:0000048B
code:0000048B
code:0000048B CursorLeft:                             ; CODE XREF: CursorLeft:TypeBackspace↓p
code:0000048B                                         ; DATA XREF: TypeCharToScreen+6D↑o ...
code:0000048B                 mov     A, CursorColumn
code:0000048D                 jz      code_49B
code:0000048F
code:0000048F
code:0000048F                 dec     CursorColumn
code:00000491                 acall   CalcColumnPtr   ; Find the address of the row and column, accounting for
code:00000491                                         ; attributes
code:00000493                 ret
code:00000494 ; ---------------------------------------------------------------------------
code:00000494
code:00000494 TypeBackspace:                          ; CODE XREF: EraseDialStringDigit+5↓j
code:00000494                                         ; DATA XREF: InterpretESC+1A↓o
code:00000494                 acall   CursorLeft
code:00000496                 jz      code_49B
code:00000498
code:00000498
code:00000498                 mov     A, #'
code:0000049A                 movx    @DPTR, A
code:0000049B
code:0000049B code_49B:                               ; CODE XREF: CursorLeft+2↑j
code:0000049B                                         ; CursorLeft+B↑j
code:0000049B                 ret
code:0000049B ; End of function CursorLeft
code:0000049B
code:0000049C
code:0000049C ; =============== S U B R O U T I N E =======================================
code:0000049C
code:0000049C
code:0000049C MoveAsTab:                              ; DATA XREF: TypeCharToScreen+67↑o
code:0000049C                 mov     A, CursorColumn
code:0000049E                 cjne    A, #79, code_4A2
code:000004A1                 ret
code:000004A2 ; ---------------------------------------------------------------------------
code:000004A2
code:000004A2 code_4A2:                               ; CODE XREF: MoveAsTab+2↑j
code:000004A2                 cjne    A, #71, code_4A5
code:000004A5
code:000004A5 code_4A5:                               ; CODE XREF: MoveAsTab:code_4A2↑j
code:000004A5                 jnc     code_4A9
code:000004A7                 orl     A, #7
code:000004A9
code:000004A9 code_4A9:                               ; CODE XREF: MoveAsTab:code_4A5↑j
code:000004A9                 inc     A
code:000004AA                 mov     CursorColumn, A
code:000004AC                 sjmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000004AC ; End of function MoveAsTab             ; attributes
code:000004AC
code:000004AE
code:000004AE ; =============== S U B R O U T I N E =======================================
code:000004AE
code:000004AE
code:000004AE SetTimeByESCCode:                       ; DATA XREF: InterpretESC+1A↓o
code:000004AE                 mov     Scratchpad, SP  ; Stack Pointer
code:000004B1
code:000004B1
code:000004B1                 acall   ReadDigit02     ; Read a digit between 0 and 2
code:000004B3                 jz      code_4E6
code:000004B5
code:000004B5
code:000004B5                 push    ACC             ; Accumulator
code:000004B7                 cjne    A, #'2, code_4BE
code:000004BA
code:000004BA
code:000004BA                 acall   ReadDigit03     ; Read a digit between 0 and 3
code:000004BC                 ajmp    code_4C0
code:000004BE ; ---------------------------------------------------------------------------
code:000004BE
code:000004BE code_4BE:                               ; CODE XREF: SetTimeByESCCode+9↑j
code:000004BE                 acall   ReadDigit09     ; Read a digit between 0 and 9
code:000004C0
code:000004C0 code_4C0:                               ; CODE XREF: SetTimeByESCCode+E↑j
code:000004C0                 jz      code_4E6
code:000004C2
code:000004C2
code:000004C2                 push    ACC             ; Accumulator
code:000004C4                 acall   ReadDigit05     ; Read a digit between 0 and 5
code:000004C6                 jz      code_4E6
code:000004C8
code:000004C8
code:000004C8                 push    ACC             ; Accumulator
code:000004CA                 acall   ReadDigit09     ; Read a digit between 0 and 9
code:000004CC                 jz      code_4E6
code:000004CE
code:000004CE
code:000004CE                 push    ACC             ; Accumulator
code:000004D0                 acall   ReadDigit05     ; Read a digit between 0 and 5
code:000004D2                 jz      code_4E6
code:000004D4
code:000004D4
code:000004D4                 push    ACC             ; Accumulator
code:000004D6                 acall   ReadDigit09     ; Read a digit between 0 and 9
code:000004D8                 jz      code_4E6
code:000004DA
code:000004DA ;
code:000004DA ; Each digit has been read and pushed onto the stack.
code:000004DA ; Loop popping each one and storing it into the time
code:000004DA ; digit string.
code:000004DA ;
code:000004DA                 push    ACC             ; Accumulator
code:000004DC                 mov     R0, #TimeDigitsINT
code:000004DE                 mov     R1, #6
code:000004E0
code:000004E0 StoreTimeLoop:                          ; CODE XREF: SetTimeByESCCode+36↓j
code:000004E0                 pop     ACC             ; Accumulator
code:000004E2                 mov     @R0, A
code:000004E3                 inc     R0
code:000004E4                 djnz    R1, StoreTimeLoop
code:000004E6
code:000004E6 code_4E6:                               ; CODE XREF: SetTimeByESCCode+5↑j
code:000004E6                                         ; SetTimeByESCCode:code_4C0↑j ...
code:000004E6                 mov     SP, Scratchpad  ; Stack Pointer
code:000004E9                 ret
code:000004E9 ; End of function SetTimeByESCCode
code:000004E9
code:000004EA
code:000004EA ; =============== S U B R O U T I N E =======================================
code:000004EA
code:000004EA ; Read a digit between 0 and 2
code:000004EA
code:000004EA ReadDigit02:                            ; CODE XREF: SetTimeByESCCode+3↑p
code:000004EA                                         ; ChangeSettings+3F↓p
code:000004EA                 mov     R6, #'3
code:000004EC                 ajmp    ReadDigitInRange ; R6 = upper bound (exclusive)
code:000004EC ; End of function ReadDigit02           ; ESC+anything aborts
code:000004EC
code:000004EE
code:000004EE ; =============== S U B R O U T I N E =======================================
code:000004EE
code:000004EE ; Read a digit between 0 and 3
code:000004EE
code:000004EE ReadDigit03:                            ; CODE XREF: SetTimeByESCCode+C↑p
code:000004EE                                         ; ChangeSettings+4C↓p
code:000004EE                 mov     R6, #'4
code:000004F0                 ajmp    ReadDigitInRange ; R6 = upper bound (exclusive)
code:000004F0 ; End of function ReadDigit03           ; ESC+anything aborts
code:000004F0
code:000004F2
code:000004F2 ; =============== S U B R O U T I N E =======================================
code:000004F2
code:000004F2 ; Read a digit between 0 and 5
code:000004F2
code:000004F2 ReadDigit05:                            ; CODE XREF: SetTimeByESCCode+16↑p
code:000004F2                                         ; SetTimeByESCCode+22↑p ...
code:000004F2                 mov     R6, #'6
code:000004F4                 ajmp    ReadDigitInRange ; R6 = upper bound (exclusive)
code:000004F4 ; End of function ReadDigit05           ; ESC+anything aborts
code:000004F4
code:000004F6
code:000004F6 ; =============== S U B R O U T I N E =======================================
code:000004F6
code:000004F6 ; Read a digit between 0 and 9
code:000004F6
code:000004F6 ReadDigit09:                            ; CODE XREF: SetTimeByESCCode:code_4BE↑p
code:000004F6                                         ; SetTimeByESCCode+1C↑p ...
code:000004F6                 mov     R6, #':
code:000004F8
code:000004F8 ReadDigitInRange:                       ; CODE XREF: ReadDigit02+2↑j
code:000004F8                                         ; ReadDigit03+2↑j ...
code:000004F8                 mov     R5, #'0         ; R6 = upper bound (exclusive)
code:000004F8                                         ; ESC+anything aborts
code:000004FA
code:000004FA ReadCharLoop:                           ; CODE XREF: ReadDigit09+6↓j
code:000004FA                                         ; ReadDigit09:TestLower↓j ...
code:000004FA                 acall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:000004FA                                         ; needed.
code:000004FA                                         ;
code:000004FA                                         ; At return:
code:000004FA                                         ;
code:000004FA                                         ; A = next character
code:000004FA                                         ; C = next character is valid
code:000004FC                 jnc     ReadCharLoop
code:000004FE
code:000004FE
code:000004FE                 cjne    A, #0x1B, GoodChar
code:00000501
code:00000501
code:00000501                 acall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:00000501                                         ; needed.
code:00000501                                         ;
code:00000501                                         ; At return:
code:00000501                                         ;
code:00000501                                         ; A = next character
code:00000501                                         ; C = next character is valid
code:00000503                 clr     A
code:00000504
code:00000504 ReturnGate_3:                           ; CODE XREF: SendCharUnderCursor+11↓j
code:00000504                 ret
code:00000505 ; ---------------------------------------------------------------------------
code:00000505
code:00000505 GoodChar:                               ; CODE XREF: ReadDigit09+8↑j
code:00000505                 cjne    A, B0R5_MappedCursorRow, TestLower
code:00000508
code:00000508 TestLower:                              ; CODE XREF: ReadDigit09:GoodChar↑j
code:00000508                 jc      ReadCharLoop
code:0000050A
code:0000050A
code:0000050A                 cjne    A, B0R6, TestUpper
code:0000050D
code:0000050D TestUpper:                              ; CODE XREF: ReadDigit09+14↑j
code:0000050D                 jnc     ReadCharLoop
code:0000050F
code:0000050F
code:0000050F                 ret
code:0000050F ; End of function ReadDigit09
code:0000050F
code:00000510
code:00000510 ; =============== S U B R O U T I N E =======================================
code:00000510
code:00000510
code:00000510 SendTimeString:                         ; DATA XREF: InterpretESC+1A↓o
code:00000510                 mov     R1, #6
code:00000512                 mov     R0, #(TimeDigitsINT+5)
code:00000514
code:00000514 code_514:                               ; CODE XREF: SendTimeString+8↓j
code:00000514                 mov     A, @R0
code:00000515                 dec     R0
code:00000516                 acall   DispatchTypedValue
code:00000518                 djnz    R1, code_514
code:0000051A
code:0000051A
code:0000051A                 mov     A, #0xD
code:0000051C                 ajmp    DispatchTypedValue
code:0000051C ; End of function SendTimeString
code:0000051C
code:0000051E
code:0000051E ; =============== S U B R O U T I N E =======================================
code:0000051E
code:0000051E
code:0000051E SendCursorPosAsESC:                     ; DATA XREF: InterpretESC+1A↓o
code:0000051E                 mov     A, #'Y
code:00000520                 lcall   SendSimpleESCCode
code:00000523
code:00000523
code:00000523                 mov     A, CursorRow
code:00000525                 jnz     code_529
code:00000527
code:00000527
code:00000527                 add     A, #0x19
code:00000529
code:00000529 code_529:                               ; CODE XREF: SendCursorPosAsESC+7↑j
code:00000529                 add     A, #0x1F
code:0000052B                 acall   DispatchTypedValue
code:0000052D
code:0000052D
code:0000052D                 mov     A, CursorColumn
code:0000052F                 add     A, #0x20
code:00000531                 ajmp    DispatchTypedValue
code:00000531 ; End of function SendCursorPosAsESC
code:00000531
code:00000533
code:00000533 ; =============== S U B R O U T I N E =======================================
code:00000533
code:00000533
code:00000533 SendCharUnderCursor:                    ; DATA XREF: InterpretESC+1A↓o
code:00000533                 acall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:00000533                                         ; column and the line table for calculation.
code:00000533                                         ;
code:00000533                                         ; Does not account for attributes in the row.  This is a
code:00000533                                         ; bug.
code:00000535
code:00000535 code_535:                               ; CODE XREF: SendCharUnderCursor+29↓j
code:00000535                 movx    A, @DPTR
code:00000536                 acall   ScreenToVT52Char ; If the input is a graphics character, get its VT52
code:00000536                                         ; equivalent.  Set CharEquivalent when <0x80.  Return an
code:00000536                                         ; interpretation of the result:
code:00000536                                         ;
code:00000536                                         ; Original if 0x80 or higher
code:00000536                                         ;
code:00000536                                         ; Value returned is 0 if same class of value, 'G' (leave
code:00000536                                         ; graphics mode) if transition from graphics to normal, 'F'
code:00000536                                         ; (enter graphics mode) if transition from normal to
code:00000536                                         ; graphics
code:00000538                 jb      ACC7, IsAttribute ; Accumulator
code:0000053B
code:0000053B
code:0000053B                 jz      SendTheChar
code:0000053D
code:0000053D
code:0000053D                 lcall   SendSimpleESCCode
code:00000540
code:00000540 SendTheChar:                            ; CODE XREF: SendCharUnderCursor+8↑j
code:00000540                 mov     A, CharEquivalent
code:00000542                 acall   DispatchTypedValue
code:00000544
code:00000544
code:00000544                 jnb     FormatStatus.2, ReturnGate_3 ; Bit 0 = Ctrl-F1 pressed
code:00000544                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000544                                         ; Bit 2 = In graphics mode
code:00000547
code:00000547
code:00000547                 clr     FormatStatus.2  ; Bit 0 = Ctrl-F1 pressed
code:00000547                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000547                                         ; Bit 2 = In graphics mode
code:00000549                 mov     A, #'G
code:0000054B                 ljmp    SendSimpleESCCode
code:0000054E ; ---------------------------------------------------------------------------
code:0000054E
code:0000054E IsAttribute:                            ; CODE XREF: SendCharUnderCursor+5↑j
code:0000054E                 mov     R5, A
code:0000054F                 mov     A, #'s
code:00000551                 lcall   SendSimpleESCCode
code:00000554
code:00000554
code:00000554                 lcall   GetESCSAttributeCode ; Returns a digit between '0' and '7' for interpreting the
code:00000554                                         ; screen attribute into an ESC s <#> sequence
code:00000554                                         ;
code:00000554                                         ; Attribute character is R5 in bank 0
code:00000557                 acall   DispatchTypedValue
code:00000559                 acall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:00000559                                         ; column and the line table for calculation.
code:00000559                                         ;
code:00000559                                         ; Does not account for attributes in the row.  This is a
code:00000559                                         ; bug.
code:0000055B                 inc     DPTR
code:0000055C                 ajmp    code_535
code:0000055C ; End of function SendCharUnderCursor
code:0000055C
code:0000055E
code:0000055E ; =============== S U B R O U T I N E =======================================
code:0000055E
code:0000055E
code:0000055E EnableKeyboard:                         ; DATA XREF: InterpretESC+1A↓o
code:0000055E                 clr     VideoSettings.6 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000055E                                         ; Bit 1 = Receive buffer is full
code:0000055E                                         ; Bit 3 = Serial send register busy
code:0000055E                                         ; Bit 4 = Busy drawing to screen
code:0000055E                                         ; Bit 5 = Steady/Blink
code:0000055E                                         ; Bit 6 = Disable keyboard
code:0000055E                                         ; Bit 7 = Standard/Graphics
code:00000560                 ret
code:00000560 ; End of function EnableKeyboard
code:00000560
code:00000561
code:00000561 ; =============== S U B R O U T I N E =======================================
code:00000561
code:00000561
code:00000561 DisableKeyboard:                        ; DATA XREF: InterpretESC+1A↓o
code:00000561                 setb    VideoSettings.6 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000561                                         ; Bit 1 = Receive buffer is full
code:00000561                                         ; Bit 3 = Serial send register busy
code:00000561                                         ; Bit 4 = Busy drawing to screen
code:00000561                                         ; Bit 5 = Steady/Blink
code:00000561                                         ; Bit 6 = Disable keyboard
code:00000561                                         ; Bit 7 = Standard/Graphics
code:00000563                 ret
code:00000563 ; End of function DisableKeyboard
code:00000563
code:00000564
code:00000564 ; =============== S U B R O U T I N E =======================================
code:00000564
code:00000564
code:00000564 SendESCSlashK:                          ; DATA XREF: InterpretESC+1A↓o
code:00000564                 mov     A, #'/
code:00000566                 lcall   SendSimpleESCCode
code:00000569
code:00000569
code:00000569                 mov     A, #'K
code:0000056B                 ajmp    DispatchTypedValue
code:0000056B ; End of function SendESCSlashK
code:0000056B
code:0000056D
code:0000056D ; =============== S U B R O U T I N E =======================================
code:0000056D
code:0000056D
code:0000056D DontShowClock:                          ; DATA XREF: InterpretESC+1A↓o
code:0000056D                 setb    SerialSettings.0 ; Bit 0 = Clock display off
code:0000056D                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:0000056D                                         ; Bit 2 = Half/Full duplex
code:0000056D                                         ; Bit 3 = Auto Repeat disable
code:0000056D                                         ; Bit 4 = Key click disable
code:0000056D                                         ; Bit 5 = LF->CRLF
code:0000056D                                         ; Bit 6 = CR->CRLF
code:0000056D                                         ; Bit 7 = Wrap at EOL off
code:0000056F                 ajmp    ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:0000056F ; End of function DontShowClock         ; terminal software knows to react to it.  This is called to signal
code:0000056F                                         ; a change, such as when the clock updates.
code:00000571
code:00000571 ; =============== S U B R O U T I N E =======================================
code:00000571
code:00000571
code:00000571 SaveCursorPosition:                     ; DATA XREF: InterpretESC+1A↓o
code:00000571                 mov     SavedCursorColumn, CursorColumn
code:00000574                 mov     SavedCursorRow, CursorRow
code:00000577                 ret
code:00000577 ; End of function SaveCursorPosition
code:00000577
code:00000578
code:00000578 ; =============== S U B R O U T I N E =======================================
code:00000578
code:00000578
code:00000578 LoadCursorPosition:                     ; DATA XREF: InterpretESC+1A↓o
code:00000578                 mov     CursorColumn, SavedCursorColumn
code:0000057B                 mov     CursorRow, SavedCursorRow
code:0000057E                 ajmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:0000057E ; End of function LoadCursorPosition    ; attributes
code:0000057E
code:00000580
code:00000580 ; =============== S U B R O U T I N E =======================================
code:00000580
code:00000580
code:00000580 TestPrinterPresence:                    ; CODE XREF: ModifySetting:EnablePrinter↓p
code:00000580                                         ; PrintScreen+4↓p
code:00000580                 setb    PrinterStatus.0 ; Bit 0 = Printer
code:00000580                                         ; Bit 1 = Need to send XOFF
code:00000580                                         ; Bit 2 = Toggle printer state
code:00000580                                         ; Bit 3 = No writes to status line
code:00000580                                         ;         No update of time or print status.  Set cursor position ESC
code:00000580                                         ;         code cannot set cursor to row 1
code:00000580                                         ; Bit 4 = No writes to status line
code:00000580                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000580                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000580                                         ;         position to row 1
code:00000580                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000580                                         ; Bit 6 = Key pressed
code:00000580                                         ; Bit 7 = Repeat eligible
code:00000582
code:00000582
code:00000582                 clr     A
code:00000583                 mov     DPTR, #PrinterOutPort
code:00000586                 movx    @DPTR, A
code:00000587
code:00000587
code:00000587                 setb    P16             ; Port 1
code:00000589                 clr     P16             ; Port 1
code:0000058B
code:0000058B
code:0000058B                 mov     R0, #14
code:0000058D
code:0000058D TightDelayOuter:                        ; CODE XREF: TestPrinterPresence+14↓j
code:0000058D                 mov     R1, #0
code:0000058F
code:0000058F TightDelayInner:                        ; CODE XREF: TestPrinterPresence+12↓j
code:0000058F                 jnb     P17, Done       ; Port 1
code:00000592
code:00000592
code:00000592                 djnz    R1, TightDelayInner
code:00000594                 djnz    R0, TightDelayOuter
code:00000596
code:00000596 ;
code:00000596 ; If we haven't seen the printer acknowledge in 0x1400
code:00000596 ; cycles, give up
code:00000596 ;
code:00000596                 clr     PrinterStatus.0 ; Bit 0 = Printer
code:00000596                                         ; Bit 1 = Need to send XOFF
code:00000596                                         ; Bit 2 = Toggle printer state
code:00000596                                         ; Bit 3 = No writes to status line
code:00000596                                         ;         No update of time or print status.  Set cursor position ESC
code:00000596                                         ;         code cannot set cursor to row 1
code:00000596                                         ; Bit 4 = No writes to status line
code:00000596                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000596                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000596                                         ;         position to row 1
code:00000596                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000596                                         ; Bit 6 = Key pressed
code:00000596                                         ; Bit 7 = Repeat eligible
code:00000598
code:00000598 Done:                                   ; CODE XREF: TestPrinterPresence:TightDelayInner↑j
code:00000598                 ret
code:00000598 ; End of function TestPrinterPresence
code:00000598
code:00000599
code:00000599 ; =============== S U B R O U T I N E =======================================
code:00000599
code:00000599
code:00000599 PrintStringToVRAM:                      ; CODE XREF: PrintStringToVRAM+5↓j
code:00000599                 acall   PrintCharToVRAM ; R1:R0 = destination
code:00000599                                         ; A = character
code:00000599                                         ;
code:00000599                                         ; Auto-increments R1:R0
code:0000059B
code:0000059B PrintCStringToVRAMEntry:                ; CODE XREF: ModifySetting+5A↓j
code:0000059B                                         ; UpdateStatusLine+27↓p ...
code:0000059B                 clr     A               ; R1:R0 = destination
code:0000059B                                         ; DPTR = source
code:0000059B                                         ;
code:0000059B                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:0000059C                 movc    A, @A+DPTR
code:0000059D                 inc     DPTR
code:0000059E                 jnz     PrintStringToVRAM
code:000005A0                 ret
code:000005A0 ; End of function PrintStringToVRAM
code:000005A0
code:000005A1
code:000005A1 ; =============== S U B R O U T I N E =======================================
code:000005A1
code:000005A1 ; Increments R2 and writes a character to the screen.
code:000005A1 ;
code:000005A1 ; R1:R0 = screen location
code:000005A1 ; R2 = count
code:000005A1
code:000005A1 PrintCharToVRAMIncR2:                   ; CODE XREF: EraseAllEntries+150↓p
code:000005A1                                         ; EraseAllEntries+16B↓p ...
code:000005A1                 inc     R2
code:000005A1 ; End of function PrintCharToVRAMIncR2
code:000005A1
code:000005A2
code:000005A2 ; =============== S U B R O U T I N E =======================================
code:000005A2
code:000005A2 ; R1:R0 = destination
code:000005A2 ; A = character
code:000005A2 ;
code:000005A2 ; Auto-increments R1:R0
code:000005A2
code:000005A2 PrintCharToVRAM:                        ; CODE XREF: PrintStringToVRAM↑p
code:000005A2                                         ; DeleteCharOnLine+10↓p ...
code:000005A2                 push    IE              ; Interrupt Enable Register
code:000005A4                 clr     EA              ; Interrupt Enable Register
code:000005A6
code:000005A6
code:000005A6                 mov     P2, R1          ; Emulate 16-bit address lookup using R1:R0 as the 16 bits
code:000005A8                 movx    @R0, A
code:000005A9
code:000005A9
code:000005A9                 pop     IE              ; Interrupt Enable Register
code:000005AB                 inc     R0
code:000005AC                 cjne    R0, #0, code_5B0
code:000005AF
code:000005AF
code:000005AF                 inc     R1
code:000005B0
code:000005B0 code_5B0:                               ; CODE XREF: PrintCharToVRAM+A↑j
code:000005B0                 ret
code:000005B0 ; End of function PrintCharToVRAM
code:000005B0
code:000005B1
code:000005B1 ; =============== S U B R O U T I N E =======================================
code:000005B1
code:000005B1
code:000005B1 EnterSettingEnable:                     ; DATA XREF: InterpretESC+1A↓o
code:000005B1                 setb    TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:000005B1                                         ; Bit 1 = BREAK is tracked as pressed
code:000005B1                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000005B1                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000005B1                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000005B1                                         ;         handler uses this to look for timeouts in each state.
code:000005B1                                         ; Bit 4 = Use immediate dial buffer
code:000005B1                                         ; Bit 5 = Dial voice
code:000005B1                                         ; Bit 6 = Disabling/Enabling a setting
code:000005B1                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000005B3                 ajmp    code_5B7
code:000005B5 ; ---------------------------------------------------------------------------
code:000005B5
code:000005B5 EnterSettingDisable:                    ; DATA XREF: InterpretESC+1A↓o
code:000005B5                 clr     TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:000005B5                                         ; Bit 1 = BREAK is tracked as pressed
code:000005B5                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000005B5                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000005B5                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000005B5                                         ;         handler uses this to look for timeouts in each state.
code:000005B5                                         ; Bit 4 = Use immediate dial buffer
code:000005B5                                         ; Bit 5 = Dial voice
code:000005B5                                         ; Bit 6 = Disabling/Enabling a setting
code:000005B5                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000005B7
code:000005B7 code_5B7:                               ; CODE XREF: EnterSettingEnable+2↑j
code:000005B7                 mov     ContextFunctionPtr+1, #(ModifySetting & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000005BA                 mov     ContextFunctionPtr, #(ModifySetting >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000005BD
code:000005BD ReturnGate_7:                           ; CODE XREF: ModifySetting:code_5C6↓j
code:000005BD                 ret
code:000005BD ; End of function EnterSettingEnable
code:000005BD
code:000005BE
code:000005BE ; =============== S U B R O U T I N E =======================================
code:000005BE
code:000005BE
code:000005BE ModifySetting:                          ; DATA XREF: EnterSettingEnable:code_5B7↑o
code:000005BE                                         ; EnterSettingEnable+9↑o
code:000005BE                 acall   SetNormalInputMode
code:000005C0
code:000005C0
code:000005C0                 clr     C
code:000005C1                 subb    A, #'1
code:000005C3                 cjne    A, #16, code_5C6
code:000005C6
code:000005C6 code_5C6:                               ; CODE XREF: ModifySetting+5↑j
code:000005C6                 jnc     ReturnGate_7
code:000005C8
code:000005C8
code:000005C8                 mov     DPTR, #jpt_5D2
code:000005CB                 jnb     TimerStatus.6, code_5D1 ; Bit 0 = ESC is tracked as pressed
code:000005CB                                         ; Bit 1 = BREAK is tracked as pressed
code:000005CB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000005CB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000005CB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000005CB                                         ;         handler uses this to look for timeouts in each state.
code:000005CB                                         ; Bit 4 = Use immediate dial buffer
code:000005CB                                         ; Bit 5 = Dial voice
code:000005CB                                         ; Bit 6 = Disabling/Enabling a setting
code:000005CB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000005CE
code:000005CE
code:000005CE                 mov     DPTR, #EnableJumptTable
code:000005D1
code:000005D1 code_5D1:                               ; CODE XREF: ModifySetting+D↑j
code:000005D1                 movc    A, @A+DPTR      ; switch 14 cases
code:000005D2                 jmp     @A+DPTR         ; switch jump
code:000005D2 ; ---------------------------------------------------------------------------
code:000005D3 jpt_5D2:        .byte DisableStatusLineByESC - 0x5D3
code:000005D3                                         ; DATA XREF: ModifySetting+A↑o
code:000005D3                 .byte DisableKeyclick - 0x5D3 ; jump table for switch statement
code:000005D3                 .byte ReturnGate_9 - 0x5D3
code:000005D3                 .byte ReturnGate_9 - 0x5D3
code:000005D3                 .byte DisableScreenUpdate - 0x5D3
code:000005D3                 .byte ReturnGate_9 - 0x5D3
code:000005D3                 .byte ReturnGate_9 - 0x5D3
code:000005D3                 .byte EnableCRtoCRLF - 0x5D3
code:000005D3                 .byte EnableLFtoCRLF - 0x5D3
code:000005D3                 .byte EnablePrinter - 0x5D3
code:000005D3                 .byte CursorRevVideo - 0x5D3
code:000005D3                 .byte DisableRepeat - 0x5D3
code:000005D3                 .byte DisableTopLine - 0x5D3
code:000005D3                 .byte SetFullDuplex - 0x5D3
code:000005E1 ; ---------------------------------------------------------------------------
code:000005E1
code:000005E1 DisableStatusLineByESC:                 ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005E1                 jb      PrinterStatus.4, ReturnGate_9 ; jumptable 000005D2 case 0
code:000005E4
code:000005E4
code:000005E4                 mov     C, PrinterStatus.3 ; Bit 0 = Printer
code:000005E4                                         ; Bit 1 = Need to send XOFF
code:000005E4                                         ; Bit 2 = Toggle printer state
code:000005E4                                         ; Bit 3 = No writes to status line
code:000005E4                                         ;         No update of time or print status.  Set cursor position ESC
code:000005E4                                         ;         code cannot set cursor to row 1
code:000005E4                                         ; Bit 4 = No writes to status line
code:000005E4                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000005E4                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000005E4                                         ;         position to row 1
code:000005E4                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000005E4                                         ; Bit 6 = Key pressed
code:000005E4                                         ; Bit 7 = Repeat eligible
code:000005E6                 mov     FormatStatus.1, C ; Bit 0 = Ctrl-F1 pressed
code:000005E6                                         ; Bit 1 = Save of Disable Status Bar flag
code:000005E6                                         ; Bit 2 = In graphics mode
code:000005E8                 setb    PrinterStatus.4 ; Bit 0 = Printer
code:000005E8                                         ; Bit 1 = Need to send XOFF
code:000005E8                                         ; Bit 2 = Toggle printer state
code:000005E8                                         ; Bit 3 = No writes to status line
code:000005E8                                         ;         No update of time or print status.  Set cursor position ESC
code:000005E8                                         ;         code cannot set cursor to row 1
code:000005E8                                         ; Bit 4 = No writes to status line
code:000005E8                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000005E8                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000005E8                                         ;         position to row 1
code:000005E8                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000005E8                                         ; Bit 6 = Key pressed
code:000005E8                                         ; Bit 7 = Repeat eligible
code:000005EA                 clr     PrinterStatus.3 ; Bit 0 = Printer
code:000005EA                                         ; Bit 1 = Need to send XOFF
code:000005EA                                         ; Bit 2 = Toggle printer state
code:000005EA                                         ; Bit 3 = No writes to status line
code:000005EA                                         ;         No update of time or print status.  Set cursor position ESC
code:000005EA                                         ;         code cannot set cursor to row 1
code:000005EA                                         ; Bit 4 = No writes to status line
code:000005EA                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000005EA                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000005EA                                         ;         position to row 1
code:000005EA                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000005EA                                         ; Bit 6 = Key pressed
code:000005EA                                         ; Bit 7 = Repeat eligible
code:000005EC                 ajmp    ClearTopLine
code:000005EE ; ---------------------------------------------------------------------------
code:000005EE
code:000005EE DisableKeyclick:                        ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005EE                 setb    SerialSettings.4 ; jumptable 000005D2 case 1
code:000005F0
code:000005F0 ReturnGate_9:                           ; CODE XREF: ModifySetting:DisableStatusLineByESC↑j
code:000005F0                                         ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005F0                 ret                     ; jumptable 000005D2 cases 2,3,5,6
code:000005F1 ; ---------------------------------------------------------------------------
code:000005F1
code:000005F1 DisableScreenUpdate:                    ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005F1                 setb    VideoSettings.4 ; jumptable 000005D2 case 4
code:000005F3                 ret
code:000005F4 ; ---------------------------------------------------------------------------
code:000005F4
code:000005F4 EnableCRtoCRLF:                         ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005F4                 setb    SerialSettings.6 ; jumptable 000005D2 case 7
code:000005F6                 ret
code:000005F7 ; ---------------------------------------------------------------------------
code:000005F7
code:000005F7 EnableLFtoCRLF:                         ; DATA XREF: ModifySetting:jpt_5D2↑o
code:000005F7                 setb    SerialSettings.5 ; jumptable 000005D2 case 8
code:000005F9                 ret
code:000005FA ; ---------------------------------------------------------------------------
code:000005FA
code:000005FA TurnPrinterOff:                         ; CODE XREF: ModifySetting+42↓j
code:000005FA                 clr     PrinterStatus.0 ; Bit 0 = Printer
code:000005FA                                         ; Bit 1 = Need to send XOFF
code:000005FA                                         ; Bit 2 = Toggle printer state
code:000005FA                                         ; Bit 3 = No writes to status line
code:000005FA                                         ;         No update of time or print status.  Set cursor position ESC
code:000005FA                                         ;         code cannot set cursor to row 1
code:000005FA                                         ; Bit 4 = No writes to status line
code:000005FA                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000005FA                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000005FA                                         ;         position to row 1
code:000005FA                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000005FA                                         ; Bit 6 = Key pressed
code:000005FA                                         ; Bit 7 = Repeat eligible
code:000005FC                 ajmp    ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:000005FC                                         ; terminal software knows to react to it.  This is called to signal
code:000005FC                                         ; a change, such as when the clock updates.
code:000005FE ; ---------------------------------------------------------------------------
code:000005FE
code:000005FE TogglePrinterStatus:                    ; CODE XREF: TerminalLoop+3D↓p
code:000005FE                 clr     PrinterStatus.2 ; Bit 0 = Printer
code:000005FE                                         ; Bit 1 = Need to send XOFF
code:000005FE                                         ; Bit 2 = Toggle printer state
code:000005FE                                         ; Bit 3 = No writes to status line
code:000005FE                                         ;         No update of time or print status.  Set cursor position ESC
code:000005FE                                         ;         code cannot set cursor to row 1
code:000005FE                                         ; Bit 4 = No writes to status line
code:000005FE                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000005FE                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000005FE                                         ;         position to row 1
code:000005FE                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000005FE                                         ; Bit 6 = Key pressed
code:000005FE                                         ; Bit 7 = Repeat eligible
code:00000600                 jb      PrinterStatus.0, TurnPrinterOff ; Bit 0 = Printer
code:00000600                                         ; Bit 1 = Need to send XOFF
code:00000600                                         ; Bit 2 = Toggle printer state
code:00000600                                         ; Bit 3 = No writes to status line
code:00000600                                         ;         No update of time or print status.  Set cursor position ESC
code:00000600                                         ;         code cannot set cursor to row 1
code:00000600                                         ; Bit 4 = No writes to status line
code:00000600                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000600                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000600                                         ;         position to row 1
code:00000600                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000600                                         ; Bit 6 = Key pressed
code:00000600                                         ; Bit 7 = Repeat eligible
code:00000603
code:00000603 EnablePrinter:                          ; DATA XREF: ModifySetting:jpt_5D2↑o
code:00000603                 acall   TestPrinterPresence ; jumptable 000005D2 case 9
code:00000605
code:00000605 WritePrinterStatusToScreen:             ; CODE XREF: ModifySetting+98↓j
code:00000605                 jb      PrinterStatus.4, ReturnGate ; Bit 0 = Printer
code:00000605                                         ; Bit 1 = Need to send XOFF
code:00000605                                         ; Bit 2 = Toggle printer state
code:00000605                                         ; Bit 3 = No writes to status line
code:00000605                                         ;         No update of time or print status.  Set cursor position ESC
code:00000605                                         ;         code cannot set cursor to row 1
code:00000605                                         ; Bit 4 = No writes to status line
code:00000605                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000605                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000605                                         ;         position to row 1
code:00000605                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000605                                         ; Bit 6 = Key pressed
code:00000605                                         ; Bit 7 = Repeat eligible
code:00000608                 jb      PrinterStatus.3, ReturnGate ; Bit 0 = Printer
code:00000608                                         ; Bit 1 = Need to send XOFF
code:00000608                                         ; Bit 2 = Toggle printer state
code:00000608                                         ; Bit 3 = No writes to status line
code:00000608                                         ;         No update of time or print status.  Set cursor position ESC
code:00000608                                         ;         code cannot set cursor to row 1
code:00000608                                         ; Bit 4 = No writes to status line
code:00000608                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000608                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000608                                         ;         position to row 1
code:00000608                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000608                                         ; Bit 6 = Key pressed
code:00000608                                         ; Bit 7 = Repeat eligible
code:0000060B
code:0000060B ForceWritePrintStatus:                  ; CODE XREF: UpdateStatusLine+3E↓p
code:0000060B                 mov     DPTR, #aSpaces  ; Does not check for presence of the status line
code:0000060E                 jnb     PrinterStatus.0, code_614 ; Bit 0 = Printer
code:0000060E                                         ; Bit 1 = Need to send XOFF
code:0000060E                                         ; Bit 2 = Toggle printer state
code:0000060E                                         ; Bit 3 = No writes to status line
code:0000060E                                         ;         No update of time or print status.  Set cursor position ESC
code:0000060E                                         ;         code cannot set cursor to row 1
code:0000060E                                         ; Bit 4 = No writes to status line
code:0000060E                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:0000060E                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:0000060E                                         ;         position to row 1
code:0000060E                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:0000060E                                         ; Bit 6 = Key pressed
code:0000060E                                         ; Bit 7 = Repeat eligible
code:00000611
code:00000611
code:00000611                 mov     DPTR, #aPrinter
code:00000614
code:00000614 code_614:                               ; CODE XREF: ModifySetting+50↑j
code:00000614                 mov     R0, #(PrintStatus & 0xFF)
code:00000616                 mov     R1, #(PrintStatus >> 8)
code:00000618                 ajmp    PrintCStringToVRAMEntry ; R1:R0 = destination
code:00000618                                         ; DPTR = source
code:00000618                                         ;
code:00000618                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:0000061A ; ---------------------------------------------------------------------------
code:0000061A
code:0000061A CursorRevVideo:                         ; CODE XREF: ChangeSettings+F9↓j
code:0000061A                                         ; DATA XREF: ModifySetting:jpt_5D2↑o
code:0000061A                 mov     B, #0x29        ; Set 20 counts per horizontal retrace; Cursor is reverse
code:0000061A                                         ; video; Transparent field attributes
code:0000061D                 setb    VideoSettings.5 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000061D                                         ; Bit 1 = Receive buffer is full
code:0000061D                                         ; Bit 3 = Serial send register busy
code:0000061D                                         ; Bit 4 = Busy drawing to screen
code:0000061D                                         ; Bit 5 = Steady/Blink
code:0000061D                                         ; Bit 6 = Disable keyboard
code:0000061D                                         ; Bit 7 = Standard/Graphics
code:0000061F                 ajmp    ChangeVideoMode
code:00000621 ; ---------------------------------------------------------------------------
code:00000621
code:00000621 DisableRepeat:                          ; DATA XREF: ModifySetting:jpt_5D2↑o
code:00000621                 setb    SerialSettings.3 ; jumptable 000005D2 case 11
code:00000623
code:00000623 ReturnGate:                             ; CODE XREF: ModifySetting:WritePrinterStatusToScreen↑j
code:00000623                                         ; ModifySetting+4A↑j ...
code:00000623                 ret
code:00000624 ; ---------------------------------------------------------------------------
code:00000624
code:00000624 DisableTopLine:                         ; DATA XREF: ModifySetting:jpt_5D2↑o
code:00000624                 jb      PrinterStatus.4, ReturnGate ; jumptable 000005D2 case 12
code:00000627
code:00000627
code:00000627                 setb    PrinterStatus.3 ; Bit 0 = Printer
code:00000627                                         ; Bit 1 = Need to send XOFF
code:00000627                                         ; Bit 2 = Toggle printer state
code:00000627                                         ; Bit 3 = No writes to status line
code:00000627                                         ;         No update of time or print status.  Set cursor position ESC
code:00000627                                         ;         code cannot set cursor to row 1
code:00000627                                         ; Bit 4 = No writes to status line
code:00000627                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000627                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000627                                         ;         position to row 1
code:00000627                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000627                                         ; Bit 6 = Key pressed
code:00000627                                         ; Bit 7 = Repeat eligible
code:00000629                 ajmp    ClearTopLine
code:0000062B ; ---------------------------------------------------------------------------
code:0000062B
code:0000062B SetFullDuplex:                          ; DATA XREF: ModifySetting:jpt_5D2↑o
code:0000062B                 setb    SerialSettings.2 ; jumptable 000005D2 case 13
code:0000062D                 ret
code:0000062D ; ---------------------------------------------------------------------------
code:0000062E EnableJumptTable:                       ; DATA XREF: ModifySetting+10↑o
code:0000062E                 .byte EnableStatusLineByESC - 0x62E ; jump table for switch statement
code:0000062E                 .byte EnableKeyclick - 0x62E
code:0000062E                 .byte ReturnGate_10 - 0x62E
code:0000062E                 .byte ReturnGate_10 - 0x62E
code:0000062E                 .byte EnableScreenUpdates - 0x62E
code:0000062E                 .byte ReturnGate_10 - 0x62E
code:0000062E                 .byte ReturnGate_10 - 0x62E
code:0000062E                 .byte DisableCRtoCRLF - 0x62E
code:0000062E                 .byte DisableLFtoCRLF - 0x62E
code:0000062E                 .byte DisablePrinting - 0x62E
code:0000062E                 .byte CursorBlink - 0x62E
code:0000062E                 .byte EnableRepeat - 0x62E
code:0000062E                 .byte EnableStatusLine - 0x62E
code:0000062E                 .byte SetHalfDuplex - 0x62E
code:0000063C ; ---------------------------------------------------------------------------
code:0000063C
code:0000063C EnableStatusLineByESC:                  ; CODE XREF: ModifySetting+14↑j
code:0000063C                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:0000063C                 jb      PrinterStatus.3, ReturnGate_10 ; jumptable 000005D2 case 0
code:0000063F
code:0000063F
code:0000063F                 jnb     PrinterStatus.4, ReturnGate_10 ; jumptable 000005D2 cases 2,3,5,6
code:00000642
code:00000642
code:00000642                 mov     C, FormatStatus.1 ; Bit 0 = Ctrl-F1 pressed
code:00000642                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000642                                         ; Bit 2 = In graphics mode
code:00000644                 mov     PrinterStatus.3, C ; Bit 0 = Printer
code:00000644                                         ; Bit 1 = Need to send XOFF
code:00000644                                         ; Bit 2 = Toggle printer state
code:00000644                                         ; Bit 3 = No writes to status line
code:00000644                                         ;         No update of time or print status.  Set cursor position ESC
code:00000644                                         ;         code cannot set cursor to row 1
code:00000644                                         ; Bit 4 = No writes to status line
code:00000644                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000644                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000644                                         ;         position to row 1
code:00000644                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000644                                         ; Bit 6 = Key pressed
code:00000644                                         ; Bit 7 = Repeat eligible
code:00000646                 ajmp    CleanUpStatusLine
code:00000648 ; ---------------------------------------------------------------------------
code:00000648
code:00000648 EnableKeyclick:                         ; CODE XREF: ModifySetting+14↑j
code:00000648                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:00000648                 clr     SerialSettings.4 ; jumptable 000005D2 case 1
code:0000064A
code:0000064A ReturnGate_10:                          ; CODE XREF: ModifySetting+14↑j
code:0000064A                                         ; ModifySetting:EnableStatusLineByESC↑j ...
code:0000064A                 ret                     ; jumptable 000005D2 cases 2,3,5,6
code:0000064B ; ---------------------------------------------------------------------------
code:0000064B
code:0000064B EnableScreenUpdates:                    ; CODE XREF: ModifySetting+14↑j
code:0000064B                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:0000064B                 clr     VideoSettings.4 ; jumptable 000005D2 case 4
code:0000064D                 ret
code:0000064E ; ---------------------------------------------------------------------------
code:0000064E
code:0000064E DisableCRtoCRLF:                        ; CODE XREF: ModifySetting+14↑j
code:0000064E                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:0000064E                 clr     SerialSettings.6 ; jumptable 000005D2 case 7
code:00000650                 ret
code:00000651 ; ---------------------------------------------------------------------------
code:00000651
code:00000651 DisableLFtoCRLF:                        ; CODE XREF: ModifySetting+14↑j
code:00000651                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:00000651                 clr     SerialSettings.5 ; jumptable 000005D2 case 8
code:00000653                 ret
code:00000654 ; ---------------------------------------------------------------------------
code:00000654
code:00000654 DisablePrinting:                        ; CODE XREF: ModifySetting+14↑j
code:00000654                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:00000654                 clr     PrinterStatus.0 ; jumptable 000005D2 case 9
code:00000656                 sjmp    WritePrinterStatusToScreen
code:00000658 ; ---------------------------------------------------------------------------
code:00000658
code:00000658 CursorBlink:                            ; CODE XREF: ModifySetting+14↑j
code:00000658                                         ; ChangeSettings:code_136C↓j
code:00000658                                         ; DATA XREF: ...
code:00000658                 mov     B, #9           ; Set 20 counts per horizontal retrace; Cursor blinks;
code:00000658                                         ; Transparent field attributes
code:0000065B                 clr     VideoSettings.5 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000065B                                         ; Bit 1 = Receive buffer is full
code:0000065B                                         ; Bit 3 = Serial send register busy
code:0000065B                                         ; Bit 4 = Busy drawing to screen
code:0000065B                                         ; Bit 5 = Steady/Blink
code:0000065B                                         ; Bit 6 = Disable keyboard
code:0000065B                                         ; Bit 7 = Standard/Graphics
code:0000065D
code:0000065D ChangeVideoMode:                        ; CODE XREF: ModifySetting+61↑j
code:0000065D                 push    IE              ; Interrupt Enable Register
code:0000065F                 clr     EA              ; Interrupt Enable Register
code:00000661                 acall   SetVidMode
code:00000663                 mov     DPTR, #CRTC_CREG
code:00000666                 ajmp    code_395
code:00000668 ; ---------------------------------------------------------------------------
code:00000668
code:00000668 EnableRepeat:                           ; CODE XREF: ModifySetting+14↑j
code:00000668                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:00000668                 clr     SerialSettings.3 ; jumptable 000005D2 case 11
code:0000066A                 ret
code:0000066B ; ---------------------------------------------------------------------------
code:0000066B
code:0000066B SetHalfDuplex:                          ; CODE XREF: ModifySetting+14↑j
code:0000066B                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:0000066B                 clr     SerialSettings.2 ; jumptable 000005D2 case 13
code:0000066D                 ret
code:0000066E ; ---------------------------------------------------------------------------
code:0000066E
code:0000066E EnableStatusLine:                       ; CODE XREF: ModifySetting+14↑j
code:0000066E                                         ; DATA XREF: ModifySetting:EnableJumptTable↑o
code:0000066E                 clr     PrinterStatus.3 ; jumptable 000005D2 case 12
code:00000670
code:00000670 CleanUpStatusLine:                      ; CODE XREF: ModifySetting+88↑j
code:00000670                 mov     A, CursorRow
code:00000672                 jnz     code_677
code:00000674
code:00000674
code:00000674                 lcall   HomeTTY
code:00000677
code:00000677 code_677:                               ; CODE XREF: ModifySetting+B4↑j
code:00000677                 clr     PrinterStatus.4 ; Bit 0 = Printer
code:00000677                                         ; Bit 1 = Need to send XOFF
code:00000677                                         ; Bit 2 = Toggle printer state
code:00000677                                         ; Bit 3 = No writes to status line
code:00000677                                         ;         No update of time or print status.  Set cursor position ESC
code:00000677                                         ;         code cannot set cursor to row 1
code:00000677                                         ; Bit 4 = No writes to status line
code:00000677                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000677                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000677                                         ;         position to row 1
code:00000677                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000677                                         ; Bit 6 = Key pressed
code:00000677                                         ; Bit 7 = Repeat eligible
code:00000679                 acall   ClearTopLine
code:0000067B                 ajmp    ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:0000067B ; End of function ModifySetting         ; terminal software knows to react to it.  This is called to signal
code:0000067B                                         ; a change, such as when the clock updates.
code:0000067D
code:0000067D ; =============== S U B R O U T I N E =======================================
code:0000067D
code:0000067D
code:0000067D EnterAttributeEdit:                     ; DATA XREF: InterpretESC+1A↓o
code:0000067D                 mov     ContextFunctionPtr+1, #(AttributeEdit & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00000680                 mov     ContextFunctionPtr, #(AttributeEdit >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00000683                 ret
code:00000683 ; End of function EnterAttributeEdit
code:00000683
code:00000684
code:00000684 ; =============== S U B R O U T I N E =======================================
code:00000684
code:00000684
code:00000684 GetAttributeByIndex:                    ; CODE XREF: GetESCSAttributeCode+4↓p
code:00000684                 movc    A, @A+PC
code:00000685                 ret
code:00000685 ; End of function GetAttributeByIndex
code:00000685
code:00000685 ; ---------------------------------------------------------------------------
code:00000686 AttributeTable: .byte 0x80              ; DATA XREF: AttributeEdit+C↓o
code:00000686                 .byte 0x90
code:00000686                 .byte 0x82
code:00000686                 .byte 0x92
code:00000686                 .byte 0x81
code:00000686                 .byte 0x91
code:00000686                 .byte 0x83
code:00000686                 .byte 0x93
code:0000068E
code:0000068E ; =============== S U B R O U T I N E =======================================
code:0000068E
code:0000068E
code:0000068E AttributeEdit:                          ; DATA XREF: EnterAttributeEdit↑o
code:0000068E                                         ; EnterAttributeEdit+3↑o
code:0000068E                 acall   SetNormalInputMode
code:00000690
code:00000690
code:00000690                 cjne    A, #'0, code_693
code:00000693
code:00000693 code_693:                               ; CODE XREF: AttributeEdit+2↑j
code:00000693                 jc      ReturnGate_6
code:00000695
code:00000695
code:00000695                 cjne    A, #'8, code_698
code:00000698
code:00000698 code_698:                               ; CODE XREF: AttributeEdit+7↑j
code:00000698                 jnc     ReturnGate_6
code:0000069A
code:0000069A
code:0000069A                 mov     DPTR, #(AttributeTable-0x30)
code:0000069D                 movc    A, @A+DPTR
code:0000069E                 mov     R5, A
code:0000069E ; End of function AttributeEdit
code:0000069E
code:0000069F
code:0000069F ; =============== S U B R O U T I N E =======================================
code:0000069F
code:0000069F ; A = attribute to insert
code:0000069F
code:0000069F InsertAttribute:                        ; CODE XREF: InsertReverseVideoAttr+2↓j
code:0000069F                                         ; InsertNormalVideoAttr+2↓j
code:0000069F                 lcall   SetDPTRToCursorAddr
code:000006A2                 movx    A, @DPTR
code:000006A3                 jb      ACC7, SetAttrib ; Accumulator
code:000006A6
code:000006A6
code:000006A6                 lcall   DecrementDPTR
code:000006A9                 movx    A, @DPTR
code:000006AA                 jb      ACC7, SetAttrib ; Accumulator
code:000006AD
code:000006AD
code:000006AD                 acall   CalcCursorEndOfLine ; Expects to be in register bank 0
code:000006AD                                         ;
code:000006AD                                         ; Sets R1:R0 to the end of line pointer
code:000006AD                                         ; Sets B to the difference between current address and end of
code:000006AD                                         ; line
code:000006AF                 mov     DPL, R0         ; Data Pointer, Low Byte
code:000006B1                 mov     DPH, R1         ; Data Pointer, High Byte
code:000006B3                 lcall   DecrementDPTR
code:000006B6                 acall   InsertCharOnLine ; DPTR = End of source address
code:000006B6                                         ; DPTR+1 = End of destination address
code:000006B6                                         ; B = Number of chars to move
code:000006B6                                         ;
code:000006B6                                         ; Since this function moves in reverse, DPTR must point to
code:000006B6                                         ; the end of the buffer to move, not the start.
code:000006B8                 lcall   SetDPTRToCursorAddr
code:000006BB
code:000006BB SetAttrib:                              ; CODE XREF: InsertAttribute+4↑j
code:000006BB                                         ; InsertAttribute+B↑j
code:000006BB                 mov     A, R5
code:000006BC                 movx    @DPTR, A
code:000006BD                 inc     DPTR
code:000006BE                 mov     CursorAddr+1, DPL ; Data Pointer, Low Byte
code:000006C1                 mov     CursorAddr, DPH ; Data Pointer, High Byte
code:000006C4
code:000006C4 ReturnGate_6:                           ; CODE XREF: AttributeEdit:code_693↑j
code:000006C4                                         ; AttributeEdit:code_698↑j
code:000006C4                 ret
code:000006C4 ; End of function InsertAttribute
code:000006C4
code:000006C5
code:000006C5 ; =============== S U B R O U T I N E =======================================
code:000006C5
code:000006C5 ; Expects to be in register bank 0
code:000006C5 ;
code:000006C5 ; Sets R1:R0 to the end of line pointer
code:000006C5 ; Sets B to the difference between current address and end of
code:000006C5 ; line
code:000006C5
code:000006C5 CalcCursorEndOfLine:                    ; CODE XREF: TypeCharToScreen+3E↑p
code:000006C5                                         ; InsertAttribute+E↑p ...
code:000006C5                 acall   CalcCursorLinePtr ; Using CursorRow and the LineNumbers table, calculate the
code:000006C5                                         ; start of the cursor's line from a base of 0
code:000006C5                                         ;
code:000006C5                                         ; Returns value in B:A
code:000006C7                 mov     R1, B           ; B-Register
code:000006C9                 add     A, #95
code:000006CB                 jnc     code_6CE
code:000006CD
code:000006CD
code:000006CD                 inc     R1
code:000006CE
code:000006CE code_6CE:                               ; CODE XREF: CalcCursorEndOfLine+6↑j
code:000006CE                 mov     R0, A
code:000006CF
code:000006CF ;
code:000006CF ; R1:R0 is now the pointer to the current line + 95
code:000006CF ;
code:000006CF                 clr     C
code:000006D0                 subb    A, CursorAddr+1
code:000006D2                 mov     B, A            ; B-Register
code:000006D4
code:000006D4
code:000006D4                 orl     B0R1, #(VideoLine1 >> 8)
code:000006D7                 ret
code:000006D7 ; End of function CalcCursorEndOfLine
code:000006D7
code:000006D8
code:000006D8 ; =============== S U B R O U T I N E =======================================
code:000006D8
code:000006D8 ; Pulls a character string left by a cell, simulating
code:000006D8 ; backspace
code:000006D8 ;
code:000006D8 ; DPTR+1 = source address
code:000006D8 ; DPTR = destination address
code:000006D8 ; B = number of chars to move
code:000006D8
code:000006D8 DeleteCharOnLine:                       ; CODE XREF: TypeCharToScreen+4B↑p
code:000006D8                 mov     A, #1
code:000006DA
code:000006DA MoveNCharsBack:                         ; CODE XREF: ClearHomeToCursor+4D↓j
code:000006DA                                         ; EraseEntry:code_179D↓p ...
code:000006DA                 mov     R0, DPL         ; DPTR+A = source of move
code:000006DA                                         ; DPTR = destination of move
code:000006DA                                         ; B = number of chars to move
code:000006DC                 mov     R1, DPH         ; Data Pointer, High Byte
code:000006DE
code:000006DE
code:000006DE                 add     A, DPL          ; Data Pointer, Low Byte
code:000006E0                 mov     DPL, A          ; Data Pointer, Low Byte
code:000006E2                 jnc     CopyBlock       ; Copies B chars from DPTR to R1:R0
code:000006E2                                         ;
code:000006E2                                         ; If B=0, copies 256 bytes
code:000006E4
code:000006E4
code:000006E4                 inc     DPH             ; Data Pointer, High Byte
code:000006E6
code:000006E6 CopyBlock:                              ; CODE XREF: DeleteCharOnLine+A↑j
code:000006E6                                         ; DeleteCharOnLine+12↓j ...
code:000006E6                 movx    A, @DPTR        ; Copies B chars from DPTR to R1:R0
code:000006E6                                         ;
code:000006E6                                         ; If B=0, copies 256 bytes
code:000006E7                 inc     DPTR
code:000006E8                 acall   PrintCharToVRAM ; R1:R0 = destination
code:000006E8                                         ; A = character
code:000006E8                                         ;
code:000006E8                                         ; Auto-increments R1:R0
code:000006EA                 djnz    B, CopyBlock    ; Copies B chars from DPTR to R1:R0
code:000006EA                                         ;
code:000006EA                                         ; If B=0, copies 256 bytes
code:000006ED                 ret
code:000006ED ; End of function DeleteCharOnLine
code:000006ED
code:000006EE
code:000006EE ; =============== S U B R O U T I N E =======================================
code:000006EE
code:000006EE ; DPTR = End of source address
code:000006EE ; DPTR+1 = End of destination address
code:000006EE ; B = Number of chars to move
code:000006EE ;
code:000006EE ; Since this function moves in reverse, DPTR must point to
code:000006EE ; the end of the buffer to move, not the start.
code:000006EE
code:000006EE InsertCharOnLine:                       ; CODE XREF: InsertAttribute+17↑p
code:000006EE                 mov     A, #1
code:000006F0
code:000006F0 InsertNChars:                           ; CODE XREF: MoveMemory+32↓p
code:000006F0                 mov     R1, DPH         ; DPTR = End of source address
code:000006F0                                         ; DPTR+A = End of destination address
code:000006F0                                         ; B = Number of chars to move
code:000006F0                                         ;
code:000006F0                                         ; Since this function moves in reverse, DPTR must point to
code:000006F0                                         ; the end of the buffer to move, not the start.
code:000006F2                 add     A, DPL          ; Data Pointer, Low Byte
code:000006F4                 mov     R0, A
code:000006F5                 jnc     InsertLoop
code:000006F7
code:000006F7
code:000006F7                 inc     R1
code:000006F8
code:000006F8 InsertLoop:                             ; CODE XREF: InsertCharOnLine+7↑j
code:000006F8                                         ; InsertCharOnLine+1C↓j ...
code:000006F8                 movx    A, @DPTR
code:000006F9                 push    IE              ; Interrupt Enable Register
code:000006FB                 clr     EA              ; Interrupt Enable Register
code:000006FD
code:000006FD
code:000006FD                 mov     P2, R1          ; Port 2
code:000006FF                 movx    @R0, A
code:00000700
code:00000700
code:00000700                 pop     IE              ; Interrupt Enable Register
code:00000702                 dec     R0
code:00000703                 cjne    R0, #0xFF, code_707
code:00000706
code:00000706
code:00000706                 dec     R1
code:00000707
code:00000707 code_707:                               ; CODE XREF: InsertCharOnLine+15↑j
code:00000707                 lcall   DecrementDPTR
code:0000070A
code:0000070A
code:0000070A                 djnz    B, InsertLoop   ; B-Register
code:0000070D                 ret
code:0000070D ; End of function InsertCharOnLine
code:0000070D
code:0000070E
code:0000070E ; =============== S U B R O U T I N E =======================================
code:0000070E
code:0000070E
code:0000070E InsertReverseVideoAttr:                 ; DATA XREF: InterpretESC+1A↓o
code:0000070E                 mov     R5, #0x90
code:00000710                 sjmp    InsertAttribute ; A = attribute to insert
code:00000710 ; End of function InsertReverseVideoAttr
code:00000710
code:00000712
code:00000712 ; =============== S U B R O U T I N E =======================================
code:00000712
code:00000712
code:00000712 InsertNormalVideoAttr:                  ; DATA XREF: InterpretESC+1A↓o
code:00000712                 mov     R5, #0x80
code:00000714                 sjmp    InsertAttribute ; A = attribute to insert
code:00000714 ; End of function InsertNormalVideoAttr
code:00000714
code:00000716
code:00000716 ; =============== S U B R O U T I N E =======================================
code:00000716
code:00000716
code:00000716 SendPageToSerial:                       ; CODE XREF: InterpretESC+5↓j
code:00000716                 mov     R1, #0
code:00000718
code:00000718 code_718:                               ; CODE XREF: SendPageToSerial+6↓j
code:00000718                 inc     R1
code:00000719                 mov     A, R1
code:0000071A                 acall   SendScreenLineToSerial ; This function expects to be called in register bank 0
code:0000071C                 cjne    R1, #24, code_718
code:0000071F
code:0000071F
code:0000071F                 acall   SafeSerialSendCR
code:00000721                 ajmp    ExecuteBell
code:00000721 ; End of function SendPageToSerial
code:00000721
code:00000723
code:00000723 ; =============== S U B R O U T I N E =======================================
code:00000723
code:00000723
code:00000723 SafeSendTopLineToSerial:                ; DATA XREF: InterpretESC+1A↓o
code:00000723                 clr     A
code:00000724                 acall   SendScreenLineToSerial ; This function expects to be called in register bank 0
code:00000724 ; End of function SafeSendTopLineToSerial
code:00000724
code:00000726
code:00000726 ; =============== S U B R O U T I N E =======================================
code:00000726
code:00000726
code:00000726 SafeSerialSendCR:                       ; CODE XREF: SendPageToSerial+9↑p
code:00000726                                         ; SendRowToSerial+4↓j
code:00000726                 mov     A, #0xD
code:00000726 ; End of function SafeSerialSendCR
code:00000726
code:00000728
code:00000728 ; =============== S U B R O U T I N E =======================================
code:00000728
code:00000728 ; Waits until serial buffer is empty before sending next
code:00000728 ; character
code:00000728
code:00000728 SafeSerialSend:                         ; CODE XREF: SafeSerialSend↓j
code:00000728                                         ; SendScreenLineToSerial+1B↓p ...
code:00000728                 jb      VideoSettings.3, SafeSerialSend ; Waits until serial buffer is empty before sending next
code:00000728                                         ; character
code:0000072B                 setb    VideoSettings.3 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000072B                                         ; Bit 1 = Receive buffer is full
code:0000072B                                         ; Bit 3 = Serial send register busy
code:0000072B                                         ; Bit 4 = Busy drawing to screen
code:0000072B                                         ; Bit 5 = Steady/Blink
code:0000072B                                         ; Bit 6 = Disable keyboard
code:0000072B                                         ; Bit 7 = Standard/Graphics
code:0000072D                 mov     SBUF, A         ; Serial Channel Buffer Register
code:0000072F                 ret
code:0000072F ; End of function SafeSerialSend
code:0000072F
code:00000730
code:00000730 ; =============== S U B R O U T I N E =======================================
code:00000730
code:00000730
code:00000730 SendRowToSerial:                        ; DATA XREF: InterpretESC+1A↓o
code:00000730                 mov     A, CursorRow
code:00000732                 acall   SendScreenLineToSerial ; This function expects to be called in register bank 0
code:00000734                 ajmp    SafeSerialSendCR
code:00000734 ; End of function SendRowToSerial
code:00000734
code:00000736
code:00000736 ; =============== S U B R O U T I N E =======================================
code:00000736
code:00000736 ; This function expects to be called in register bank 0
code:00000736
code:00000736 SendScreenLineToSerial:                 ; CODE XREF: SendPageToSerial+4↑p
code:00000736                                         ; SafeSendTopLineToSerial+1↑p ...
code:00000736                 push    CursorColumn
code:00000738                 push    CursorRow
code:0000073A
code:0000073A
code:0000073A                 mov     CursorRow, A
code:0000073C                 mov     CursorColumn, #0
code:0000073F                 acall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:0000073F                                         ; column and the line table for calculation.
code:0000073F                                         ;
code:0000073F                                         ; Does not account for attributes in the row.  This is a
code:0000073F                                         ; bug.
code:00000741
code:00000741
code:00000741                 mov     B, #80          ; B-Register
code:00000744
code:00000744 LineLoop:                               ; CODE XREF: SendScreenLineToSerial+1D↓j
code:00000744                                         ; SendScreenLineToSerial+36↓j
code:00000744                 movx    A, @DPTR
code:00000745                 inc     DPTR
code:00000746                 acall   ScreenToVT52Char ; If the input is a graphics character, get its VT52
code:00000746                                         ; equivalent.  Set CharEquivalent when <0x80.  Return an
code:00000746                                         ; interpretation of the result:
code:00000746                                         ;
code:00000746                                         ; Original if 0x80 or higher
code:00000746                                         ;
code:00000746                                         ; Value returned is 0 if same class of value, 'G' (leave
code:00000746                                         ; graphics mode) if transition from graphics to normal, 'F'
code:00000746                                         ; (enter graphics mode) if transition from normal to
code:00000746                                         ; graphics
code:00000748
code:00000748
code:00000748                 jb      ACC7, SetAttribute ; Accumulator
code:0000074B
code:0000074B
code:0000074B                 jz      NoAttrChange
code:0000074D
code:0000074D
code:0000074D                 acall   SafeSerialSendESCCode ; Sends an escape code on the serial line
code:0000074D                                         ;
code:0000074D                                         ; A = code to send
code:0000074F
code:0000074F NoAttrChange:                           ; CODE XREF: SendScreenLineToSerial+15↑j
code:0000074F                 mov     A, CharEquivalent
code:00000751                 acall   SafeSerialSend  ; Waits until serial buffer is empty before sending next
code:00000751                                         ; character
code:00000753                 djnz    B, LineLoop     ; B-Register
code:00000756
code:00000756
code:00000756                 jnb     FormatStatus.2, code_75D ; Bit 0 = Ctrl-F1 pressed
code:00000756                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000756                                         ; Bit 2 = In graphics mode
code:00000759                 mov     A, #'G
code:0000075B                 acall   SafeSerialSendESCCode ; Sends an escape code on the serial line
code:0000075B                                         ;
code:0000075B                                         ; A = code to send
code:0000075D
code:0000075D code_75D:                               ; CODE XREF: SendScreenLineToSerial+20↑j
code:0000075D                 pop     CursorRow
code:0000075F                 pop     CursorColumn
code:00000761                 ret
code:00000762 ; ---------------------------------------------------------------------------
code:00000762
code:00000762 SetAttribute:                           ; CODE XREF: SendScreenLineToSerial+12↑j
code:00000762                 mov     R5, A           ; Save the actual attribute
code:00000763
code:00000763
code:00000763                 mov     A, #'s
code:00000765                 acall   SafeSerialSendESCCode ; Sends an escape code on the serial line
code:00000765                                         ;
code:00000765                                         ; A = code to send
code:00000767
code:00000767
code:00000767                 lcall   GetESCSAttributeCode ; Returns a digit between '0' and '7' for interpreting the
code:00000767                                         ; screen attribute into an ESC s <#> sequence
code:00000767                                         ;
code:00000767                                         ; Attribute character is R5 in bank 0
code:0000076A                 acall   SafeSerialSend  ; Waits until serial buffer is empty before sending next
code:0000076A                                         ; character
code:0000076C                 sjmp    LineLoop
code:0000076C ; End of function SendScreenLineToSerial
code:0000076C
code:0000076E
code:0000076E ; =============== S U B R O U T I N E =======================================
code:0000076E
code:0000076E ; Sends an escape code on the serial line
code:0000076E ;
code:0000076E ; A = code to send
code:0000076E
code:0000076E SafeSerialSendESCCode:                  ; CODE XREF: SendScreenLineToSerial+17↑p
code:0000076E                                         ; SendScreenLineToSerial+25↑p ...
code:0000076E                 push    ACC             ; Accumulator
code:00000770                 mov     A, #0x1B
code:00000772                 acall   SafeSerialSend  ; Waits until serial buffer is empty before sending next
code:00000772                                         ; character
code:00000774                 pop     ACC             ; Accumulator
code:00000776                 sjmp    SafeSerialSend  ; Waits until serial buffer is empty before sending next
code:00000776 ; End of function SafeSerialSendESCCode ; character
code:00000776
code:00000778
code:00000778 ; =============== S U B R O U T I N E =======================================
code:00000778
code:00000778
code:00000778 SetESCCodeInterpretMode:                ; DATA XREF: TypeCharToScreen+6A↑o
code:00000778                 mov     ContextFunctionPtr+1, #(InterpretESC & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000077B                 mov     ContextFunctionPtr, #(InterpretESC >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000077E
code:0000077E ReturnGate_0:                           ; CODE XREF: InterpretESC+A↓j
code:0000077E                 ret
code:0000077E ; End of function SetESCCodeInterpretMode
code:0000077E
code:0000077F
code:0000077F ;
code:0000077F ; Escape codes:
code:0000077F ; ESC # - Send the screen
code:0000077F ; ESC : <hex> - Store the value into 3008
code:0000077F ; ESC ; - Get the value stored into 3008
code:0000077F ; ESC A - Cursor up
code:0000077F ; ESC B - Cursor down
code:0000077F ; ESC C - Cursor right
code:0000077F ; ESC D - Cursor left
code:0000077F ; ESC E - Clear screen
code:0000077F ; ESC F - Enter graphics mode
code:0000077F ; ESC G - Exit graphics mode
code:0000077F ; ESC H - Home
code:0000077F ; ESC I - Reverse line feed
code:0000077F ; ESC J - Clear to end of screen
code:0000077F ; ESC K - Clear to end of line
code:0000077F ; ESC L - Insert line
code:0000077F ; ESC M - Delete line
code:0000077F ; ESC N - Erase previous char (does not scroll following
code:0000077F ;         chars)
code:0000077F ; ESC X hhmmyy - Set the time with the digits given
code:0000077F ; ESC Y R C - Set row and column using ascii characters
code:0000077F ;         Characters act as a base-80 numbering system
code:0000077F ;         without a 0.  The characters are in order:
code:0000077F ;           ! " # $ % & ' ( )
code:0000077F ;         * + , - . / 0 1 2 3
code:0000077F ;         4 5 6 7 8 9 : ; < =
code:0000077F ;         > ? @ A B C D E F G
code:0000077F ;         H I J K L M N O P Q
code:0000077F ;         R S T U V W X Y Z [
code:0000077F ;         / ] ^ _ ` a b c d e
code:0000077F ;         f g h i j k l m n o
code:0000077F ;
code:0000077F ; ESC Z - Sends ESC, slash, and K sequence.  ???
code:0000077F ; ESC ] - Sends the top line text
code:0000077F ; ESC ^ - Sends the line text that the cursor is on
code:0000077F ; ESC _ - Sends the character under the cursor
code:0000077F ; ESC ` - Sends the screen to the printer
code:0000077F ; ESC b - Deletes from HOME to the cursor position.  Moves
code:0000077F ;         remaining text after cursor on current line to
code:0000077F ;         beginning of line
code:0000077F ; ESC c - Show clock
code:0000077F ; ESC d - Don't show clock
code:0000077F ; ESC e - Send time string
code:0000077F ; ESC i - Clear the top line *
code:0000077F ; ESC j - Save cursor position
code:0000077F ; ESC k - Restore cursor position (move to most recent
code:0000077F ;         save)
code:0000077F ; ESC l - Clear line at cursor
code:0000077F ; ESC n - Sends the cursor position as ESC Y sequence (see
code:0000077F ;         above)
code:0000077F ; ESC o - Delete from beginning of line to cursor
code:0000077F ; ESC p - Insert reverse video at cursor
code:0000077F ; ESC q - Insert normal video at cursor
code:0000077F ; ESC r <L> - Set baud rate.  Baud rates are represented
code:0000077F ;         as A,B,C,D,E,H,J, and Z.  J requires the ability
code:0000077F ;         to use double-baud rate
code:0000077F ; ESC s <D> - Insert attribute.  Attributes are:
code:0000077F ;         0 - Normal
code:0000077F ;         1 - Reverse
code:0000077F ;         2 - Blink
code:0000077F ;         3 - Reverse blink
code:0000077F ;         4 - Highlight
code:0000077F ;         5 - Reverse highlight
code:0000077F ;         6 - Blink highlight
code:0000077F ;         7 - Reverse blink highlight
code:0000077F ; ESC v - Wrap at EOL
code:0000077F ; ESC w - Don't wrap at EOL
code:0000077F ; ESC x <d> - Enable a setting
code:0000077F ; ESC y <d> - Disable a setting
code:0000077F ;         Both of these use the same setting digits:
code:0000077F ;         1 - Status line
code:0000077F ;         2 - Key click
code:0000077F ;         5 - Screen updates
code:0000077F ;         8 - CR->CRLF (inverted sense)
code:0000077F ;         9 - LF->CRLF (inverted sense)
code:0000077F ;         : - Printer (inverted sense)
code:0000077F ;         ; - Cursor (blink or reverse video)
code:0000077F ;         < - Auto-repeat keypresses
code:0000077F ;         = - Top status line
code:0000077F ;         > - Full/Half duplex
code:0000077F ;         ? - Bug (Should have limited to >)
code:0000077F ;
code:0000077F ; ESC z - Reset the terminal
code:0000077F ; ESC { - Enable keyboard
code:0000077F ; ESC } - Disable keyboard
code:0000077F ;
code:0000077F
code:0000077F ; =============== S U B R O U T I N E =======================================
code:0000077F
code:0000077F
code:0000077F InterpretESC:                           ; DATA XREF: SetESCCodeInterpretMode↑o
code:0000077F                                         ; SetESCCodeInterpretMode+3↑o
code:0000077F                 acall   SetNormalInputMode ; Regardless of the character following ESC, return to normal
code:0000077F                                         ; character interpretation
code:00000781
code:00000781
code:00000781                 cjne    A, #'#, DoLookup
code:00000784
code:00000784
code:00000784                 sjmp    SendPageToSerial
code:00000786 ; ---------------------------------------------------------------------------
code:00000786
code:00000786 DoLookup:                               ; CODE XREF: InterpretESC+2↑j
code:00000786                 clr     C
code:00000787                 subb    A, #':
code:00000789                 jc      ReturnGate_0
code:0000078B
code:0000078B
code:0000078B                 rl      A
code:0000078C                 mov     R5, A
code:0000078D                 add     A, #10
code:0000078F                 movc    A, @A+PC
code:00000790                 push    ACC             ; Accumulator
code:00000792                 mov     A, R5
code:00000793                 add     A, #3
code:00000795                 movc    A, @A+PC
code:00000796                 push    ACC             ; Accumulator
code:00000798                 ret
code:00000798 ; ---------------------------------------------------------------------------
code:00000799                 .word RecvAsHex         ; 0 ; Sends as a hex digit from 0x3008
code:00000799                 .word SendAsHex         ; 1
code:00000799                 .word nullsub_2         ; 2
code:00000799                 .word nullsub_2         ; 3
code:00000799                 .word nullsub_2         ; 4
code:00000799                 .word nullsub_2         ; 5
code:00000799                 .word nullsub_2         ; 6
code:00000799                 .word CursorUp          ; 7
code:00000799                 .word CursorDown        ; 8
code:00000799                 .word CursorRight       ; 9
code:00000799                 .word CursorLeft        ; 10
code:00000799                 .word ClearTTY          ; 11
code:00000799                 .word EnterGraphicsMode ; 12
code:00000799                 .word ExitGraphicsMode  ; 13
code:00000799                 .word HomeTTY           ; 14
code:00000799                 .word ReverseLineFeed   ; 15
code:00000799                 .word ClearToEndOfScreen; 16
code:00000799                 .word ClearToEndOfLine  ; 17
code:00000799                 .word InsertLine        ; 18
code:00000799                 .word DeleteLine        ; 19
code:00000799                 .word TypeBackspace     ; 20
code:00000799                 .word nullsub_2         ; 21
code:00000799                 .word nullsub_2         ; 22
code:00000799                 .word nullsub_2         ; 23
code:00000799                 .word nullsub_2         ; 24
code:00000799                 .word nullsub_2         ; 25
code:00000799                 .word nullsub_2         ; 26
code:00000799                 .word nullsub_2         ; 27
code:00000799                 .word nullsub_2         ; 28
code:00000799                 .word nullsub_2         ; 29
code:00000799                 .word SetTimeByESCCode  ; 30
code:00000799                 .word EnterReadCursorPosMode; 31
code:00000799                 .word SendESCSlashK     ; 32
code:00000799                 .word nullsub_2         ; 33
code:00000799                 .word nullsub_2         ; 34
code:00000799                 .word SafeSendTopLineToSerial; 35
code:00000799                 .word SendRowToSerial   ; 36
code:00000799                 .word SendCharUnderCursor; 37
code:00000799                 .word PrintScreen       ; 38
code:00000799                 .word nullsub_2         ; 39
code:00000799                 .word ClearHomeToCursor ; 40
code:00000799                 .word ShowClock         ; 41
code:00000799                 .word DontShowClock     ; 42
code:00000799                 .word SendTimeString    ; 43
code:00000799                 .word nullsub_2         ; 44
code:00000799                 .word nullsub_2         ; 45
code:00000799                 .word nullsub_2         ; 46
code:00000799                 .word ClearTopLineIfDisabled; 47
code:00000799                 .word SaveCursorPosition; 48
code:00000799                 .word LoadCursorPosition; 49
code:00000799                 .word ClearLineAtCursor ; 50
code:00000799                 .word nullsub_2         ; 51
code:00000799                 .word SendCursorPosAsESC; 52
code:00000799                 .word ClearLineStartToCursor; 53
code:00000799                 .word InsertReverseVideoAttr; 54
code:00000799                 .word InsertNormalVideoAttr; 55
code:00000799                 .word EnterSetBaudRateMode; 56
code:00000799                 .word EnterAttributeEdit; 57
code:00000799                 .word nullsub_2         ; 58
code:00000799                 .word nullsub_2         ; 59
code:00000799                 .word WrapAtEOL         ; 60
code:00000799                 .word DontWrapAtEOL     ; 61
code:00000799                 .word EnterSettingDisable; 62
code:00000799                 .word EnterSettingEnable; 63
code:00000799                 .word Reset             ; 64
code:00000799                 .word EnableKeyboard    ; 65
code:00000799                 .word nullsub_2         ; 66
code:00000799                 .word DisableKeyboard   ; 67
code:00000799                 .word nullsub_2         ; 68
code:00000799                 .word nullsub_2         ; 69
code:00000825 ; ---------------------------------------------------------------------------
code:00000825
code:00000825 nullsub_2:                              ; DATA XREF: InterpretESC+1A↑o
code:00000825                 ret
code:00000825 ; End of function InterpretESC
code:00000825
code:00000826
code:00000826 ; =============== S U B R O U T I N E =======================================
code:00000826
code:00000826 ; Returns a digit between '0' and '7' for interpreting the
code:00000826 ; screen attribute into an ESC s <#> sequence
code:00000826 ;
code:00000826 ; Attribute character is R5 in bank 0
code:00000826
code:00000826 GetESCSAttributeCode:                   ; CODE XREF: SendCharUnderCursor+21↑p
code:00000826                                         ; SendScreenLineToSerial+31↑p
code:00000826                 mov     R0, #0
code:00000828
code:00000828 code_828:                               ; CODE XREF: GetESCSAttributeCode+7↓j
code:00000828                 inc     R0
code:00000829                 mov     A, R0
code:0000082A                 lcall   GetAttributeByIndex
code:0000082D
code:0000082D
code:0000082D                 cjne    A, B0R5_MappedCursorRow, code_828
code:00000830
code:00000830
code:00000830                 mov     A, #0x2F
code:00000832                 add     A, R0
code:00000833                 ret
code:00000833 ; End of function GetESCSAttributeCode
code:00000833
code:00000834
code:00000834 ; =============== S U B R O U T I N E =======================================
code:00000834
code:00000834
code:00000834 SendPrinterChar:                        ; CODE XREF: ProcessInputWithContextFunction+3↑p
code:00000834                                         ; PrintScreen+25↓p ...
code:00000834                 push    DPL             ; Data Pointer, Low Byte
code:00000836                 push    DPH             ; Data Pointer, High Byte
code:00000838                 mov     DPTR, #PrinterOutPort
code:0000083B                 movx    @DPTR, A
code:0000083C                 pop     DPH             ; Data Pointer, High Byte
code:0000083E                 pop     DPL             ; Data Pointer, Low Byte
code:00000840
code:00000840
code:00000840                 setb    P16             ; Port 1
code:00000842                 clr     P16             ; Port 1
code:00000844
code:00000844 code_844:                               ; CODE XREF: SendPrinterChar:code_844↓j
code:00000844                 jb      P17, code_844   ; Port 1
code:00000847                 ret
code:00000847 ; End of function SendPrinterChar
code:00000847
code:00000848
code:00000848 ; =============== S U B R O U T I N E =======================================
code:00000848
code:00000848 ; Ignores attributes
code:00000848
code:00000848 PrintScreen:                            ; DATA XREF: InterpretESC+1A↑o
code:00000848                 mov     C, PrinterStatus.0 ; Bit 0 = Printer
code:00000848                                         ; Bit 1 = Need to send XOFF
code:00000848                                         ; Bit 2 = Toggle printer state
code:00000848                                         ; Bit 3 = No writes to status line
code:00000848                                         ;         No update of time or print status.  Set cursor position ESC
code:00000848                                         ;         code cannot set cursor to row 1
code:00000848                                         ; Bit 4 = No writes to status line
code:00000848                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000848                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000848                                         ;         position to row 1
code:00000848                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000848                                         ; Bit 6 = Key pressed
code:00000848                                         ; Bit 7 = Repeat eligible
code:0000084A                 push    PSW             ; Program Status Word Register
code:0000084C
code:0000084C
code:0000084C                 lcall   TestPrinterPresence
code:0000084F                 jnb     PrinterStatus.0, code_880 ; Bit 0 = Printer
code:0000084F                                         ; Bit 1 = Need to send XOFF
code:0000084F                                         ; Bit 2 = Toggle printer state
code:0000084F                                         ; Bit 3 = No writes to status line
code:0000084F                                         ;         No update of time or print status.  Set cursor position ESC
code:0000084F                                         ;         code cannot set cursor to row 1
code:0000084F                                         ; Bit 4 = No writes to status line
code:0000084F                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:0000084F                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:0000084F                                         ;         position to row 1
code:0000084F                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:0000084F                                         ; Bit 6 = Key pressed
code:0000084F                                         ; Bit 7 = Repeat eligible
code:00000852                 push    CursorColumn
code:00000854                 push    CursorRow
code:00000856
code:00000856
code:00000856                 mov     R1, #0
code:00000858
code:00000858 PrintNextLineLoop:                      ; CODE XREF: PrintScreen+31↓j
code:00000858                 inc     R1
code:00000859                 mov     CursorRow, R1
code:0000085B                 mov     CursorColumn, #0
code:0000085E                 lcall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:0000085E                                         ; column and the line table for calculation.
code:0000085E                                         ;
code:0000085E                                         ; Does not account for attributes in the row.  This is a
code:0000085E                                         ; bug.
code:00000861                 mov     R2, #80
code:00000863
code:00000863 PrintNextCharLoop:                      ; CODE XREF: PrintScreen+20↓j
code:00000863                                         ; PrintScreen+27↓j
code:00000863                 movx    A, @DPTR
code:00000864                 inc     DPTR
code:00000865                 lcall   ScreenToVT52Char ; If the input is a graphics character, get its VT52
code:00000865                                         ; equivalent.  Set CharEquivalent when <0x80.  Return an
code:00000865                                         ; interpretation of the result:
code:00000865                                         ;
code:00000865                                         ; Original if 0x80 or higher
code:00000865                                         ;
code:00000865                                         ; Value returned is 0 if same class of value, 'G' (leave
code:00000865                                         ; graphics mode) if transition from graphics to normal, 'F'
code:00000865                                         ; (enter graphics mode) if transition from normal to
code:00000865                                         ; graphics
code:00000868                 jb      ACC7, PrintNextCharLoop ; Accumulator
code:0000086B
code:0000086B
code:0000086B                 mov     A, CharEquivalent
code:0000086D                 acall   SendPrinterChar
code:0000086F                 djnz    R2, PrintNextCharLoop
code:00000871
code:00000871
code:00000871                 mov     A, #0xD
code:00000873                 acall   SendPrinterChar
code:00000875                 mov     A, #0xA
code:00000877                 acall   SendPrinterChar
code:00000879                 cjne    R1, #24, PrintNextLineLoop
code:0000087C
code:0000087C
code:0000087C                 pop     CursorRow
code:0000087E                 pop     CursorColumn
code:00000880
code:00000880 code_880:                               ; CODE XREF: PrintScreen+7↑j
code:00000880                 pop     PSW             ; Program Status Word Register
code:00000882                 mov     PrinterStatus.0, C ; Bit 0 = Printer
code:00000882                                         ; Bit 1 = Need to send XOFF
code:00000882                                         ; Bit 2 = Toggle printer state
code:00000882                                         ; Bit 3 = No writes to status line
code:00000882                                         ;         No update of time or print status.  Set cursor position ESC
code:00000882                                         ;         code cannot set cursor to row 1
code:00000882                                         ; Bit 4 = No writes to status line
code:00000882                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000882                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000882                                         ;         position to row 1
code:00000882                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000882                                         ; Bit 6 = Key pressed
code:00000882                                         ; Bit 7 = Repeat eligible
code:00000884                 ret
code:00000884 ; End of function PrintScreen
code:00000884
code:00000885
code:00000885 ; =============== S U B R O U T I N E =======================================
code:00000885
code:00000885
code:00000885 InsertLine:                             ; DATA XREF: InterpretESC+1A↑o
code:00000885                 mov     B, #24          ; B-Register
code:00000888                 acall   ClearLine       ; B = line index
code:00000888                                         ;
code:00000888                                         ; Clear the line
code:0000088A                 mov     A, CursorRow
code:0000088C                 jz      code_8AE
code:0000088E
code:0000088E
code:0000088E                 cjne    A, #24, RenumberLoop
code:00000891
code:00000891
code:00000891                 ajmp    code_8AE
code:00000893 ; ---------------------------------------------------------------------------
code:00000893
code:00000893 ;
code:00000893 ; Move the line numbers down.  First save line 24
code:00000893 ;
code:00000893
code:00000893 RenumberLoop:                           ; CODE XREF: InsertLine+9↑j
code:00000893                 mov     A, #(LineNumbers+0x18) ; In order to make scrolling faster, the system does not
code:00000893                                         ; actually move data around.  Instead, it uses this array of
code:00000893                                         ; lines as a list of indices into VRAM.  To scroll the
code:00000893                                         ; screen, just rotate these numbers so that what was once
code:00000893                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:00000893                                         ; scroll operation.
code:00000895                 mov     R0, A
code:00000896                 mov     R1, A
code:00000897                 dec     R1
code:00000898                 mov     A, #24
code:0000089A                 clr     C
code:0000089B                 subb    A, CursorRow
code:0000089D                 mov     R4, A
code:0000089E
code:0000089E ;
code:0000089E ; Renumber the lines to scroll down.  We now have the
code:0000089E ; following values:
code:0000089E ;   R0 = destination ptr
code:0000089E ;   R1 = source ptr
code:0000089E ;   R4 = number of lines to relocate
code:0000089E ;   R5 = original last line index
code:0000089E ;
code:0000089E                 mov     B0R5_MappedCursorRow, @R0
code:000008A0                 push    IE              ; Interrupt Enable Register
code:000008A2                 clr     EA              ; Interrupt Enable Register
code:000008A4
code:000008A4 CopyDownLoop:                           ; CODE XREF: InsertLine+23↓j
code:000008A4                 mov     A, @R1
code:000008A5                 mov     @R0, A
code:000008A6                 dec     R0
code:000008A7                 dec     R1
code:000008A8                 djnz    R4, CopyDownLoop
code:000008AA
code:000008AA
code:000008AA                 mov     @R0, B0R5_MappedCursorRow
code:000008AC                 pop     IE              ; Interrupt Enable Register
code:000008AE
code:000008AE code_8AE:                               ; CODE XREF: InsertLine+7↑j
code:000008AE                                         ; InsertLine+C↑j
code:000008AE                 mov     CursorColumn, #0
code:000008B1                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000008B1 ; End of function InsertLine            ; attributes
code:000008B1
code:000008B4
code:000008B4 ; =============== S U B R O U T I N E =======================================
code:000008B4
code:000008B4
code:000008B4 DeleteLine:                             ; DATA XREF: InterpretESC+1A↑o
code:000008B4                 mov     B, CursorRow    ; B-Register
code:000008B7                 acall   ClearLine       ; B = line index
code:000008B7                                         ;
code:000008B7                                         ; Clear the line
code:000008B9                 mov     A, CursorRow
code:000008BB                 jz      Done
code:000008BD
code:000008BD
code:000008BD                 cjne    A, #24, ScrollUpFromBottom
code:000008C0
code:000008C0
code:000008C0                 ajmp    Done
code:000008C2 ; ---------------------------------------------------------------------------
code:000008C2
code:000008C2 ScrollUpFromBottom:                     ; CODE XREF: DeleteLine+9↑j
code:000008C2                 add     A, #LineNumbers ; In order to make scrolling faster, the system does not
code:000008C2                                         ; actually move data around.  Instead, it uses this array of
code:000008C2                                         ; lines as a list of indices into VRAM.  To scroll the
code:000008C2                                         ; screen, just rotate these numbers so that what was once
code:000008C2                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
code:000008C2                                         ; scroll operation.
code:000008C4                 mov     R0, A
code:000008C5                 mov     R1, A
code:000008C6                 inc     R1
code:000008C7                 mov     A, #24
code:000008C9                 clr     C
code:000008CA                 subb    A, CursorRow
code:000008CC                 mov     R4, A
code:000008CD                 mov     B0R5_MappedCursorRow, @R0
code:000008CF                 clr     EA              ; Interrupt Enable Register
code:000008D1
code:000008D1 ;
code:000008D1 ; Save the line we just deleted.  We'll be moving the rest
code:000008D1 ; of the lines up one.  The register values are:
code:000008D1 ;   R0 = destination ptr
code:000008D1 ;   R1 = source ptr
code:000008D1 ;   R4 = number of lines
code:000008D1 ;   R5 = original cursor line
code:000008D1 ;
code:000008D1
code:000008D1 ScrollUpLoop:                           ; CODE XREF: DeleteLine+21↓j
code:000008D1                 mov     A, @R1
code:000008D2                 mov     @R0, A
code:000008D3                 inc     R0
code:000008D4                 inc     R1
code:000008D5                 djnz    R4, ScrollUpLoop
code:000008D7
code:000008D7 ;
code:000008D7 ; Place the deleted line at the bottom
code:000008D7 ;
code:000008D7                 mov     @R0, B0R5_MappedCursorRow
code:000008D9                 setb    EA              ; Interrupt Enable Register
code:000008DB
code:000008DB Done:                                   ; CODE XREF: DeleteLine+7↑j
code:000008DB                                         ; DeleteLine+C↑j
code:000008DB                 mov     CursorColumn, #0
code:000008DE                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000008DE ; End of function DeleteLine            ; attributes
code:000008DE
code:000008E1
code:000008E1 ; =============== S U B R O U T I N E =======================================
code:000008E1
code:000008E1
code:000008E1 SetDPTRToCursorAddr:                    ; CODE XREF: InsertAttribute↑p
code:000008E1                                         ; InsertAttribute+19↑p ...
code:000008E1                 mov     DPL, CursorAddr+1 ; Data Pointer, Low Byte
code:000008E4                 mov     DPH, CursorAddr ; Data Pointer, High Byte
code:000008E7                 ret
code:000008E7 ; End of function SetDPTRToCursorAddr
code:000008E7
code:000008E8
code:000008E8 ; =============== S U B R O U T I N E =======================================
code:000008E8
code:000008E8
code:000008E8 ClearHomeToCursor:                      ; DATA XREF: InterpretESC+1A↑o
code:000008E8                 mov     A, CursorRow
code:000008EA                 jz      ClearLineStartToCursor
code:000008EC
code:000008EC
code:000008EC                 mov     R5, #0
code:000008EE
code:000008EE ClearLineNext:                          ; CODE XREF: ClearHomeToCursor+11↓j
code:000008EE                 inc     R5
code:000008EF                 mov     A, R5
code:000008F0                 cjne    A, CursorRow, ClearLineLoop
code:000008F3
code:000008F3
code:000008F3                 ajmp    ClearLineStartToCursor
code:000008F5 ; ---------------------------------------------------------------------------
code:000008F5
code:000008F5 ClearLineLoop:                          ; CODE XREF: ClearHomeToCursor+8↑j
code:000008F5                 mov     B, A            ; B-Register
code:000008F7                 acall   ClearLine       ; B = line index
code:000008F7                                         ;
code:000008F7                                         ; Clear the line
code:000008F9                 ajmp    ClearLineNext
code:000008FB ; ---------------------------------------------------------------------------
code:000008FB
code:000008FB ClearLineStartToCursor:                 ; CODE XREF: ClearHomeToCursor+2↑j
code:000008FB                                         ; ClearHomeToCursor+B↑j
code:000008FB                                         ; DATA XREF: ...
code:000008FB                 acall   SetDPTRToCursorAddr
code:000008FD
code:000008FD
code:000008FD                 movx    A, @DPTR
code:000008FE                 mov     R5, A
code:000008FF
code:000008FF ;
code:000008FF ; Find the number of bytes needed to reach the cursor
code:000008FF ; position from the beginning of the line.  We do this
code:000008FF ; by calculating the number of bytes to the END of the
code:000008FF ; line, then pulling an uno reverse subtracting it from
code:000008FF ; 96 to get the number of bytes from the beginning.  Why
code:000008FF ; not just get the address of the beginning of the line
code:000008FF ; vs the current position?  Who knows?
code:000008FF ;
code:000008FF                 lcall   CalcCursorEndOfLine ; Expects to be in register bank 0
code:000008FF                                         ;
code:000008FF                                         ; Sets R1:R0 to the end of line pointer
code:000008FF                                         ; Sets B to the difference between current address and end of
code:000008FF                                         ; line
code:00000902                 mov     R6, A
code:00000903                 mov     A, #96
code:00000905                 clr     C
code:00000906                 subb    A, B            ; B-Register
code:00000908
code:00000908 ;
code:00000908 ; Note that we now get the pointer to the beginning of the
code:00000908 ; line.  <waves hands at previous efforts>
code:00000908 ;
code:00000908                 push    CursorColumn
code:0000090A                 mov     CursorColumn, #0
code:0000090D
code:0000090D
code:0000090D                 push    ACC             ; Accumulator
code:0000090F
code:0000090F
code:0000090F                 lcall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:0000090F                                         ; column and the line table for calculation.
code:0000090F                                         ;
code:0000090F                                         ; Does not account for attributes in the row.  This is a
code:0000090F                                         ; bug.
code:00000912
code:00000912 ;
code:00000912 ; Now clear to the current position.  If the remaining
code:00000912 ; text on the line is shorter than the to-be-deleted text
code:00000912 ; on the line, a naive relocate would leave junk following
code:00000912 ; the end of the relocated text.  But why not just clear
code:00000912 ; to the end of the line from there?  Seems like
code:00000912 ; everything is being done in a confusing order, and
code:00000912 ; is potentially more complicated than it needs to be.
code:00000912 ;
code:00000912                 pop     B               ; B-Register
code:00000914                 lcall   memset_spaces   ; B = count
code:00000914                                         ; DPTR = address
code:00000917
code:00000917 ;
code:00000917 ; Need to shift the text under the cursor to the beginning
code:00000917 ; of the line
code:00000917 ;
code:00000917                 pop     CursorColumn
code:00000919                 lcall   CalcCursorDPTR  ; Updates the DPTR register using the cursor row and
code:00000919                                         ; column and the line table for calculation.
code:00000919                                         ;
code:00000919                                         ; Does not account for attributes in the row.  This is a
code:00000919                                         ; bug.
code:0000091C                 mov     A, CursorAddr+1
code:0000091E                 clr     C
code:0000091F                 subb    A, DPL          ; Data Pointer, Low Byte
code:00000921                 mov     CursorAddr+1, DPL ; Data Pointer, Low Byte
code:00000924                 mov     CursorAddr, DPH ; Data Pointer, High Byte
code:00000927
code:00000927 ;
code:00000927 ; If we were sitting on an attribute, move to the char
code:00000927 ; before it
code:00000927 ;
code:00000927                 xch     A, R5
code:00000928                 jnb     ACC7, CalcCharsToDelete ; Accumulator
code:0000092B
code:0000092B
code:0000092B                 dec     R6
code:0000092C                 inc     R5
code:0000092D
code:0000092D ;
code:0000092D ; Finally, see if there's a difference between actual
code:0000092D ; address and calculated address.  If so, that indicates
code:0000092D ; that attributes were destroyed too.  Need to shift the
code:0000092D ; text so that removing previous attributes on the line
code:0000092D ; doesn't shift the remaining text on the screen.
code:0000092D ;
code:0000092D
code:0000092D CalcCharsToDelete:                      ; CODE XREF: ClearHomeToCursor+40↑j
code:0000092D                 xch     A, R5
code:0000092E                 mov     B, R6           ; B-Register
code:00000930                 djnz    B, ShiftByEatenAttributes ; B-Register
code:00000933
code:00000933
code:00000933                 ret
code:00000934 ; ---------------------------------------------------------------------------
code:00000934
code:00000934 ShiftByEatenAttributes:                 ; CODE XREF: ClearHomeToCursor+48↑j
code:00000934                 inc     DPTR
code:00000935                 ljmp    MoveNCharsBack  ; DPTR+A = source of move
code:00000935 ; End of function ClearHomeToCursor     ; DPTR = destination of move
code:00000935                                         ; B = number of chars to move
code:00000938
code:00000938 ; =============== S U B R O U T I N E =======================================
code:00000938
code:00000938
code:00000938 ClearToEndOfScreen:                     ; DATA XREF: InterpretESC+1A↑o
code:00000938                 mov     A, CursorRow
code:0000093A                 jz      ClearToEndOfLine
code:0000093C
code:0000093C
code:0000093C                 mov     R5, A
code:0000093D
code:0000093D code_93D:                               ; CODE XREF: ClearToEndOfScreen+10↓j
code:0000093D                 inc     R5
code:0000093E                 mov     A, R5
code:0000093F                 cjne    A, #25, code_944
code:00000942
code:00000942
code:00000942                 ajmp    ClearToEndOfLine
code:00000944 ; ---------------------------------------------------------------------------
code:00000944
code:00000944 code_944:                               ; CODE XREF: ClearToEndOfScreen+7↑j
code:00000944                 mov     B, A            ; B-Register
code:00000946                 acall   ClearLine       ; B = line index
code:00000946                                         ;
code:00000946                                         ; Clear the line
code:00000948                 ajmp    code_93D
code:0000094A ; ---------------------------------------------------------------------------
code:0000094A
code:0000094A ClearToEndOfLine:                       ; CODE XREF: ClearToEndOfScreen+2↑j
code:0000094A                                         ; ClearToEndOfScreen+A↑j
code:0000094A                                         ; DATA XREF: ...
code:0000094A                 lcall   CalcCursorEndOfLine ; Expects to be in register bank 0
code:0000094A                                         ;
code:0000094A                                         ; Sets R1:R0 to the end of line pointer
code:0000094A                                         ; Sets B to the difference between current address and end of
code:0000094A                                         ; line
code:0000094D                 inc     B               ; B-Register
code:0000094F                 acall   SetDPTRToCursorAddr
code:00000951                 ljmp    memset_spaces   ; B = count
code:00000951 ; End of function ClearToEndOfScreen    ; DPTR = address
code:00000951
code:00000954
code:00000954 ; =============== S U B R O U T I N E =======================================
code:00000954
code:00000954
code:00000954 ClearLineAtCursor:                      ; DATA XREF: InterpretESC+1A↑o
code:00000954                 mov     B, CursorRow    ; B-Register
code:00000957                 acall   ClearLine       ; B = line index
code:00000957                                         ;
code:00000957                                         ; Clear the line
code:00000959                 ljmp    CalcCursorAddr  ; Updates the CursorAddr pointer using the cursor row and
code:00000959 ; End of function ClearLineAtCursor     ; column and the line table for calculation.
code:00000959                                         ;
code:00000959                                         ; Does not account for attributes in the row.  This is a
code:00000959                                         ; bug.
code:0000095C
code:0000095C ; =============== S U B R O U T I N E =======================================
code:0000095C
code:0000095C ; B = line index
code:0000095C ;
code:0000095C ; Clear the line
code:0000095C
code:0000095C ClearLine:                              ; CODE XREF: TypeLF+10↑p
code:0000095C                                         ; ReverseLineFeed+A↑p ...
code:0000095C                 mov     A, B            ; B-Register
code:0000095E                 lcall   CalcLinePtr     ; A = line index
code:0000095E                                         ;
code:0000095E                                         ; Using line index and the LineNumbers table, calculate the
code:0000095E                                         ; start of the cursor's line
code:00000961                 mov     DPL, A          ; Data Pointer, Low Byte
code:00000963                 mov     A, B            ; B-Register
code:00000965                 add     A, #(VideoLine1 >> 8)
code:00000967                 mov     DPH, A          ; Data Pointer, High Byte
code:00000969                 ljmp    ClearLineBytes  ; DPTR = line pointer
code:00000969 ; End of function ClearLine             ;
code:00000969                                         ; Low-level routine to clear a line
code:0000096C
code:0000096C ; =============== S U B R O U T I N E =======================================
code:0000096C
code:0000096C
code:0000096C EnterGraphicsMode:                      ; DATA XREF: InterpretESC+1A↑o
code:0000096C                 setb    VideoSettings.7 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000096C                                         ; Bit 1 = Receive buffer is full
code:0000096C                                         ; Bit 3 = Serial send register busy
code:0000096C                                         ; Bit 4 = Busy drawing to screen
code:0000096C                                         ; Bit 5 = Steady/Blink
code:0000096C                                         ; Bit 6 = Disable keyboard
code:0000096C                                         ; Bit 7 = Standard/Graphics
code:0000096E                 ret
code:0000096E ; End of function EnterGraphicsMode
code:0000096E
code:0000096F
code:0000096F ; =============== S U B R O U T I N E =======================================
code:0000096F
code:0000096F
code:0000096F ExitGraphicsMode:                       ; DATA XREF: InterpretESC+1A↑o
code:0000096F                 clr     VideoSettings.7 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000096F                                         ; Bit 1 = Receive buffer is full
code:0000096F                                         ; Bit 3 = Serial send register busy
code:0000096F                                         ; Bit 4 = Busy drawing to screen
code:0000096F                                         ; Bit 5 = Steady/Blink
code:0000096F                                         ; Bit 6 = Disable keyboard
code:0000096F                                         ; Bit 7 = Standard/Graphics
code:00000971                 ret
code:00000971 ; End of function ExitGraphicsMode
code:00000971
code:00000972
code:00000972 ; =============== S U B R O U T I N E =======================================
code:00000972
code:00000972
code:00000972 WrapAtEOL:                              ; DATA XREF: InterpretESC+1A↑o
code:00000972                 clr     SerialSettings.7 ; Bit 0 = Clock display off
code:00000972                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000972                                         ; Bit 2 = Half/Full duplex
code:00000972                                         ; Bit 3 = Auto Repeat disable
code:00000972                                         ; Bit 4 = Key click disable
code:00000972                                         ; Bit 5 = LF->CRLF
code:00000972                                         ; Bit 6 = CR->CRLF
code:00000972                                         ; Bit 7 = Wrap at EOL off
code:00000974                 ret
code:00000974 ; End of function WrapAtEOL
code:00000974
code:00000975
code:00000975 ; =============== S U B R O U T I N E =======================================
code:00000975
code:00000975
code:00000975 DontWrapAtEOL:                          ; DATA XREF: InterpretESC+1A↑o
code:00000975                 setb    SerialSettings.7 ; Bit 0 = Clock display off
code:00000975                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000975                                         ; Bit 2 = Half/Full duplex
code:00000975                                         ; Bit 3 = Auto Repeat disable
code:00000975                                         ; Bit 4 = Key click disable
code:00000975                                         ; Bit 5 = LF->CRLF
code:00000975                                         ; Bit 6 = CR->CRLF
code:00000975                                         ; Bit 7 = Wrap at EOL off
code:00000977                 ret
code:00000977 ; End of function DontWrapAtEOL
code:00000977
code:00000978 ; ---------------------------------------------------------------------------
code:00000978 ; START OF FUNCTION CHUNK FOR ConnectMenu
code:00000978
code:00000978 ClearTTY:                               ; CODE XREF: ConnectMenu+44↓j
code:00000978                                         ; DATA XREF: InterpretESC+1A↑o
code:00000978                 lcall   ClearScreen
code:0000097B
code:0000097B HomeTTY:                                ; CODE XREF: ModifySetting+B6↑p
code:0000097B                                         ; DATA XREF: InterpretESC+1A↑o
code:0000097B                 mov     CursorColumn, #0
code:0000097E                 mov     CursorRow, #1
code:00000981                 ljmp    CalcCursorAddr  ; Updates the CursorAddr pointer using the cursor row and
code:00000981 ; END OF FUNCTION CHUNK FOR ConnectMenu ; column and the line table for calculation.
code:00000981                                         ;
code:00000981                                         ; Does not account for attributes in the row.  This is a
code:00000981                                         ; bug.
code:00000984
code:00000984 ; =============== S U B R O U T I N E =======================================
code:00000984
code:00000984 ; Does not go to next line
code:00000984
code:00000984 CursorRight:                            ; DATA XREF: InterpretESC+1A↑o
code:00000984                 mov     A, CursorColumn
code:00000986                 cjne    A, #79, code_98A
code:00000989                 ret
code:0000098A ; ---------------------------------------------------------------------------
code:0000098A
code:0000098A code_98A:                               ; CODE XREF: CursorRight+2↑j
code:0000098A                 inc     CursorColumn
code:0000098C                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:0000098C ; End of function CursorRight           ; attributes
code:0000098C
code:0000098F
code:0000098F ; =============== S U B R O U T I N E =======================================
code:0000098F
code:0000098F
code:0000098F DecrementDPTR:                          ; CODE XREF: InsertAttribute+7↑p
code:0000098F                                         ; InsertAttribute+14↑p ...
code:0000098F                 clr     A
code:00000990                 cjne    A, DPL, code_995 ; Data Pointer, Low Byte
code:00000993
code:00000993
code:00000993                 dec     DPH             ; Data Pointer, High Byte
code:00000995
code:00000995 code_995:                               ; CODE XREF: DecrementDPTR+1↑j
code:00000995                 dec     DPL             ; Data Pointer, Low Byte
code:00000997                 ret
code:00000997 ; End of function DecrementDPTR
code:00000997
code:00000998
code:00000998 ; =============== S U B R O U T I N E =======================================
code:00000998
code:00000998
code:00000998 CursorUp:                               ; DATA XREF: InterpretESC+1A↑o
code:00000998                 mov     A, CursorRow
code:0000099A                 jz      code_99F
code:0000099C
code:0000099C
code:0000099C                 cjne    A, #1, code_9A0
code:0000099F
code:0000099F code_99F:                               ; CODE XREF: CursorUp+2↑j
code:0000099F                 ret
code:000009A0 ; ---------------------------------------------------------------------------
code:000009A0
code:000009A0 code_9A0:                               ; CODE XREF: CursorUp+4↑j
code:000009A0                 dec     CursorRow
code:000009A2                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000009A2 ; End of function CursorUp              ; attributes
code:000009A2
code:000009A5
code:000009A5 ; =============== S U B R O U T I N E =======================================
code:000009A5
code:000009A5
code:000009A5 CursorDown:                             ; DATA XREF: InterpretESC+1A↑o
code:000009A5                 mov     A, CursorRow
code:000009A7                 jz      code_9AC
code:000009A9
code:000009A9
code:000009A9                 cjne    A, #24, code_9AD
code:000009AC
code:000009AC code_9AC:                               ; CODE XREF: CursorDown+2↑j
code:000009AC                 ret
code:000009AD ; ---------------------------------------------------------------------------
code:000009AD
code:000009AD code_9AD:                               ; CODE XREF: CursorDown+4↑j
code:000009AD                 inc     CursorRow
code:000009AF                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000009AF ; End of function CursorDown            ; attributes
code:000009AF
code:000009B2
code:000009B2 ; =============== S U B R O U T I N E =======================================
code:000009B2
code:000009B2
code:000009B2 EnterReadCursorPosMode:                 ; DATA XREF: InterpretESC+1A↑o
code:000009B2                 mov     ContextFunctionPtr+1, #(ReadRowChar & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009B5                 mov     ContextFunctionPtr, #(ReadRowChar >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009B8                 ret
code:000009B8 ; End of function EnterReadCursorPosMode
code:000009B8
code:000009B9
code:000009B9 ; =============== S U B R O U T I N E =======================================
code:000009B9
code:000009B9
code:000009B9 ReadRowChar:                            ; DATA XREF: EnterReadCursorPosMode↑o
code:000009B9                                         ; EnterReadCursorPosMode+3↑o
code:000009B9                 mov     ContextFunctionPtr+1, #(ReadColChar & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009BC                 mov     ContextFunctionPtr, #(ReadColChar >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009BF
code:000009BF
code:000009BF                 clr     C
code:000009C0                 subb    A, #0x1F
code:000009C2                 jc      Done
code:000009C4
code:000009C4
code:000009C4                 cjne    A, #25, code_9D5 ; Row numbers are ascii characters from 0x21 to 0x38
code:000009C7
code:000009C7
code:000009C7                 clr     A               ; If so, clear it
code:000009C8
code:000009C8 code_9C8:                               ; CODE XREF: ReadRowChar:code_9D5↓j
code:000009C8                 jnz     SetCursorRow
code:000009CA
code:000009CA
code:000009CA                 jnb     PrinterStatus.4, Done ; Bit 0 = Printer
code:000009CA                                         ; Bit 1 = Need to send XOFF
code:000009CA                                         ; Bit 2 = Toggle printer state
code:000009CA                                         ; Bit 3 = No writes to status line
code:000009CA                                         ;         No update of time or print status.  Set cursor position ESC
code:000009CA                                         ;         code cannot set cursor to row 1
code:000009CA                                         ; Bit 4 = No writes to status line
code:000009CA                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000009CA                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000009CA                                         ;         position to row 1
code:000009CA                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000009CA                                         ; Bit 6 = Key pressed
code:000009CA                                         ; Bit 7 = Repeat eligible
code:000009CD                 jb      PrinterStatus.3, Done ; Bit 0 = Printer
code:000009CD                                         ; Bit 1 = Need to send XOFF
code:000009CD                                         ; Bit 2 = Toggle printer state
code:000009CD                                         ; Bit 3 = No writes to status line
code:000009CD                                         ;         No update of time or print status.  Set cursor position ESC
code:000009CD                                         ;         code cannot set cursor to row 1
code:000009CD                                         ; Bit 4 = No writes to status line
code:000009CD                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:000009CD                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:000009CD                                         ;         position to row 1
code:000009CD                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:000009CD                                         ; Bit 6 = Key pressed
code:000009CD                                         ; Bit 7 = Repeat eligible
code:000009D0
code:000009D0 SetCursorRow:                           ; CODE XREF: ReadRowChar:code_9C8↑j
code:000009D0                 mov     CursorRow, A
code:000009D2                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000009D2                                         ; attributes
code:000009D5 ; ---------------------------------------------------------------------------
code:000009D5
code:000009D5 code_9D5:                               ; CODE XREF: ReadRowChar+B↑j
code:000009D5                 jc      code_9C8        ; 7 down to space: Use it
code:000009D7
code:000009D7 Done:                                   ; CODE XREF: ReadRowChar+9↑j
code:000009D7                                         ; ReadRowChar+11↑j ...
code:000009D7                 ret
code:000009D7 ; End of function ReadRowChar
code:000009D7
code:000009D8
code:000009D8 ; =============== S U B R O U T I N E =======================================
code:000009D8
code:000009D8
code:000009D8 ReadColChar:                            ; DATA XREF: ReadRowChar↑o
code:000009D8                                         ; ReadRowChar+3↑o
code:000009D8                 lcall   SetNormalInputMode
code:000009DB
code:000009DB
code:000009DB                 clr     C
code:000009DC                 subb    A, #0x20
code:000009DE                 jc      code_9E5
code:000009E0
code:000009E0
code:000009E0                 cjne    A, #80, code_9E3
code:000009E3
code:000009E3 code_9E3:                               ; CODE XREF: ReadColChar+8↑j
code:000009E3                 jc      code_9E7
code:000009E5
code:000009E5 code_9E5:                               ; CODE XREF: ReadColChar+6↑j
code:000009E5                 mov     A, #79
code:000009E7
code:000009E7 code_9E7:                               ; CODE XREF: ReadColChar:code_9E3↑j
code:000009E7                 mov     CursorColumn, A
code:000009E9                 ljmp    CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000009E9 ; End of function ReadColChar           ; attributes
code:000009E9
code:000009EC
code:000009EC ; =============== S U B R O U T I N E =======================================
code:000009EC
code:000009EC
code:000009EC EnterSetBaudRateMode:                   ; DATA XREF: InterpretESC+1A↑o
code:000009EC                 mov     ContextFunctionPtr+1, #(SetBaudRate & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009EF                 mov     ContextFunctionPtr, #(SetBaudRate >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000009F2                 ret
code:000009F2 ; End of function EnterSetBaudRateMode
code:000009F2
code:000009F3
code:000009F3 ; =============== S U B R O U T I N E =======================================
code:000009F3
code:000009F3
code:000009F3 SetBaudRate:                            ; DATA XREF: EnterSetBaudRateMode↑o
code:000009F3                                         ; EnterSetBaudRateMode+3↑o
code:000009F3                 lcall   SetNormalInputMode
code:000009F6
code:000009F6
code:000009F6                 acall   LookupBaudDivisor ; A = given character, A,B,C,D,E,H,J,Z.  J first checks if
code:000009F6                                         ;     double baud rate is available
code:000009F6                                         ;
code:000009F6                                         ; Expects to be called with register bank 0
code:000009F8                 jc      ReturnGate_5
code:000009F8 ; End of function SetBaudRate
code:000009F8
code:000009FA
code:000009FA ; =============== S U B R O U T I N E =======================================
code:000009FA
code:000009FA ; A = baud rate divisor
code:000009FA
code:000009FA ProgramBaud:                            ; CODE XREF: RESET_0+37↑p
code:000009FA                 clr     TR1             ; Timer 0/1 Control Register
code:000009FC
code:000009FC
code:000009FC                 mov     TMOD, #0x21     ; Timer 1 = 8-bit auto-reload
code:000009FC                                         ; Timer 0 = 16-bit
code:000009FF                 mov     SCON, #0x52     ; 8-bit UART, enable reception
code:00000A02                 mov     TH1, A          ; Timer 1, High Byte
code:00000A04
code:00000A04
code:00000A04                 setb    TR1             ; Timer 0/1 Control Register
code:00000A06
code:00000A06 ReturnGate_5:                           ; CODE XREF: SetBaudRate+5↑j
code:00000A06                 ret
code:00000A06 ; End of function ProgramBaud
code:00000A06
code:00000A07
code:00000A07 ; =============== S U B R O U T I N E =======================================
code:00000A07
code:00000A07 ; A = given character, A,B,C,D,E,H,J,Z.  J first checks if
code:00000A07 ;     double baud rate is available
code:00000A07 ;
code:00000A07 ; Expects to be called with register bank 0
code:00000A07
code:00000A07 LookupBaudDivisor:                      ; CODE XREF: SetBaudRate+3↑p
code:00000A07                 mov     R1, A
code:00000A08                 mov     PCON, #0        ; Power Control Register
code:00000A0B                 cjne    A, #'J, code_A1B
code:00000A0E
code:00000A0E
code:00000A0E                 mov     A, PCON         ; Power Control Register
code:00000A10                 jb      ACC7, code_A2D  ; Accumulator
code:00000A13
code:00000A13
code:00000A13                 mov     PCON, #0x80     ; Power Control Register
code:00000A16                 mov     A, PCON         ; Power Control Register
code:00000A18                 jnb     ACC7, code_A2D  ; Accumulator
code:00000A1B
code:00000A1B code_A1B:                               ; CODE XREF: LookupBaudDivisor+4↑j
code:00000A1B                 mov     DPTR, #code_A2F
code:00000A1E                 mov     R0, #8
code:00000A20
code:00000A20 code_A20:                               ; CODE XREF: LookupBaudDivisor+24↓j
code:00000A20                 clr     A
code:00000A21                 movc    A, @A+DPTR
code:00000A22                 inc     DPTR
code:00000A23                 cjne    A, B0R1, code_A2A
code:00000A26
code:00000A26
code:00000A26                 clr     A
code:00000A27                 movc    A, @A+DPTR
code:00000A28                 clr     C
code:00000A29                 ret
code:00000A2A ; ---------------------------------------------------------------------------
code:00000A2A
code:00000A2A code_A2A:                               ; CODE XREF: LookupBaudDivisor+1C↑j
code:00000A2A                 inc     DPTR
code:00000A2B                 djnz    R0, code_A20
code:00000A2D
code:00000A2D code_A2D:                               ; CODE XREF: LookupBaudDivisor+9↑j
code:00000A2D                                         ; LookupBaudDivisor+11↑j
code:00000A2D                 setb    C
code:00000A2E                 ret
code:00000A2E ; End of function LookupBaudDivisor
code:00000A2E
code:00000A2E ; ---------------------------------------------------------------------------
code:00000A2F code_A2F:       .byte 'A                ; DATA XREF: LookupBaudDivisor:code_A1B↑o
code:00000A30                 .byte 103               ; 110 baud
code:00000A31                 .byte 'B
code:00000A32                 .byte 144               ; 150 baud
code:00000A33                 .byte 'C
code:00000A34                 .byte 200               ; 300 baud
code:00000A35                 .byte 'D
code:00000A36                 .byte 228               ; 600 baud
code:00000A37                 .byte 'E
code:00000A38                 .byte 242               ; 1200 baud
code:00000A39                 .byte 'H
code:00000A3A                 .byte 249               ; 2400 baud
code:00000A3B                 .byte 'J
code:00000A3C                 .byte 249               ; 4800 baud
code:00000A3D                 .byte 'Z
code:00000A3E                 .byte 255               ; 16800 baud
code:00000A3F
code:00000A3F ; =============== S U B R O U T I N E =======================================
code:00000A3F
code:00000A3F ; DPTR = Source
code:00000A3F ; R1:R0 = Destination
code:00000A3F ; B = length
code:00000A3F
code:00000A3F CopyBuffer:                             ; CODE XREF: SaveDirectoryEntry+F↓p
code:00000A3F                                         ; InputFormLine+2D↓p
code:00000A3F                 inc     B               ; B-Register
code:00000A41
code:00000A41 CopyLoop:                               ; CODE XREF: CopyBuffer+B↓j
code:00000A41                 djnz    B, CopyAChar    ; B-Register
code:00000A44                 ret
code:00000A45 ; ---------------------------------------------------------------------------
code:00000A45
code:00000A45 CopyAChar:                              ; CODE XREF: CopyBuffer:CopyLoop↑j
code:00000A45                 movx    A, @DPTR
code:00000A46                 inc     DPTR
code:00000A47                 lcall   PrintCharToVRAM ; R1:R0 = destination
code:00000A47                                         ; A = character
code:00000A47                                         ;
code:00000A47                                         ; Auto-increments R1:R0
code:00000A4A                 sjmp    CopyLoop
code:00000A4A ; End of function CopyBuffer
code:00000A4A
code:00000A4C
code:00000A4C ; =============== S U B R O U T I N E =======================================
code:00000A4C
code:00000A4C ; Source = DPTR
code:00000A4C ; Dest = R1:R0
code:00000A4C
code:00000A4C CStringCopy:                            ; CODE XREF: CStringCopy+8↓j
code:00000A4C                                         ; ManualDial+1D↓p ...
code:00000A4C                 movx    A, @DPTR
code:00000A4D                 jnz     code_A50
code:00000A4F
code:00000A4F
code:00000A4F                 ret
code:00000A50 ; ---------------------------------------------------------------------------
code:00000A50
code:00000A50 code_A50:                               ; CODE XREF: CStringCopy+1↑j
code:00000A50                 inc     DPTR
code:00000A51                 lcall   PrintCharToVRAM ; R1:R0 = destination
code:00000A51                                         ; A = character
code:00000A51                                         ;
code:00000A51                                         ; Auto-increments R1:R0
code:00000A54                 ajmp    CStringCopy     ; Source = DPTR
code:00000A54 ; End of function CStringCopy           ; Dest = R1:R0
code:00000A54
code:00000A56
code:00000A56 ; =============== S U B R O U T I N E =======================================
code:00000A56
code:00000A56
code:00000A56 UpdateStatusLine:                       ; CODE XREF: TerminalLoop+37↓p
code:00000A56                                         ; TerminalLoop+4C↓p ...
code:00000A56                 jb      PrinterStatus.3, ReturnGate ; Bit 0 = Printer
code:00000A56                                         ; Bit 1 = Need to send XOFF
code:00000A56                                         ; Bit 2 = Toggle printer state
code:00000A56                                         ; Bit 3 = No writes to status line
code:00000A56                                         ;         No update of time or print status.  Set cursor position ESC
code:00000A56                                         ;         code cannot set cursor to row 1
code:00000A56                                         ; Bit 4 = No writes to status line
code:00000A56                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000A56                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000A56                                         ;         position to row 1
code:00000A56                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000A56                                         ; Bit 6 = Key pressed
code:00000A56                                         ; Bit 7 = Repeat eligible
code:00000A59
code:00000A59
code:00000A59                 jb      PrinterStatus.4, ReturnGate ; Bit 0 = Printer
code:00000A59                                         ; Bit 1 = Need to send XOFF
code:00000A59                                         ; Bit 2 = Toggle printer state
code:00000A59                                         ; Bit 3 = No writes to status line
code:00000A59                                         ;         No update of time or print status.  Set cursor position ESC
code:00000A59                                         ;         code cannot set cursor to row 1
code:00000A59                                         ; Bit 4 = No writes to status line
code:00000A59                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000A59                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000A59                                         ;         position to row 1
code:00000A59                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000A59                                         ; Bit 6 = Key pressed
code:00000A59                                         ; Bit 7 = Repeat eligible
code:00000A5C
code:00000A5C
code:00000A5C                 jb      VideoSettings.0, Online ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000A5C                                         ; Bit 1 = Receive buffer is full
code:00000A5C                                         ; Bit 3 = Serial send register busy
code:00000A5C                                         ; Bit 4 = Busy drawing to screen
code:00000A5C                                         ; Bit 5 = Steady/Blink
code:00000A5C                                         ; Bit 6 = Disable keyboard
code:00000A5C                                         ; Bit 7 = Standard/Graphics
code:00000A5F
code:00000A5F ;
code:00000A5F ; OFFLINE.  See if we've acknowledged that
code:00000A5F ;
code:00000A5F                 jb      TimerStatus.2, StatusChange ; Bit 0 = ESC is tracked as pressed
code:00000A5F                                         ; Bit 1 = BREAK is tracked as pressed
code:00000A5F                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000A5F                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000A5F                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000A5F                                         ;         handler uses this to look for timeouts in each state.
code:00000A5F                                         ; Bit 4 = Use immediate dial buffer
code:00000A5F                                         ; Bit 5 = Dial voice
code:00000A5F                                         ; Bit 6 = Disabling/Enabling a setting
code:00000A5F                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000A62
code:00000A62 ReturnGate:                             ; CODE XREF: UpdateStatusLine↑j
code:00000A62                                         ; UpdateStatusLine+3↑j ...
code:00000A62                 ret
code:00000A63 ; ---------------------------------------------------------------------------
code:00000A63
code:00000A63 Online:                                 ; CODE XREF: UpdateStatusLine+6↑j
code:00000A63                 jb      TimerStatus.2, ReturnGate ; Bit 0 = ESC is tracked as pressed
code:00000A63                                         ; Bit 1 = BREAK is tracked as pressed
code:00000A63                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000A63                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000A63                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000A63                                         ;         handler uses this to look for timeouts in each state.
code:00000A63                                         ; Bit 4 = Use immediate dial buffer
code:00000A63                                         ; Bit 5 = Dial voice
code:00000A63                                         ; Bit 6 = Disabling/Enabling a setting
code:00000A63                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000A66
code:00000A66 StatusChange:                           ; CODE XREF: UpdateStatusLine+9↑j
code:00000A66                 cpl     TimerStatus.2   ; Bit 0 = ESC is tracked as pressed
code:00000A66                                         ; Bit 1 = BREAK is tracked as pressed
code:00000A66                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000A66                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000A66                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000A66                                         ;         handler uses this to look for timeouts in each state.
code:00000A66                                         ; Bit 4 = Use immediate dial buffer
code:00000A66                                         ; Bit 5 = Dial voice
code:00000A66                                         ; Bit 6 = Disabling/Enabling a setting
code:00000A66                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000A68                 lcall   ClearTopLine
code:00000A6B
code:00000A6B ;
code:00000A6B ; Status change noticed and top line cleared.  Now write
code:00000A6B ; appropriate status
code:00000A6B ;
code:00000A6B                 jb      VideoSettings.0, PrintOnlineTopLine ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000A6B                                         ; Bit 1 = Receive buffer is full
code:00000A6B                                         ; Bit 3 = Serial send register busy
code:00000A6B                                         ; Bit 4 = Busy drawing to screen
code:00000A6B                                         ; Bit 5 = Steady/Blink
code:00000A6B                                         ; Bit 6 = Disable keyboard
code:00000A6B                                         ; Bit 7 = Standard/Graphics
code:00000A6E                 jb      PrinterStatus.5, PressQUIT ; Bit 0 = Printer
code:00000A6E                                         ; Bit 1 = Need to send XOFF
code:00000A6E                                         ; Bit 2 = Toggle printer state
code:00000A6E                                         ; Bit 3 = No writes to status line
code:00000A6E                                         ;         No update of time or print status.  Set cursor position ESC
code:00000A6E                                         ;         code cannot set cursor to row 1
code:00000A6E                                         ; Bit 4 = No writes to status line
code:00000A6E                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000A6E                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000A6E                                         ;         position to row 1
code:00000A6E                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000A6E                                         ; Bit 6 = Key pressed
code:00000A6E                                         ; Bit 7 = Repeat eligible
code:00000A71
code:00000A71
code:00000A71                 mov     DPTR, #aPressHelp ; "Press HELP"
code:00000A74                 ajmp    PrintOfflineTopLine
code:00000A76 ; ---------------------------------------------------------------------------
code:00000A76
code:00000A76 PressQUIT:                              ; CODE XREF: UpdateStatusLine+18↑j
code:00000A76                 mov     DPTR, #aPressQuitToExi ; "Press QUIT to exit"
code:00000A79
code:00000A79 PrintOfflineTopLine:                    ; CODE XREF: UpdateStatusLine+1E↑j
code:00000A79                 mov     R0, #((VideoLine1 - RESET) & 0xFF) ; RESET
code:00000A7B                 mov     R1, #((VideoLine1 - RESET) >> 8) ; RESET
code:00000A7D                 lcall   PrintCStringToVRAMEntry ; R1:R0 = destination
code:00000A7D                                         ; DPTR = source
code:00000A7D                                         ;
code:00000A7D                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00000A80
code:00000A80
code:00000A80                 mov     DPTR, #aOFFLINE
code:00000A83                 ajmp    WriteTerminalOnlineStatus
code:00000A85 ; ---------------------------------------------------------------------------
code:00000A85
code:00000A85 PrintOnlineTopLine:                     ; CODE XREF: UpdateStatusLine+15↑j
code:00000A85                 mov     DPTR, #aONLINE
code:00000A88
code:00000A88 WriteTerminalOnlineStatus:              ; CODE XREF: UpdateStatusLine+2D↑j
code:00000A88                                         ; PerformState+F4↓j ...
code:00000A88                 mov     R0, #(ModemStatusText & 0xFF)
code:00000A8A                 mov     R1, #(ModemStatusText >> 8)
code:00000A8C                 lcall   PrintCStringToVRAMEntry ; R1:R0 = destination
code:00000A8C                                         ; DPTR = source
code:00000A8C                                         ;
code:00000A8C                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00000A8F
code:00000A8F
code:00000A8F                 mov     A, SerialSelection ; This is a character representing the routing selection for
code:00000A8F                                         ; serial data.
code:00000A8F                                         ;   <SPC> = MCU -> MODEM
code:00000A8F                                         ;   1 = MCU -> RS232 (power plug)
code:00000A8F                                         ;   2 = MCU -> MODEM with the DE9 listening to the modem
code:00000A8F                                         ;   3 = MODEM -> DE9 with MCU listening to the modem
code:00000A91                 lcall   WriteUnusedNumberToScreen
code:00000A94
code:00000A94
code:00000A94                 lcall   ForceWritePrintStatus ; Does not check for presence of the status line
code:00000A97
code:00000A97
code:00000A97                 jb      SerialSettings.0, ReturnGate ; Bit 0 = Clock display off
code:00000A97                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000A97                                         ; Bit 2 = Half/Full duplex
code:00000A97                                         ; Bit 3 = Auto Repeat disable
code:00000A97                                         ; Bit 4 = Key click disable
code:00000A97                                         ; Bit 5 = LF->CRLF
code:00000A97                                         ; Bit 6 = CR->CRLF
code:00000A97                                         ; Bit 7 = Wrap at EOL off
code:00000A9A
code:00000A9A
code:00000A9A                 ljmp    WriteTime       ; Writes the digits specified in RAM location 54 to upper right line on the screen
code:00000A9A ; End of function UpdateStatusLine
code:00000A9A
code:00000A9D
code:00000A9D ; =============== S U B R O U T I N E =======================================
code:00000A9D
code:00000A9D
code:00000A9D CheckKeyboard:                          ; CODE XREF: IE1+49↑p
code:00000A9D                 clr     PrinterStatus.6 ; Bit 0 = Printer
code:00000A9D                                         ; Bit 1 = Need to send XOFF
code:00000A9D                                         ; Bit 2 = Toggle printer state
code:00000A9D                                         ; Bit 3 = No writes to status line
code:00000A9D                                         ;         No update of time or print status.  Set cursor position ESC
code:00000A9D                                         ;         code cannot set cursor to row 1
code:00000A9D                                         ; Bit 4 = No writes to status line
code:00000A9D                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000A9D                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000A9D                                         ;         position to row 1
code:00000A9D                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000A9D                                         ; Bit 6 = Key pressed
code:00000A9D                                         ; Bit 7 = Repeat eligible
code:00000A9F                 setb    PrinterStatus.7 ; Bit 0 = Printer
code:00000A9F                                         ; Bit 1 = Need to send XOFF
code:00000A9F                                         ; Bit 2 = Toggle printer state
code:00000A9F                                         ; Bit 3 = No writes to status line
code:00000A9F                                         ;         No update of time or print status.  Set cursor position ESC
code:00000A9F                                         ;         code cannot set cursor to row 1
code:00000A9F                                         ; Bit 4 = No writes to status line
code:00000A9F                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000A9F                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000A9F                                         ;         position to row 1
code:00000A9F                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000A9F                                         ; Bit 6 = Key pressed
code:00000A9F                                         ; Bit 7 = Repeat eligible
code:00000AA1
code:00000AA1
code:00000AA1                 mov     R0, #KeyboardGrid
code:00000AA3                 mov     DPTR, #PressedKeys ; This is an array of 8x8 bits representing each key on the
code:00000AA3                                         ; keyboard.  The system scans from 0 to 8 and marks down
code:00000AA3                                         ; each key it finds turned on.  This helps to keep track
code:00000AA3                                         ; of which keys were last pressed.
code:00000AA6
code:00000AA6 ;
code:00000AA6 ; Read memory locations 0-7 looking for a key code
code:00000AA6 ;
code:00000AA6                 mov     R4, #8
code:00000AA8
code:00000AA8 ReadKeyboardLoop:                       ; CODE XREF: CheckKeyboard+5A↓j
code:00000AA8                 mov     P2, #(KeyboardGrid >> 8) ; Port 2
code:00000AAB                 movx    A, @R0          ; Read address 0000 (keyboard?)
code:00000AAC                 jz      NoKeyCode
code:00000AAE
code:00000AAE
code:00000AAE                 setb    PrinterStatus.6 ; Bit 0 = Printer
code:00000AAE                                         ; Bit 1 = Need to send XOFF
code:00000AAE                                         ; Bit 2 = Toggle printer state
code:00000AAE                                         ; Bit 3 = No writes to status line
code:00000AAE                                         ;         No update of time or print status.  Set cursor position ESC
code:00000AAE                                         ;         code cannot set cursor to row 1
code:00000AAE                                         ; Bit 4 = No writes to status line
code:00000AAE                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000AAE                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000AAE                                         ;         position to row 1
code:00000AAE                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000AAE                                         ; Bit 6 = Key pressed
code:00000AAE                                         ; Bit 7 = Repeat eligible
code:00000AB0
code:00000AB0
code:00000AB0                 mov     R6, A
code:00000AB1
code:00000AB1
code:00000AB1                 mov     P2, #(KeyboardShift >> 8) ; Port 2
code:00000AB4                 movx    A, @R0          ; Read address 1000 (shift keys)
code:00000AB5                 mov     ShiftStatus, A  ; Bit 0 = ESC
code:00000AB5                                         ; Bit 1 = CAPS lock
code:00000AB5                                         ; Bit 2 = Ctrl key
code:00000AB5                                         ; Bit 3 = SHIFT key
code:00000AB7
code:00000AB7
code:00000AB7                 movx    A, @DPTR        ; Mask out already existing bits from this row
code:00000AB8                 mov     R7, A
code:00000AB9                 orl     A, R6
code:00000ABA                 xrl     A, R7
code:00000ABB                 jz      SameBits
code:00000ABD
code:00000ABD ;
code:00000ABD ; The inner loop for scanning each newly active bit for a
code:00000ABD ; pressed key
code:00000ABD                 clr     PrinterStatus.7 ; Bit 0 = Printer
code:00000ABD                                         ; Bit 1 = Need to send XOFF
code:00000ABD                                         ; Bit 2 = Toggle printer state
code:00000ABD                                         ; Bit 3 = No writes to status line
code:00000ABD                                         ;         No update of time or print status.  Set cursor position ESC
code:00000ABD                                         ;         code cannot set cursor to row 1
code:00000ABD                                         ; Bit 4 = No writes to status line
code:00000ABD                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000ABD                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000ABD                                         ;         position to row 1
code:00000ABD                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000ABD                                         ; Bit 6 = Key pressed
code:00000ABD                                         ; Bit 7 = Repeat eligible
code:00000ABF                 mov     R5, #8
code:00000AC1
code:00000AC1 ScanRowLoop:                            ; CODE XREF: CheckKeyboard+54↓j
code:00000AC1                 jnb     ACC0, ScanRowNextBit ; Accumulator
code:00000AC4
code:00000AC4
code:00000AC4                 mov     SavedKeyRowValue, A
code:00000AC6
code:00000AC6 ;
code:00000AC6 ; Get the scan code:  Row * 8 + Column.  Note that column
code:00000AC6 ; starts at 8 and counts down to 1.  This makes it easier
code:00000AC6 ; for the translate function because it doesn't have to
code:00000AC6 ; add 1 to skip the RET instruction.
code:00000AC6                 mov     A, R0
code:00000AC7                 mov     B, #8           ; B-Register
code:00000ACA                 mul     AB
code:00000ACB                 add     A, R5
code:00000ACC
code:00000ACC
code:00000ACC                 jnb     ShiftStatus.3, NotShifted ; Bit 0 = ESC
code:00000ACC                                         ; Bit 1 = CAPS lock
code:00000ACC                                         ; Bit 2 = Ctrl key
code:00000ACC                                         ; Bit 3 = SHIFT key
code:00000ACF
code:00000ACF
code:00000ACF                 acall   TranslateShifted
code:00000AD1                 ajmp    CheckForCapsLock
code:00000AD3 ; ---------------------------------------------------------------------------
code:00000AD3
code:00000AD3 NotShifted:                             ; CODE XREF: CheckKeyboard+2F↑j
code:00000AD3                 acall   TranslateUnshifted
code:00000AD5
code:00000AD5 CheckForCapsLock:                       ; CODE XREF: CheckKeyboard+34↑j
code:00000AD5                 jnb     ShiftStatus.1, CheckForCtrl ; Bit 0 = ESC
code:00000AD5                                         ; Bit 1 = CAPS lock
code:00000AD5                                         ; Bit 2 = Ctrl key
code:00000AD5                                         ; Bit 3 = SHIFT key
code:00000AD8
code:00000AD8
code:00000AD8                 acall   Capitalize      ; Translates lower-case letters to upper-case.
code:00000AD8                                         ;
code:00000AD8                                         ; A = old value
code:00000AD8                                         ;
code:00000AD8                                         ; On return:
code:00000AD8                                         ;
code:00000AD8                                         ; C = untranslated
code:00000AD8                                         ; A = new value
code:00000ADA
code:00000ADA CheckForCtrl:                           ; CODE XREF: CheckKeyboard:CheckForCapsLock↑j
code:00000ADA                 jnb     ShiftStatus.2, CodeConverted ; Bit 0 = ESC
code:00000ADA                                         ; Bit 1 = CAPS lock
code:00000ADA                                         ; Bit 2 = Ctrl key
code:00000ADA                                         ; Bit 3 = SHIFT key
code:00000ADD                 acall   ConvertControl  ; Gets the control equivalent of a key in the range of a-z and some symbols.  Converts to uppercase before checking
code:00000ADD                                         ;
code:00000ADD                                         ; If A is in the range of 0x40-0x5F, subtract 0x40.
code:00000ADD                                         ;
code:00000ADD                                         ; If A is between 0x7f and 0x91, add 9
code:00000ADF
code:00000ADF CodeConverted:                          ; CODE XREF: CheckKeyboard:CheckForCtrl↑j
code:00000ADF                 mov     PressedKeyCode, A
code:00000AE1
code:00000AE1
code:00000AE1                 mov     RepeatCountDown, #34
code:00000AE4
code:00000AE4
code:00000AE4                 push    DPL             ; Data Pointer, Low Byte
code:00000AE6                 push    DPH             ; Data Pointer, High Byte
code:00000AE8                 acall   SaveAndSendKey  ; A = keycode
code:00000AEA                 pop     DPH             ; Data Pointer, High Byte
code:00000AEC                 pop     DPL             ; Data Pointer, Low Byte
code:00000AEE
code:00000AEE
code:00000AEE                 mov     A, SavedKeyRowValue
code:00000AF0
code:00000AF0 ScanRowNextBit:                         ; CODE XREF: CheckKeyboard:ScanRowLoop↑j
code:00000AF0                 rr      A
code:00000AF1                 djnz    R5, ScanRowLoop
code:00000AF3
code:00000AF3 SameBits:                               ; CODE XREF: CheckKeyboard+1E↑j
code:00000AF3                 mov     A, R6
code:00000AF4
code:00000AF4 NoKeyCode:                              ; CODE XREF: CheckKeyboard+F↑j
code:00000AF4                 movx    @DPTR, A        ; Store bitmap of pressed keys for row
code:00000AF5
code:00000AF5
code:00000AF5                 inc     R0
code:00000AF6                 inc     DPTR
code:00000AF7                 djnz    R4, ReadKeyboardLoop
code:00000AF9
code:00000AF9 ;
code:00000AF9 ; Done scanning.  Any keys held down?
code:00000AF9 ;
code:00000AF9                 jb      PrinterStatus.6, CheckForRepeatDelay ; Bit 0 = Printer
code:00000AF9                                         ; Bit 1 = Need to send XOFF
code:00000AF9                                         ; Bit 2 = Toggle printer state
code:00000AF9                                         ; Bit 3 = No writes to status line
code:00000AF9                                         ;         No update of time or print status.  Set cursor position ESC
code:00000AF9                                         ;         code cannot set cursor to row 1
code:00000AF9                                         ; Bit 4 = No writes to status line
code:00000AF9                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000AF9                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000AF9                                         ;         position to row 1
code:00000AF9                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000AF9                                         ; Bit 6 = Key pressed
code:00000AF9                                         ; Bit 7 = Repeat eligible
code:00000AFC
code:00000AFC ProcessESCKey:                          ; CODE XREF: CheckKeyboard:CheckForRepeatDelay↓j
code:00000AFC                                         ; CheckKeyboard+8F↓j ...
code:00000AFC                 mov     P2, #(KeyboardShift >> 8) ; Port 2
code:00000AFF                 movx    A, @R0
code:00000B00                 jnb     ACC0, ClearESC  ; ESC not pressed.  Done.
code:00000B03
code:00000B03
code:00000B03                 jb      TimerStatus.0, Done2 ; ESC already tracked as pressed.  Done.
code:00000B06
code:00000B06
code:00000B06                 jnb     ACC2, NotCTRLEsc ; Accumulator
code:00000B09
code:00000B09 ;
code:00000B09 ; Process Ctrl+ESC (RESET)
code:00000B09 ;
code:00000B09                 clr     RS0             ; Program Status Word Register
code:00000B0B                 acall   RestoreStatusLine
code:00000B0D                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000B0D                                         ; Bit 1 = Receive buffer is full
code:00000B0D                                         ; Bit 3 = Serial send register busy
code:00000B0D                                         ; Bit 4 = Busy drawing to screen
code:00000B0D                                         ; Bit 5 = Steady/Blink
code:00000B0D                                         ; Bit 6 = Disable keyboard
code:00000B0D                                         ; Bit 7 = Standard/Graphics
code:00000B0F                 setb    PrinterStatus.5 ; Bit 0 = Printer
code:00000B0F                                         ; Bit 1 = Need to send XOFF
code:00000B0F                                         ; Bit 2 = Toggle printer state
code:00000B0F                                         ; Bit 3 = No writes to status line
code:00000B0F                                         ;         No update of time or print status.  Set cursor position ESC
code:00000B0F                                         ;         code cannot set cursor to row 1
code:00000B0F                                         ; Bit 4 = No writes to status line
code:00000B0F                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000B0F                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000B0F                                         ;         position to row 1
code:00000B0F                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000B0F                                         ; Bit 6 = Key pressed
code:00000B0F                                         ; Bit 7 = Repeat eligible
code:00000B11                 setb    TimerStatus.0   ; Bit 0 = ESC is tracked as pressed
code:00000B11                                         ; Bit 1 = BREAK is tracked as pressed
code:00000B11                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000B11                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000B11                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000B11                                         ;         handler uses this to look for timeouts in each state.
code:00000B11                                         ; Bit 4 = Use immediate dial buffer
code:00000B11                                         ; Bit 5 = Dial voice
code:00000B11                                         ; Bit 6 = Disabling/Enabling a setting
code:00000B11                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000B13                 setb    RS0             ; Program Status Word Register
code:00000B15
code:00000B15 j_ForceStatusLineUpdate_0:              ; CODE XREF: SaveAndSendKey+B2↓j
code:00000B15                                         ; PerformState+BC↓p ...
code:00000B15                 ljmp    ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:00000B15                                         ; terminal software knows to react to it.  This is called to signal
code:00000B15                                         ; a change, such as when the clock updates.
code:00000B18 ; ---------------------------------------------------------------------------
code:00000B18
code:00000B18 NotCTRLEsc:                             ; CODE XREF: CheckKeyboard+69↑j
code:00000B18                 jb      SerialSettings.4, code_B1E ; Bit 0 = Clock display off
code:00000B18                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000B18                                         ; Bit 2 = Half/Full duplex
code:00000B18                                         ; Bit 3 = Auto Repeat disable
code:00000B18                                         ; Bit 4 = Key click disable
code:00000B18                                         ; Bit 5 = LF->CRLF
code:00000B18                                         ; Bit 6 = CR->CRLF
code:00000B18                                         ; Bit 7 = Wrap at EOL off
code:00000B1B                 mov     BellDurationCounter, #2
code:00000B1E
code:00000B1E code_B1E:                               ; CODE XREF: CheckKeyboard:NotCTRLEsc↑j
code:00000B1E                 mov     A, #0x1B
code:00000B20                 lcall   DispatchTypedValue
code:00000B23
code:00000B23
code:00000B23                 setb    TimerStatus.0   ; Bit 0 = ESC is tracked as pressed
code:00000B23                                         ; Bit 1 = BREAK is tracked as pressed
code:00000B23                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000B23                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000B23                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000B23                                         ;         handler uses this to look for timeouts in each state.
code:00000B23                                         ; Bit 4 = Use immediate dial buffer
code:00000B23                                         ; Bit 5 = Dial voice
code:00000B23                                         ; Bit 6 = Disabling/Enabling a setting
code:00000B23                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000B25
code:00000B25 Done2:                                  ; CODE XREF: CheckKeyboard+66↑j
code:00000B25                 ret
code:00000B26 ; ---------------------------------------------------------------------------
code:00000B26
code:00000B26 ClearESC:                               ; CODE XREF: CheckKeyboard+63↑j
code:00000B26                 clr     TimerStatus.0   ; Bit 0 = ESC is tracked as pressed
code:00000B26                                         ; Bit 1 = BREAK is tracked as pressed
code:00000B26                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000B26                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000B26                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000B26                                         ;         handler uses this to look for timeouts in each state.
code:00000B26                                         ; Bit 4 = Use immediate dial buffer
code:00000B26                                         ; Bit 5 = Dial voice
code:00000B26                                         ; Bit 6 = Disabling/Enabling a setting
code:00000B26                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000B28                 ret
code:00000B29 ; ---------------------------------------------------------------------------
code:00000B29
code:00000B29 CheckForRepeatDelay:                    ; CODE XREF: CheckKeyboard+5C↑j
code:00000B29                 jb      SerialSettings.3, ProcessESCKey ; Check for auto-repeat disable
code:00000B2C
code:00000B2C
code:00000B2C                 jnb     PrinterStatus.7, ProcessESCKey ; Bit 0 = Printer
code:00000B2C                                         ; Bit 1 = Need to send XOFF
code:00000B2C                                         ; Bit 2 = Toggle printer state
code:00000B2C                                         ; Bit 3 = No writes to status line
code:00000B2C                                         ;         No update of time or print status.  Set cursor position ESC
code:00000B2C                                         ;         code cannot set cursor to row 1
code:00000B2C                                         ; Bit 4 = No writes to status line
code:00000B2C                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000B2C                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000B2C                                         ;         position to row 1
code:00000B2C                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000B2C                                         ; Bit 6 = Key pressed
code:00000B2C                                         ; Bit 7 = Repeat eligible
code:00000B2F                 djnz    RepeatCountDown, ProcessESCKey
code:00000B32
code:00000B32 ;
code:00000B32 ; Yay, we repeated a keypress!
code:00000B32 ;
code:00000B32                 mov     RepeatCountDown, #4
code:00000B35                 mov     A, PressedKeyCode
code:00000B37                 acall   SaveAndSendKey  ; A = keycode
code:00000B39                 sjmp    ProcessESCKey
code:00000B39 ; End of function CheckKeyboard
code:00000B39
code:00000B3B ;
code:00000B3B ; Key code table
code:00000B3B ;
code:00000B3B ;    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
code:00000B3B ; 0 !^2  ^A  ^B  ^C  ^D  ^E  ^F  ^G  ^H  ^I  ^J  ^K  ^L  ^M  ^N  ^O
code:00000B3B ; 1  ^P  ^Q  ^R  ^S  ^T  ^U  ^V  ^W  ^X  ^Y  ^Z  ^[  ^\ !^[ !^6 !^-
code:00000B3B ; 2     !1  !'  !3  !4  !5  !7   '  !9  !0  !8  !=   ,   -   .   /
code:00000B3B ; 3  0   1   2   3   4   5   6   7   8   9  !;   ;  !,   =  !.  !/
code:00000B3B ; 4 !2  !a  !b  !c  !d  !e  !f  !g  !h  !i  !j  !k  !l  !m  !n  !o
code:00000B3B ; 5 !p  !q  !r  !s  !t  !u  !v  !w  !x  !y  !z   [   \  ![  !6  !-
code:00000B3B ; 6  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
code:00000B3B ; 7  p   q   r   s   t   u   v   w   x   y   z   {  !\  !{  !`  ^⌫
code:00000B3B ; 8 !↑  !↓  !→  !←   ↑   ↓   →   ←  !^⌫ !^↑ !^↓ !^→ !^← ^↑  ^↓  ^→
code:00000B3B ; 9 ^←   ↠  !↠ QIT
code:00000B3B
code:00000B3B
code:00000B3B ; =============== S U B R O U T I N E =======================================
code:00000B3B
code:00000B3B ; A = keycode
code:00000B3B
code:00000B3B SaveAndSendKey:                         ; CODE XREF: CheckKeyboard+4B↑p
code:00000B3B                                         ; CheckKeyboard+9A↑p
code:00000B3B                 jb      SerialSettings.4, CheckCtrlShiftSpace ; Bit 0 = Clock display off
code:00000B3B                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00000B3B                                         ; Bit 2 = Half/Full duplex
code:00000B3B                                         ; Bit 3 = Auto Repeat disable
code:00000B3B                                         ; Bit 4 = Key click disable
code:00000B3B                                         ; Bit 5 = LF->CRLF
code:00000B3B                                         ; Bit 6 = CR->CRLF
code:00000B3B                                         ; Bit 7 = Wrap at EOL off
code:00000B3E                 mov     BellDurationCounter, #2
code:00000B41
code:00000B41 CheckCtrlShiftSpace:                    ; CODE XREF: SaveAndSendKey↑j
code:00000B41                 cjne    A, #0x20, CheckCtrlShiftP
code:00000B44                 jnb     ShiftStatus.3, CheckCtrlShiftP ; Bit 0 = ESC
code:00000B44                                         ; Bit 1 = CAPS lock
code:00000B44                                         ; Bit 2 = Ctrl key
code:00000B44                                         ; Bit 3 = SHIFT key
code:00000B47                 jnb     ShiftStatus.2, CheckCtrlShiftP ; Bit 0 = ESC
code:00000B47                                         ; Bit 1 = CAPS lock
code:00000B47                                         ; Bit 2 = Ctrl key
code:00000B47                                         ; Bit 3 = SHIFT key
code:00000B4A                 ajmp    ToggleOnlineOffline
code:00000B4C ; ---------------------------------------------------------------------------
code:00000B4C
code:00000B4C CheckCtrlShiftP:                        ; CODE XREF: SaveAndSendKey:CheckCtrlShiftSpace↑j
code:00000B4C                                         ; SaveAndSendKey+9↑j ...
code:00000B4C                 cjne    A, #0x10, CheckActionKey
code:00000B4F
code:00000B4F
code:00000B4F                 jnb     ShiftStatus.3, CheckActionKey ; Bit 0 = ESC
code:00000B4F                                         ; Bit 1 = CAPS lock
code:00000B4F                                         ; Bit 2 = Ctrl key
code:00000B4F                                         ; Bit 3 = SHIFT key
code:00000B52                 jnb     ShiftStatus.2, CheckActionKey ; Bit 0 = ESC
code:00000B52                                         ; Bit 1 = CAPS lock
code:00000B52                                         ; Bit 2 = Ctrl key
code:00000B52                                         ; Bit 3 = SHIFT key
code:00000B55                 setb    PrinterStatus.2 ; Bit 0 = Printer
code:00000B55                                         ; Bit 1 = Need to send XOFF
code:00000B55                                         ; Bit 2 = Toggle printer state
code:00000B55                                         ; Bit 3 = No writes to status line
code:00000B55                                         ;         No update of time or print status.  Set cursor position ESC
code:00000B55                                         ;         code cannot set cursor to row 1
code:00000B55                                         ; Bit 4 = No writes to status line
code:00000B55                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000B55                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000B55                                         ;         position to row 1
code:00000B55                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000B55                                         ; Bit 6 = Key pressed
code:00000B55                                         ; Bit 7 = Repeat eligible
code:00000B57                 ret
code:00000B58 ; ---------------------------------------------------------------------------
code:00000B58
code:00000B58 CheckActionKey:                         ; CODE XREF: SaveAndSendKey:CheckCtrlShiftP↑j
code:00000B58                                         ; SaveAndSendKey+14↑j ...
code:00000B58                 cjne    A, #0x80, code_B5B
code:00000B5B
code:00000B5B code_B5B:                               ; CODE XREF: SaveAndSendKey:CheckActionKey↑j
code:00000B5B                 jnc     TranslateActionKey
code:00000B5D
code:00000B5D
code:00000B5D                 ljmp    DispatchTypedValue
code:00000B60 ; ---------------------------------------------------------------------------
code:00000B60
code:00000B60 TranslateActionKey:                     ; CODE XREF: SaveAndSendKey:code_B5B↑j
code:00000B60                 clr     C
code:00000B61                 subb    A, #0x80
code:00000B63                 cjne    A, #0x14, code_B66
code:00000B66
code:00000B66 code_B66:                               ; CODE XREF: SaveAndSendKey+28↑j
code:00000B66                 jc      code_B69
code:00000B68
code:00000B68
code:00000B68                 ret
code:00000B69 ; ---------------------------------------------------------------------------
code:00000B69
code:00000B69 code_B69:                               ; CODE XREF: SaveAndSendKey:code_B66↑j
code:00000B69                 mov     DPTR, #ActionKeyTable
code:00000B6C                 movc    A, @A+DPTR      ; switch 20 cases
code:00000B6D                 jmp     @A+DPTR         ; switch jump
code:00000B6D ; ---------------------------------------------------------------------------
code:00000B6E ActionKeyTable:                         ; DATA XREF: SaveAndSendKey:code_B69↑o
code:00000B6E                 .byte KeyF1 - 0xB6E     ; jump table for switch statement
code:00000B6E                 .byte KeyF2 - 0xB6E
code:00000B6E                 .byte KeyF3 - 0xB6E
code:00000B6E                 .byte KeyF4 - 0xB6E
code:00000B6E                 .byte KeyUP - 0xB6E
code:00000B6E                 .byte KeyDOWN - 0xB6E
code:00000B6E                 .byte KeyRIGHT - 0xB6E
code:00000B6E                 .byte KeyLEFT - 0xB6E
code:00000B6E                 .byte KeyCtrlShftBksp - 0xB6E
code:00000B6E                 .byte Set___0 - 0xB6E
code:00000B6E                 .byte Set___1 - 0xB6E
code:00000B6E                 .byte Set___2 - 0xB6E
code:00000B6E                 .byte Set___3 - 0xB6E
code:00000B6E                 .byte KeyCtrlUp - 0xB6E
code:00000B6E                 .byte KeyCtrlDn - 0xB6E
code:00000B6E                 .byte KeyCtrlRt - 0xB6E
code:00000B6E                 .byte KeyCtrlLt - 0xB6E
code:00000B6E                 .byte HELPButton - 0xB6E
code:00000B6E                 .byte SendESCBar - 0xB6E
code:00000B6E                 .byte SetBreak - 0xB6E
code:00000B82 ; ---------------------------------------------------------------------------
code:00000B82
code:00000B82 KeyF1:                                  ; CODE XREF: SaveAndSendKey+32↑j
code:00000B82                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B82                 mov     A, #'S          ; jumptable 00000B6D case 0
code:00000B84                 ajmp    SendSimpleESCCode
code:00000B86 ; ---------------------------------------------------------------------------
code:00000B86
code:00000B86 KeyF2:                                  ; CODE XREF: SaveAndSendKey+32↑j
code:00000B86                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B86                 mov     A, #'T          ; jumptable 00000B6D case 1
code:00000B88                 ajmp    SendSimpleESCCode
code:00000B8A ; ---------------------------------------------------------------------------
code:00000B8A
code:00000B8A KeyF3:                                  ; CODE XREF: SaveAndSendKey+32↑j
code:00000B8A                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B8A                 mov     A, #'U          ; jumptable 00000B6D case 2
code:00000B8C                 ajmp    SendSimpleESCCode
code:00000B8E ; ---------------------------------------------------------------------------
code:00000B8E
code:00000B8E KeyF4:                                  ; CODE XREF: SaveAndSendKey+32↑j
code:00000B8E                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B8E                 mov     A, #'V          ; jumptable 00000B6D case 3
code:00000B90                 ajmp    SendSimpleESCCode
code:00000B92 ; ---------------------------------------------------------------------------
code:00000B92
code:00000B92 KeyCtrlUp:                              ; CODE XREF: SaveAndSendKey+32↑j
code:00000B92                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B92                 mov     A, #'W          ; jumptable 00000B6D case 13
code:00000B94                 ajmp    SendSimpleESCCode
code:00000B96 ; ---------------------------------------------------------------------------
code:00000B96
code:00000B96 KeyCtrlDn:                              ; CODE XREF: SaveAndSendKey+32↑j
code:00000B96                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B96                 mov     A, #'P          ; jumptable 00000B6D case 14
code:00000B98                 ajmp    SendSimpleESCCode
code:00000B9A ; ---------------------------------------------------------------------------
code:00000B9A
code:00000B9A KeyCtrlRt:                              ; CODE XREF: SaveAndSendKey+32↑j
code:00000B9A                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B9A                 mov     A, #'Q          ; jumptable 00000B6D case 15
code:00000B9C                 ajmp    SendSimpleESCCode
code:00000B9E ; ---------------------------------------------------------------------------
code:00000B9E
code:00000B9E KeyCtrlLt:                              ; CODE XREF: SaveAndSendKey+32↑j
code:00000B9E                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000B9E                 mov     A, #'R          ; jumptable 00000B6D case 16
code:00000BA0                 ajmp    SendSimpleESCCode
code:00000BA2 ; ---------------------------------------------------------------------------
code:00000BA2
code:00000BA2 KeyCtrlShftBksp:                        ; CODE XREF: SaveAndSendKey+32↑j
code:00000BA2                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BA2                 mov     A, #'H          ; jumptable 00000B6D case 8
code:00000BA4                 ajmp    SendSimpleESCCode
code:00000BA6 ; ---------------------------------------------------------------------------
code:00000BA6
code:00000BA6 Set___0:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BA6                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BA6                 clr     P12             ; Select mode 0:  MCU<->MODEM
code:00000BA8                 clr     P13             ; Port 1
code:00000BAA                 mov     A, #0x20
code:00000BAC
code:00000BAC UpdateSerialSelect:                     ; CODE XREF: SaveAndSendKey+84↓j
code:00000BAC                                         ; SaveAndSendKey+8C↓j ...
code:00000BAC                 mov     SerialSelection, A ; This is a character representing the routing selection for
code:00000BAC                                         ; serial data.
code:00000BAC                                         ;   <SPC> = MCU -> MODEM
code:00000BAC                                         ;   1 = MCU -> RS232 (power plug)
code:00000BAC                                         ;   2 = MCU -> MODEM with the DE9 listening to the modem
code:00000BAC                                         ;   3 = MODEM -> DE9 with MCU listening to the modem
code:00000BAE
code:00000BAE WriteUnusedNumberToScreen:              ; CODE XREF: UpdateStatusLine+3B↑p
code:00000BAE                 jb      PrinterStatus.4, code_BB8 ; This code rolls around looking to become the next robot
code:00000BAE                                         ; mascot in a major scifi franchise.
code:00000BAE                                         ;
code:00000BAE                                         ; Just kidding, it's the function exit.
code:00000BB1                 jb      PrinterStatus.3, code_BB8 ; This code rolls around looking to become the next robot
code:00000BB1                                         ; mascot in a major scifi franchise.
code:00000BB1                                         ;
code:00000BB1                                         ; Just kidding, it's the function exit.
code:00000BB4
code:00000BB4
code:00000BB4                 mov     DPTR, #SerialModeText
code:00000BB7                 movx    @DPTR, A
code:00000BB8
code:00000BB8 code_BB8:                               ; CODE XREF: SaveAndSendKey:WriteUnusedNumberToScreen↑j
code:00000BB8                                         ; SaveAndSendKey+76↑j
code:00000BB8                 ret                     ; This code rolls around looking to become the next robot
code:00000BB8                                         ; mascot in a major scifi franchise.
code:00000BB8                                         ;
code:00000BB8                                         ; Just kidding, it's the function exit.
code:00000BB9 ; ---------------------------------------------------------------------------
code:00000BB9
code:00000BB9 Set___1:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BB9                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BB9                 setb    P12             ; jumptable 00000B6D case 10
code:00000BBB                 clr     P13             ; Port 1
code:00000BBD                 mov     A, #'1
code:00000BBF                 ajmp    UpdateSerialSelect
code:00000BC1 ; ---------------------------------------------------------------------------
code:00000BC1
code:00000BC1 Set___2:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BC1                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BC1                 clr     P12             ; jumptable 00000B6D case 11
code:00000BC3                 setb    P13             ; Port 1
code:00000BC5                 mov     A, #'2
code:00000BC7                 ajmp    UpdateSerialSelect
code:00000BC9 ; ---------------------------------------------------------------------------
code:00000BC9
code:00000BC9 Set___3:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BC9                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BC9                 setb    P12             ; jumptable 00000B6D case 12
code:00000BCB                 setb    P13             ; Port 1
code:00000BCD                 mov     A, #'3
code:00000BCF                 ajmp    UpdateSerialSelect
code:00000BD1 ; ---------------------------------------------------------------------------
code:00000BD1
code:00000BD1 KeyUP:                                  ; CODE XREF: SaveAndSendKey+32↑j
code:00000BD1                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BD1                 mov     A, #'A          ; jumptable 00000B6D case 4
code:00000BD3                 ajmp    SendSimpleESCCode
code:00000BD5 ; ---------------------------------------------------------------------------
code:00000BD5
code:00000BD5 KeyDOWN:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BD5                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BD5                 mov     A, #'B          ; jumptable 00000B6D case 5
code:00000BD7                 ajmp    SendSimpleESCCode
code:00000BD9 ; ---------------------------------------------------------------------------
code:00000BD9
code:00000BD9 KeyRIGHT:                               ; CODE XREF: SaveAndSendKey+32↑j
code:00000BD9                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BD9                 mov     A, #'C          ; jumptable 00000B6D case 6
code:00000BDB                 ajmp    SendSimpleESCCode
code:00000BDD ; ---------------------------------------------------------------------------
code:00000BDD
code:00000BDD KeyLEFT:                                ; CODE XREF: SaveAndSendKey+32↑j
code:00000BDD                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BDD                 mov     A, #'D          ; jumptable 00000B6D case 7
code:00000BDF                 ajmp    SendSimpleESCCode
code:00000BE1 ; ---------------------------------------------------------------------------
code:00000BE1
code:00000BE1 SendESCBar:                             ; CODE XREF: SaveAndSendKey+32↑j
code:00000BE1                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BE1                 mov     A, #'|          ; jumptable 00000B6D case 18
code:00000BE3                 ajmp    SendSimpleESCCode
code:00000BE5 ; ---------------------------------------------------------------------------
code:00000BE5
code:00000BE5 SetBreak:                               ; CODE XREF: SaveAndSendKey+32↑j
code:00000BE5                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BE5                 setb    TimerStatus.1   ; jumptable 00000B6D case 19
code:00000BE7                 ret
code:00000BE8 ; ---------------------------------------------------------------------------
code:00000BE8
code:00000BE8 HELPButton:                             ; CODE XREF: SaveAndSendKey+32↑j
code:00000BE8                                         ; DATA XREF: SaveAndSendKey:ActionKeyTable↑o
code:00000BE8                 jb      VideoSettings.0, SendESCTilde ; jumptable 00000B6D case 17
code:00000BEB
code:00000BEB
code:00000BEB                 setb    PrinterStatus.5 ; Bit 0 = Printer
code:00000BEB                                         ; Bit 1 = Need to send XOFF
code:00000BEB                                         ; Bit 2 = Toggle printer state
code:00000BEB                                         ; Bit 3 = No writes to status line
code:00000BEB                                         ;         No update of time or print status.  Set cursor position ESC
code:00000BEB                                         ;         code cannot set cursor to row 1
code:00000BEB                                         ; Bit 4 = No writes to status line
code:00000BEB                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000BEB                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000BEB                                         ;         position to row 1
code:00000BEB                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000BEB                                         ; Bit 6 = Key pressed
code:00000BEB                                         ; Bit 7 = Repeat eligible
code:00000BED                 ajmp    j_ForceStatusLineUpdate_0
code:00000BEF ; ---------------------------------------------------------------------------
code:00000BEF
code:00000BEF SendESCTilde:                           ; CODE XREF: SaveAndSendKey:HELPButton↑j
code:00000BEF                 mov     A, #'~          ; No idea what this code is supposed to do.
code:00000BF1
code:00000BF1 SendSimpleESCCode:                      ; CODE XREF: SendCursorPosAsESC+2↑p
code:00000BF1                                         ; SendCharUnderCursor+A↑p ...
code:00000BF1                 push    ACC             ; Accumulator
code:00000BF3                 mov     A, #0x1B
code:00000BF5                 lcall   DispatchTypedValue
code:00000BF8                 pop     ACC             ; Accumulator
code:00000BFA                 ljmp    DispatchTypedValue
code:00000BFD ; ---------------------------------------------------------------------------
code:00000BFD
code:00000BFD ToggleOnlineOffline:                    ; CODE XREF: SaveAndSendKey+F↑j
code:00000BFD                 jb      PrinterStatus.5, ReturnGate ; Bit 0 = Printer
code:00000BFD                                         ; Bit 1 = Need to send XOFF
code:00000BFD                                         ; Bit 2 = Toggle printer state
code:00000BFD                                         ; Bit 3 = No writes to status line
code:00000BFD                                         ;         No update of time or print status.  Set cursor position ESC
code:00000BFD                                         ;         code cannot set cursor to row 1
code:00000BFD                                         ; Bit 4 = No writes to status line
code:00000BFD                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000BFD                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000BFD                                         ;         position to row 1
code:00000BFD                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000BFD                                         ; Bit 6 = Key pressed
code:00000BFD                                         ; Bit 7 = Repeat eligible
code:00000C00
code:00000C00
code:00000C00                 cpl     VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000C00                                         ; Bit 1 = Receive buffer is full
code:00000C00                                         ; Bit 3 = Serial send register busy
code:00000C00                                         ; Bit 4 = Busy drawing to screen
code:00000C00                                         ; Bit 5 = Steady/Blink
code:00000C00                                         ; Bit 6 = Disable keyboard
code:00000C00                                         ; Bit 7 = Standard/Graphics
code:00000C02                 ret
code:00000C02 ; End of function SaveAndSendKey
code:00000C02
code:00000C03
code:00000C03 ; =============== S U B R O U T I N E =======================================
code:00000C03
code:00000C03 ; Translates lower-case letters to upper-case.
code:00000C03 ;
code:00000C03 ; A = old value
code:00000C03 ;
code:00000C03 ; On return:
code:00000C03 ;
code:00000C03 ; C = untranslated
code:00000C03 ; A = new value
code:00000C03
code:00000C03 Capitalize:                             ; CODE XREF: CheckKeyboard+3B↑p
code:00000C03                                         ; ConvertControl↓p ...
code:00000C03                 cjne    A, #'a, code_C06
code:00000C06
code:00000C06 code_C06:                               ; CODE XREF: Capitalize↑j
code:00000C06                 jc      ReturnGate
code:00000C08
code:00000C08
code:00000C08                 cjne    A, #'{, code_C0B ; 'z' + 1
code:00000C0B
code:00000C0B code_C0B:                               ; CODE XREF: Capitalize+5↑j
code:00000C0B                 jnc     ReturnGate
code:00000C0D
code:00000C0D
code:00000C0D                 clr     C
code:00000C0E                 subb    A, #0x20
code:00000C10
code:00000C10 ReturnGate:                             ; CODE XREF: SaveAndSendKey:ToggleOnlineOffline↑j
code:00000C10                                         ; Capitalize:code_C06↑j ...
code:00000C10                 ret
code:00000C10 ; End of function Capitalize
code:00000C10
code:00000C11
code:00000C11 ; =============== S U B R O U T I N E =======================================
code:00000C11
code:00000C11 ; Gets the control equivalent of a key in the range of a-z and some symbols.  Converts to uppercase before checking
code:00000C11 ;
code:00000C11 ; If A is in the range of 0x40-0x5F, subtract 0x40.
code:00000C11 ;
code:00000C11 ; If A is between 0x7f and 0x91, add 9
code:00000C11
code:00000C11 ConvertControl:                         ; CODE XREF: CheckKeyboard+40↑p
code:00000C11                 acall   Capitalize      ; Translates lower-case letters to upper-case.
code:00000C11                                         ;
code:00000C11                                         ; A = old value
code:00000C11                                         ;
code:00000C11                                         ; On return:
code:00000C11                                         ;
code:00000C11                                         ; C = untranslated
code:00000C11                                         ; A = new value
code:00000C13                 cjne    A, #'@, CheckLetterLower
code:00000C16
code:00000C16 CheckLetterLower:                       ; CODE XREF: ConvertControl+2↑j
code:00000C16                 jc      ReturnGate
code:00000C18
code:00000C18
code:00000C18                 cjne    A, #0x60, CheckLetterUpper
code:00000C1B
code:00000C1B CheckLetterUpper:                       ; CODE XREF: ConvertControl+7↑j
code:00000C1B                 jnc     CheckActionKey
code:00000C1D
code:00000C1D
code:00000C1D                 clr     C
code:00000C1E
code:00000C1E
code:00000C1E                 subb    A, #0x40
code:00000C20
code:00000C20 ReturnGate:                             ; CODE XREF: ConvertControl:CheckLetterLower↑j
code:00000C20                 ret
code:00000C21 ; ---------------------------------------------------------------------------
code:00000C21
code:00000C21 CheckActionKey:                         ; CODE XREF: ConvertControl:CheckLetterUpper↑j
code:00000C21                 cjne    A, #0x7F, code_C24
code:00000C24
code:00000C24 code_C24:                               ; CODE XREF: ConvertControl:CheckActionKey↑j
code:00000C24                 jc      ReturnGate2
code:00000C26
code:00000C26
code:00000C26                 cjne    A, #0x91, code_C29
code:00000C29
code:00000C29 code_C29:                               ; CODE XREF: ConvertControl+15↑j
code:00000C29                 jnc     ReturnGate2
code:00000C2B
code:00000C2B
code:00000C2B                 add     A, #9
code:00000C2D
code:00000C2D ReturnGate2:                            ; CODE XREF: ConvertControl:code_C24↑j
code:00000C2D                                         ; ConvertControl:code_C29↑j
code:00000C2D                 ret
code:00000C2D ; End of function ConvertControl
code:00000C2D
code:00000C2E
code:00000C2E ; =============== S U B R O U T I N E =======================================
code:00000C2E
code:00000C2E
code:00000C2E TranslateUnshifted:                     ; CODE XREF: CheckKeyboard:NotShifted↑p
code:00000C2E                 movc    A, @A+PC
code:00000C2F                 ret
code:00000C2F ; ---------------------------------------------------------------------------
code:00000C30                 .byte 0x86,' , 0, 0,'/, 0, 0, 0
code:00000C30                 .byte  8,'`,0x5C,'=,'-,'8,'9,'0
code:00000C30                 .byte 0x84,0xA,'{,'[,'p,'u,'i,'o
code:00000C30                 .byte 0x85,0x87,0xD,0x27,';, 0,'.,'l
code:00000C30                 .byte 'a,'s,'d,'f,'g,'k,'j,'h
code:00000C30                 .byte 0x92,'1,'2,'3,'4,'7,'6,'5
code:00000C30                 .byte 0x91, 9,'q,'w,'e,'y,'t,'r
code:00000C30                 .byte 'z,'x,'c,'v,'b,',,'m,'n
code:00000C30 ; End of function TranslateUnshifted
code:00000C30
code:00000C70
code:00000C70 ; =============== S U B R O U T I N E =======================================
code:00000C70
code:00000C70
code:00000C70 TranslateShifted:                       ; CODE XREF: CheckKeyboard+32↑p
code:00000C70                 movc    A, @A+PC
code:00000C71                 ret
code:00000C71 ; ---------------------------------------------------------------------------
code:00000C72                 .byte 0x82,' , 0, 0,'?, 0, 0, 0
code:00000C72                 .byte 0x7F,'~,'|,'+,'_,'*,'(,')
code:00000C72                 .byte 0x80,0xA,'},'],'P,'U,'I,'O
code:00000C72                 .byte 0x81,0x83,0xD,0x22,':, 0,'>,'L
code:00000C72                 .byte 'A,'S,'D,'F,'G,'K,'J,'H
code:00000C72                 .byte 0x93,'!,'@,'#,'$,'&,'^,'%
code:00000C72                 .byte 0x91, 9,'Q,'W,'E,'Y,'T,'R
code:00000C72                 .byte 'Z,'X,'C,'V,'B,'<,'M,'N
code:00000C72 ; End of function TranslateShifted
code:00000C72
code:00000CB2
code:00000CB2 ; =============== S U B R O U T I N E =======================================
code:00000CB2
code:00000CB2
code:00000CB2 CheckPhoneBookMem:                      ; CODE XREF: RESET_0+72↑p
code:00000CB2                                         ; UpdatePhoneBookCksum+D↓p ...
code:00000CB2                 acall   SumRAM3002      ; Sums the lower 16 bits of each RAM location from 3002 to 3400
code:00000CB4
code:00000CB4
code:00000CB4                 mov     DPTR, #DialMemoryCksum
code:00000CB7                 lcall   NibblesToByte   ; Read 2 consecutive nibbles as one byte from DPTR.  This is
code:00000CB7                                         ; used for name and password text stored in phone book memory.
code:00000CBA
code:00000CBA
code:00000CBA                 xrl     A, R2
code:00000CBB
code:00000CBB ReturnGate_1:                           ; CODE XREF: RecvAsHex:code_CCE↓j
code:00000CBB                 ret
code:00000CBB ; End of function CheckPhoneBookMem
code:00000CBB
code:00000CBC
code:00000CBC ; =============== S U B R O U T I N E =======================================
code:00000CBC
code:00000CBC ; Receives a hex digit into 0x3008
code:00000CBC
code:00000CBC RecvAsHex:                              ; CODE XREF: RecvAsHex+3↓j
code:00000CBC                                         ; DATA XREF: InterpretESC+1A↑o
code:00000CBC                 lcall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:00000CBC                                         ; needed.
code:00000CBC                                         ;
code:00000CBC                                         ; At return:
code:00000CBC                                         ;
code:00000CBC                                         ; A = next character
code:00000CBC                                         ; C = next character is valid
code:00000CBF                 jnc     RecvAsHex       ; Receives a hex digit into 0x3008
code:00000CC1
code:00000CC1
code:00000CC1                 clr     C
code:00000CC2                 subb    A, #'0
code:00000CC4                 cjne    A, #10, code_CC7
code:00000CC7
code:00000CC7 code_CC7:                               ; CODE XREF: RecvAsHex+8↑j
code:00000CC7                 jc      code_CD0
code:00000CC9
code:00000CC9
code:00000CC9                 subb    A, #7
code:00000CCB                 cjne    A, #0x10, code_CCE
code:00000CCE
code:00000CCE code_CCE:                               ; CODE XREF: RecvAsHex+F↑j
code:00000CCE                 jnc     ReturnGate_1
code:00000CD0
code:00000CD0 code_CD0:                               ; CODE XREF: RecvAsHex:code_CC7↑j
code:00000CD0                 mov     DPTR, #HexChars
code:00000CD3                 movx    @DPTR, A
code:00000CD3 ; End of function RecvAsHex
code:00000CD3
code:00000CD4
code:00000CD4 ; =============== S U B R O U T I N E =======================================
code:00000CD4
code:00000CD4
code:00000CD4 UpdatePhoneBookCksum:                   ; CODE XREF: SettingsSaveChanges+1B↓p
code:00000CD4                                         ; EraseAllEntries+1B1↓p ...
code:00000CD4                 mov     VerifyPassCnt, #5
code:00000CD7
code:00000CD7 code_CD7:                               ; CODE XREF: UpdatePhoneBookCksum+11↓j
code:00000CD7                 acall   SumRAM3002      ; Sums the lower 16 bits of each RAM location from 3002 to 3400
code:00000CD9
code:00000CD9 ; Write sum into RAM
code:00000CD9                 mov     DPTR, #DialMemoryCksum
code:00000CDC                 swap    A
code:00000CDD                 movx    @DPTR, A
code:00000CDE                 inc     DPTR
code:00000CDF                 mov     A, R2
code:00000CE0                 movx    @DPTR, A
code:00000CE1
code:00000CE1
code:00000CE1                 acall   CheckPhoneBookMem
code:00000CE3                 jz      code_CE8
code:00000CE5
code:00000CE5
code:00000CE5                 djnz    VerifyPassCnt, code_CD7
code:00000CE8
code:00000CE8 code_CE8:                               ; CODE XREF: UpdatePhoneBookCksum+F↑j
code:00000CE8                 ljmp    ExecuteBell
code:00000CE8 ; End of function UpdatePhoneBookCksum
code:00000CE8
code:00000CEB
code:00000CEB ; =============== S U B R O U T I N E =======================================
code:00000CEB
code:00000CEB ; Sums the lower 16 bits of each RAM location from 3002 to 3400
code:00000CEB
code:00000CEB SumRAM3002:                             ; CODE XREF: CheckPhoneBookMem↑p
code:00000CEB                                         ; UpdatePhoneBookCksum:code_CD7↑p
code:00000CEB                 mov     DPTR, #DialMemoryWatermark
code:00000CEE                 mov     R2, #0
code:00000CF0
code:00000CF0 code_CF0:                               ; CODE XREF: SumRAM3002+D↓j
code:00000CF0                 movx    A, @DPTR
code:00000CF1                 anl     A, #0xF
code:00000CF3                 inc     DPTR
code:00000CF4                 add     A, R2
code:00000CF5                 mov     R2, A
code:00000CF6
code:00000CF6
code:00000CF6                 acall   TestDPTR3400
code:00000CF8                 jnz     code_CF0
code:00000CFA
code:00000CFA
code:00000CFA                 mov     A, R2
code:00000CFB                 ret
code:00000CFB ; End of function SumRAM3002
code:00000CFB
code:00000CFC
code:00000CFC ; =============== S U B R O U T I N E =======================================
code:00000CFC
code:00000CFC
code:00000CFC TestDPTR3400:                           ; CODE XREF: SumRAM3002+B↑p
code:00000CFC                 mov     A, DPL          ; Data Pointer, Low Byte
code:00000CFE                 jnz     code_D06
code:00000D00
code:00000D00
code:00000D00                 mov     A, DPH          ; Data Pointer, High Byte
code:00000D02                 cjne    A, #((DialMemoryCksum+0x400) >> 8), code_D06
code:00000D05
code:00000D05
code:00000D05                 clr     A
code:00000D06
code:00000D06 code_D06:                               ; CODE XREF: TestDPTR3400+2↑j
code:00000D06                                         ; TestDPTR3400+6↑j
code:00000D06                 ret
code:00000D06 ; End of function TestDPTR3400
code:00000D06
code:00000D07 ;
code:00000D07 ; This is a state machine that helps with background tasks
code:00000D07 ; related to the modem, such as pulse dialing, listening
code:00000D07 ; for rings, running login scripts, etc.  Each state is a
code:00000D07 ; piece of one of these functions.
code:00000D07 ;
code:00000D07
code:00000D07 ; =============== S U B R O U T I N E =======================================
code:00000D07
code:00000D07
code:00000D07 PerformState:                           ; CODE XREF: TerminalLoop:ChecksDone↓p
code:00000D07                                         ; ConnectMenu+2A↓p
code:00000D07
code:00000D07 ; FUNCTION CHUNK AT code:00000F13 SIZE 00000029 BYTES
code:00000D07
code:00000D07                 mov     DPTR, #code_D0E
code:00000D0A                 mov     A, TerminalState
code:00000D0C                 rl      A
code:00000D0D                 jmp     @A+DPTR
code:00000D0E ; ---------------------------------------------------------------------------
code:00000D0E
code:00000D0E code_D0E:                               ; DATA XREF: PerformState↑o
code:00000D0E                 ajmp    TermState0
code:00000D10 ; ---------------------------------------------------------------------------
code:00000D10                 ajmp    TermState1
code:00000D12 ; ---------------------------------------------------------------------------
code:00000D12                 ajmp    TermState2
code:00000D14 ; ---------------------------------------------------------------------------
code:00000D14                 ajmp    TermState3
code:00000D16 ; ---------------------------------------------------------------------------
code:00000D16                 ajmp    TaskState4
code:00000D18 ; ---------------------------------------------------------------------------
code:00000D18                 ajmp    TaskState5
code:00000D1A ; ---------------------------------------------------------------------------
code:00000D1A                 ajmp    TaskState6
code:00000D1C ; ---------------------------------------------------------------------------
code:00000D1C                 ajmp    TermState7
code:00000D1E ; ---------------------------------------------------------------------------
code:00000D1E                 ajmp    TaskState8
code:00000D20 ; ---------------------------------------------------------------------------
code:00000D20                 ajmp    TaskState9
code:00000D22 ; ---------------------------------------------------------------------------
code:00000D22                 ajmp    TaskState10
code:00000D24 ; ---------------------------------------------------------------------------
code:00000D24                 ajmp    TaskState11
code:00000D26 ; ---------------------------------------------------------------------------
code:00000D26                 ajmp    TaskState12
code:00000D28 ; ---------------------------------------------------------------------------
code:00000D28                 ajmp    TaskState13
code:00000D2A ; ---------------------------------------------------------------------------
code:00000D2A                 ajmp    TaskState14
code:00000D2C ; ---------------------------------------------------------------------------
code:00000D2C                 ajmp    TaskState15
code:00000D2E ; ---------------------------------------------------------------------------
code:00000D2E                 ajmp    TaskState16
code:00000D30 ; ---------------------------------------------------------------------------
code:00000D30                 ajmp    TaskState17
code:00000D32 ; ---------------------------------------------------------------------------
code:00000D32                 ajmp    TaskState18
code:00000D34 ; ---------------------------------------------------------------------------
code:00000D34                 ajmp    TaskState19
code:00000D36 ; ---------------------------------------------------------------------------
code:00000D36                 ajmp    TaskState20
code:00000D38 ; ---------------------------------------------------------------------------
code:00000D38                 ajmp    TaskState21
code:00000D3A ; ---------------------------------------------------------------------------
code:00000D3A                 ajmp    TaskState22
code:00000D3C ; ---------------------------------------------------------------------------
code:00000D3C                 ajmp    TermState23
code:00000D3E ; ---------------------------------------------------------------------------
code:00000D3E                 ajmp    TermState24
code:00000D40 ; ---------------------------------------------------------------------------
code:00000D40
code:00000D40 ;
code:00000D40 ; State 2 waits for the next ring.  If one does not arrive
code:00000D40 ; in time, return to State 0.  Otherwise go to State 1.
code:00000D40 ;
code:00000D40
code:00000D40 WaitForRing:                            ; CODE XREF: PerformState+61↓j
code:00000D40                                         ; PerformState+64↓j
code:00000D40                 acall   ProgramTimer5seconds ; 5s
code:00000D42                 mov     TerminalState, #2
code:00000D45
code:00000D45 TermState2:                             ; CODE XREF: PerformState+B↑j
code:00000D45                 jb      P15, RingDetected ; Port 1
code:00000D48
code:00000D48
code:00000D48                 jb      TimerStatus.3, MiscTaskDone ; Return to reset state if it's been too long
code:00000D4B
code:00000D4B ;
code:00000D4B ; State 0 resets the ring counter.  If auto-answer is on
code:00000D4B ; and a ring is signaled, it moves to State 1.  Otherwise
code:00000D4B ; only outside intervention will change states.
code:00000D4B ;
code:00000D4B
code:00000D4B ResetRingCount:                         ; CODE XREF: PerformState+D9↓j
code:00000D4B                                         ; PerformState+1E1↓j ...
code:00000D4B                 mov     TerminalState, #0
code:00000D4E
code:00000D4E
code:00000D4E                 clr     P14             ; Turn off that scream
code:00000D50                 setb    P11             ; Detect rings
code:00000D52
code:00000D52 TermState0:                             ; CODE XREF: PerformState:code_D0E↑j
code:00000D52                 mov     A, AutoAnswerAfter ; Number of rings to wait
code:00000D54                 jz      MiscTaskDone
code:00000D56
code:00000D56
code:00000D56                 mov     RingCountdown, A
code:00000D58
code:00000D58
code:00000D58                 jnb     P15, MiscTaskDone ; If ring is detected, fall through
code:00000D5B
code:00000D5B RingDetected:                           ; CODE XREF: PerformState:TermState2↑j
code:00000D5B                 mov     TerminalState, #1
code:00000D5E
code:00000D5E
code:00000D5E                 mov     A, #3
code:00000D60                 mov     B, #4           ; Around a quarter of a second
code:00000D63                 acall   ProgramTimer0   ; A and B are multipliers.  The total duration is A*B/50
code:00000D63                                         ; seconds
code:00000D65
code:00000D65
code:00000D65 ;
code:00000D65 ; State 1 waits for the ring signal to go away.  If
code:00000D65 ; this happens before a required duration, go to State 2.
code:00000D65 ; Otherwise decrement the ring counter and check for
code:00000D65 ; 0.  If so, activate modem and move to State 3.  If not,
code:00000D65 ; move to State 2.
code:00000D65 ;
code:00000D65
code:00000D65 TermState1:                             ; CODE XREF: PerformState+9↑j
code:00000D65                 jb      P15, MiscTaskDone ; Port 1
code:00000D68
code:00000D68
code:00000D68                 jb      TimerStatus.3, WaitForRing ; The ring signal is a series of high-voltage pulses which
code:00000D68                                         ; were strong enough to ring the bell in old rotary
code:00000D68                                         ; telephones.  Due to the pulse nature of this voltage, the
code:00000D68                                         ; bell would be repeatedly struck, resulting in the familiar
code:00000D68                                         ; sound.  Then the ringing would stop for a second or two.
code:00000D68                                         ; We're timing here to make sure we haven't heard a previous
code:00000D68                                         ; ring in a quarter second, before finally declaring the end
code:00000D68                                         ; of a "ring".
code:00000D6B
code:00000D6B
code:00000D6B                 djnz    RingCountdown, WaitForRing ; And now see if we've seen enough rings
code:00000D6E
code:00000D6E
code:00000D6E                 acall   ProgramTimer0TenthSecond ; 0.1s
code:00000D70
code:00000D70
code:00000D70                 clr     T0              ; Port 3
code:00000D72                 mov     TerminalState, #3
code:00000D75
code:00000D75
code:00000D75
code:00000D75 TermState3:                             ; CODE XREF: PerformState+D↑j
code:00000D75                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000D75                                         ; Bit 1 = BREAK is tracked as pressed
code:00000D75                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000D75                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000D75                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000D75                                         ;         handler uses this to look for timeouts in each state.
code:00000D75                                         ; Bit 4 = Use immediate dial buffer
code:00000D75                                         ; Bit 5 = Dial voice
code:00000D75                                         ; Bit 6 = Disabling/Enabling a setting
code:00000D75                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000D78
code:00000D78 ;
code:00000D78 ; Note that these control signals are only set on
code:00000D78 ; transition from 3 to 4, not from other states.
code:00000D78 ;
code:00000D78                 clr     P10             ; Go off-hook (pick up the phone!)
code:00000D7A                 setb    P14             ; Begin modem handshake
code:00000D7C
code:00000D7C ;
code:00000D7C ; This state only seems to introduce a 1-second pause
code:00000D7C ;
code:00000D7C
code:00000D7C Wait1sThenDetectCarrier:                ; CODE XREF: PerformState+8F↓j
code:00000D7C                 acall   ProgramTimer0OneSecond ; 1s
code:00000D7E                 mov     TerminalState, #4
code:00000D81
code:00000D81 TaskState4:                             ; CODE XREF: PerformState+F↑j
code:00000D81                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000D81                                         ; Bit 1 = BREAK is tracked as pressed
code:00000D81                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000D81                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000D81                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000D81                                         ;         handler uses this to look for timeouts in each state.
code:00000D81                                         ; Bit 4 = Use immediate dial buffer
code:00000D81                                         ; Bit 5 = Dial voice
code:00000D81                                         ; Bit 6 = Disabling/Enabling a setting
code:00000D81                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000D84
code:00000D84 DetectCarrier:                          ; CODE XREF: PerformState:TaskState6↓j
code:00000D84                 acall   ProgramTimer5seconds ; 5s
code:00000D86                 mov     TerminalState, #5
code:00000D89
code:00000D89 ;
code:00000D89 ; State 5:  Wait up to 5 seconds for carrier detection,
code:00000D89 ; then move to state 6 if successful
code:00000D89 ;
code:00000D89
code:00000D89 TaskState5:                             ; CODE XREF: PerformState+11↑j
code:00000D89                 jb      P15, CarrierDetected ; Port 1
code:00000D8C
code:00000D8C
code:00000D8C                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000D8C                                         ; Bit 1 = BREAK is tracked as pressed
code:00000D8C                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000D8C                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000D8C                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000D8C                                         ;         handler uses this to look for timeouts in each state.
code:00000D8C                                         ; Bit 4 = Use immediate dial buffer
code:00000D8C                                         ; Bit 5 = Dial voice
code:00000D8C                                         ; Bit 6 = Disabling/Enabling a setting
code:00000D8C                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000D8F
code:00000D8F ;
code:00000D8F ; Give up on the handshake.
code:00000D8F ; The first time through, disable the ring listener bit.
code:00000D8F ; The second time through, offer to let the user answer
code:00000D8F ; the voice call of the (now annoyed) caller
code:00000D8F ;
code:00000D8F                 clr     P14             ; Port 1
code:00000D91
code:00000D91
code:00000D91                 jnb     P11, AnswerVoice ; Port 1
code:00000D94
code:00000D94
code:00000D94                 clr     P11             ; Port 1
code:00000D96                 ajmp    Wait1sThenDetectCarrier
code:00000D98 ; ---------------------------------------------------------------------------
code:00000D98
code:00000D98 CarrierDetected:                        ; CODE XREF: PerformState:TaskState5↑j
code:00000D98                 acall   ProgramTimer0TwoHalfSecond ; 2.5s
code:00000D9A                 mov     TerminalState, #6
code:00000D9D
code:00000D9D TaskState6:                             ; CODE XREF: PerformState+13↑j
code:00000D9D                 jnb     P15, DetectCarrier ; If the signal is lost, try to retrain
code:00000DA0
code:00000DA0
code:00000DA0                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000DA0                                         ; Bit 1 = BREAK is tracked as pressed
code:00000DA0                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000DA0                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000DA0                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000DA0                                         ;         handler uses this to look for timeouts in each state.
code:00000DA0                                         ; Bit 4 = Use immediate dial buffer
code:00000DA0                                         ; Bit 5 = Dial voice
code:00000DA0                                         ; Bit 6 = Disabling/Enabling a setting
code:00000DA0                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000DA3
code:00000DA3
code:00000DA3                 ajmp    ModemIsOnline
code:00000DA5 ; ---------------------------------------------------------------------------
code:00000DA5
code:00000DA5 MiscTaskDone:                           ; CODE XREF: PerformState+41↑j
code:00000DA5                                         ; PerformState+4D↑j ...
code:00000DA5                 ret
code:00000DA6 ; ---------------------------------------------------------------------------
code:00000DA6
code:00000DA6 AnswerVoice:                            ; CODE XREF: PerformState+8A↑j
code:00000DA6                 clr     P14             ; Make sure the handshake is shut off
code:00000DA8
code:00000DA8
code:00000DA8                 mov     DPTR, #aAnswerVoiceCal ; "Answer Voice call, press RETURN "
code:00000DAB                 mov     R0, #(VideoLine1 & 0xFF)
code:00000DAD                 mov     R1, #(VideoLine1 >> 8)
code:00000DAF                 mov     BellDurationCounter, #19
code:00000DB2                 lcall   PrintCStringToVRAMEntry ; R1:R0 = destination
code:00000DB2                                         ; DPTR = source
code:00000DB2                                         ;
code:00000DB2                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00000DB5
code:00000DB5
code:00000DB5                 mov     A, #250         ; 30 seconds
code:00000DB7                 mov     B, #6           ; B-Register
code:00000DBA                 acall   ProgramTimer0   ; A and B are multipliers.  The total duration is A*B/50
code:00000DBA                                         ; seconds
code:00000DBC                 mov     TerminalState, #7
code:00000DBF
code:00000DBF ;
code:00000DBF ; State 7 - Offer to answer a voice call.  You have 30
code:00000DBF ; seconds to press RETURN
code:00000DBF ;
code:00000DBF
code:00000DBF TermState7:                             ; CODE XREF: PerformState+15↑j
code:00000DBF                 mov     A, SerialInBufLen
code:00000DC1                 jz      NoKeyAvailable
code:00000DC3
code:00000DC3 ;
code:00000DC3 ; The user has pressed RETURN, so hang up and let the call
code:00000DC3 ; progress.  Go back to waiting for the next call.
code:00000DC3 ;
code:00000DC3                 acall   j_ForceStatusLineUpdate_0
code:00000DC5                 ajmp    HangUpModem
code:00000DC7 ; ---------------------------------------------------------------------------
code:00000DC7
code:00000DC7 NoKeyAvailable:                         ; CODE XREF: PerformState+BA↑j
code:00000DC7                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000DC7                                         ; Bit 1 = BREAK is tracked as pressed
code:00000DC7                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000DC7                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000DC7                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000DC7                                         ;         handler uses this to look for timeouts in each state.
code:00000DC7                                         ; Bit 4 = Use immediate dial buffer
code:00000DC7                                         ; Bit 5 = Dial voice
code:00000DC7                                         ; Bit 6 = Disabling/Enabling a setting
code:00000DC7                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000DCA
code:00000DCA ;
code:00000DCA ; We already wrote over the status line with an offer to
code:00000DCA ; let the user answer the voice call.  Now that we've
code:00000DCA ; given up on even that, it's time to restore the status
code:00000DCA ; line and then go back to listening
code:00000DCA ;
code:00000DCA
code:00000DCA RestoreStatusLine:                      ; CODE XREF: CheckKeyboard+6E↑p
code:00000DCA                                         ; PerformState+170↓j ...
code:00000DCA                 jnb     P12, StillOffline ; If route select is 0 or 2, we are forced offline.
code:00000DCD
code:00000DCD
code:00000DCD                 jnb     P13, code_DD4   ; If route is 1, our ONLINE/OFFLINE state is irrelevant
code:00000DD0
code:00000DD0 StillOffline:                           ; CODE XREF: PerformState:RestoreStatusLine↑j
code:00000DD0                 clr     VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000DD0                                         ; Bit 1 = Receive buffer is full
code:00000DD0                                         ; Bit 3 = Serial send register busy
code:00000DD0                                         ; Bit 4 = Busy drawing to screen
code:00000DD0                                         ; Bit 5 = Steady/Blink
code:00000DD0                                         ; Bit 6 = Disable keyboard
code:00000DD0                                         ; Bit 7 = Standard/Graphics
code:00000DD2                 acall   j_ForceStatusLineUpdate_0
code:00000DD4
code:00000DD4 code_DD4:                               ; CODE XREF: PerformState+C6↑j
code:00000DD4                 setb    P10             ; Hang up
code:00000DD6                 acall   ProgramTimer0TenthSecond ; 0.1s
code:00000DD8                 mov     TerminalState, #8
code:00000DDB
code:00000DDB TaskState8:                             ; CODE XREF: PerformState+17↑j
code:00000DDB                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000DDB                                         ; Bit 1 = BREAK is tracked as pressed
code:00000DDB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000DDB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000DDB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000DDB                                         ;         handler uses this to look for timeouts in each state.
code:00000DDB                                         ; Bit 4 = Use immediate dial buffer
code:00000DDB                                         ; Bit 5 = Dial voice
code:00000DDB                                         ; Bit 6 = Disabling/Enabling a setting
code:00000DDB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000DDE                 setb    T0              ; Port 3
code:00000DE0                 ajmp    ResetRingCount
code:00000DE2 ; ---------------------------------------------------------------------------
code:00000DE2
code:00000DE2 BeginDialing:                           ; CODE XREF: PerformState+22D↓j
code:00000DE2                 clr     P11             ; Port 1
code:00000DE4                 clr     P14             ; Port 1
code:00000DE6                 clr     T0              ; Port 3
code:00000DE8
code:00000DE8
code:00000DE8                 mov     A, #50          ; 1/6 second
code:00000DEA                 mov     B, #2           ; B-Register
code:00000DED                 acall   ProgramTimer0   ; A and B are multipliers.  The total duration is A*B/50
code:00000DED                                         ; seconds
code:00000DEF
code:00000DEF
code:00000DEF                 mov     TerminalState, #9
code:00000DF2                 jb      PrinterStatus.4, TaskState9 ; Bit 0 = Printer
code:00000DF2                                         ; Bit 1 = Need to send XOFF
code:00000DF2                                         ; Bit 2 = Toggle printer state
code:00000DF2                                         ; Bit 3 = No writes to status line
code:00000DF2                                         ;         No update of time or print status.  Set cursor position ESC
code:00000DF2                                         ;         code cannot set cursor to row 1
code:00000DF2                                         ; Bit 4 = No writes to status line
code:00000DF2                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000DF2                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000DF2                                         ;         position to row 1
code:00000DF2                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000DF2                                         ; Bit 6 = Key pressed
code:00000DF2                                         ; Bit 7 = Repeat eligible
code:00000DF5                 jb      PrinterStatus.3, TaskState9 ; Bit 0 = Printer
code:00000DF5                                         ; Bit 1 = Need to send XOFF
code:00000DF5                                         ; Bit 2 = Toggle printer state
code:00000DF5                                         ; Bit 3 = No writes to status line
code:00000DF5                                         ;         No update of time or print status.  Set cursor position ESC
code:00000DF5                                         ;         code cannot set cursor to row 1
code:00000DF5                                         ; Bit 4 = No writes to status line
code:00000DF5                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000DF5                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000DF5                                         ;         position to row 1
code:00000DF5                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000DF5                                         ; Bit 6 = Key pressed
code:00000DF5                                         ; Bit 7 = Repeat eligible
code:00000DF8
code:00000DF8
code:00000DF8                 mov     DPTR, #aDialing
code:00000DFB                 ajmp    WriteTerminalOnlineStatus
code:00000DFD ; ---------------------------------------------------------------------------
code:00000DFD
code:00000DFD ;
code:00000DFD ; Task state 9 is entered when asked to dial a number.
code:00000DFD ; Pauses 2.5s then moves to state 10
code:00000DFD ;
code:00000DFD
code:00000DFD TaskState9:                             ; CODE XREF: PerformState+19↑j
code:00000DFD                                         ; PerformState+EB↑j ...
code:00000DFD                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000DFD                                         ; Bit 1 = BREAK is tracked as pressed
code:00000DFD                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000DFD                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000DFD                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000DFD                                         ;         handler uses this to look for timeouts in each state.
code:00000DFD                                         ; Bit 4 = Use immediate dial buffer
code:00000DFD                                         ; Bit 5 = Dial voice
code:00000DFD                                         ; Bit 6 = Disabling/Enabling a setting
code:00000DFD                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E00                 clr     P10             ; Off hook (pick up phone)
code:00000E02                 acall   ProgramTimer0TwoHalfSecond ; 2.5s
code:00000E04
code:00000E04
code:00000E04                 mov     TerminalState, #10
code:00000E07
code:00000E07 TaskState10:                            ; CODE XREF: PerformState+1B↑j
code:00000E07                 jb      TimerStatus.3, MiscTaskDone ; Bit 0 = ESC is tracked as pressed
code:00000E07                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E07                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E07                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E07                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E07                                         ;         handler uses this to look for timeouts in each state.
code:00000E07                                         ; Bit 4 = Use immediate dial buffer
code:00000E07                                         ; Bit 5 = Dial voice
code:00000E07                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E07                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E0A
code:00000E0A LoadNextDialDigit:                      ; CODE XREF: PerformState+144↓j
code:00000E0A                 acall   GetNextDigitToDial ; This is a destructive read of DigitsToDial.  Every time it
code:00000E0A                                         ; returns a digit, it also destroys that digit so that the
code:00000E0A                                         ; next call will return the following digit.  Just use a
code:00000E0A                                         ; cursor?  Nah.
code:00000E0C                 jz      DialFinished
code:00000E0E
code:00000E0E
code:00000E0E                 cjne    A, #13, CheckForDash
code:00000E11
code:00000E11 ;
code:00000E11 ; A slash was encountered.  Pause for (cnt+4)*15/50 secs
code:00000E11 ;
code:00000E11                 mov     A, SlashPause   ; Time to wait when / is seen.  Value is 3*number+12
code:00000E13                 add     A, #4
code:00000E15                 mov     B, A            ; B-Register
code:00000E17                 mov     A, #15
code:00000E19                 acall   ProgramTimer0   ; A and B are multipliers.  The total duration is A*B/50
code:00000E19                                         ; seconds
code:00000E1B                 ajmp    DialPause
code:00000E1D ; ---------------------------------------------------------------------------
code:00000E1D
code:00000E1D CheckForDash:                           ; CODE XREF: PerformState+107↑j
code:00000E1D                 cjne    A, #14, SendPulses
code:00000E20
code:00000E20
code:00000E20                 acall   ProgramTimer0OneSecond ; 1s
code:00000E22                 ajmp    DialPause
code:00000E24 ; ---------------------------------------------------------------------------
code:00000E24
code:00000E24 SendPulses:                             ; CODE XREF: PerformState:CheckForDash↑j
code:00000E24                 mov     PulseCount, A
code:00000E26
code:00000E26 PulseRelayOn:                           ; CODE XREF: PerformState+137↓j
code:00000E26                 setb    P10             ; Port 1
code:00000E28
code:00000E28
code:00000E28                 mov     A, #3           ; Pause for 3/50 of a second
code:00000E2A                 acall   ProgramTimer0A  ; The total duration is A
code:00000E2C
code:00000E2C
code:00000E2C                 mov     TerminalState, #11
code:00000E2F
code:00000E2F ;
code:00000E2F ; Task state 11 is for pulse dialing.  It is the pause
code:00000E2F ; between turning the pulse relay on and off
code:00000E2F ;
code:00000E2F
code:00000E2F TaskState11:                            ; CODE XREF: PerformState+1D↑j
code:00000E2F                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000E2F                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E2F                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E2F                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E2F                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E2F                                         ;         handler uses this to look for timeouts in each state.
code:00000E2F                                         ; Bit 4 = Use immediate dial buffer
code:00000E2F                                         ; Bit 5 = Dial voice
code:00000E2F                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E2F                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E32                 clr     P10             ; Port 1
code:00000E34
code:00000E34
code:00000E34                 mov     A, #2           ; Pause for 2/50 of a second
code:00000E36                 acall   ProgramTimer0A  ; The total duration is A
code:00000E38
code:00000E38
code:00000E38                 mov     TerminalState, #12
code:00000E3B
code:00000E3B ;
code:00000E3B ; Task State 12 waits for time to turn the pulse relay
code:00000E3B ; back on, decrements the pulse train count, and returns
code:00000E3B ; to task state 11 if more pulses are needed
code:00000E3B ;
code:00000E3B
code:00000E3B TaskState12:                            ; CODE XREF: PerformState+1F↑j
code:00000E3B                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000E3B                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E3B                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E3B                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E3B                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E3B                                         ;         handler uses this to look for timeouts in each state.
code:00000E3B                                         ; Bit 4 = Use immediate dial buffer
code:00000E3B                                         ; Bit 5 = Dial voice
code:00000E3B                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E3B                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E3E                 djnz    PulseCount, PulseRelayOn
code:00000E41
code:00000E41
code:00000E41                 mov     A, #40          ; 40/50 of a second pause
code:00000E43                 acall   ProgramTimer0A  ; The total duration is A
code:00000E45
code:00000E45 DialPause:                              ; CODE XREF: PerformState+114↑j
code:00000E45                                         ; PerformState+11B↑j
code:00000E45                 mov     TerminalState, #13
code:00000E48
code:00000E48 ;
code:00000E48 ; State 13 is the long pause state between pulse trains.
code:00000E48 ; Once the pause expires, it loads the next digit and
code:00000E48 ; returns to state 11
code:00000E48
code:00000E48 TaskState13:                            ; CODE XREF: PerformState+21↑j
code:00000E48                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000E48                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E48                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E48                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E48                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E48                                         ;         handler uses this to look for timeouts in each state.
code:00000E48                                         ; Bit 4 = Use immediate dial buffer
code:00000E48                                         ; Bit 5 = Dial voice
code:00000E48                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E48                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E4B                 ajmp    LoadNextDialDigit
code:00000E4D ; ---------------------------------------------------------------------------
code:00000E4D
code:00000E4D DialFinished:                           ; CODE XREF: PerformState+105↑j
code:00000E4D                 jb      PrinterStatus.4, AbortDial ; Bit 0 = Printer
code:00000E4D                                         ; Bit 1 = Need to send XOFF
code:00000E4D                                         ; Bit 2 = Toggle printer state
code:00000E4D                                         ; Bit 3 = No writes to status line
code:00000E4D                                         ;         No update of time or print status.  Set cursor position ESC
code:00000E4D                                         ;         code cannot set cursor to row 1
code:00000E4D                                         ; Bit 4 = No writes to status line
code:00000E4D                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000E4D                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000E4D                                         ;         position to row 1
code:00000E4D                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000E4D                                         ; Bit 6 = Key pressed
code:00000E4D                                         ; Bit 7 = Repeat eligible
code:00000E50                 jb      PrinterStatus.3, AbortDial ; Bit 0 = Printer
code:00000E50                                         ; Bit 1 = Need to send XOFF
code:00000E50                                         ; Bit 2 = Toggle printer state
code:00000E50                                         ; Bit 3 = No writes to status line
code:00000E50                                         ;         No update of time or print status.  Set cursor position ESC
code:00000E50                                         ;         code cannot set cursor to row 1
code:00000E50                                         ; Bit 4 = No writes to status line
code:00000E50                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00000E50                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00000E50                                         ;         position to row 1
code:00000E50                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00000E50                                         ; Bit 6 = Key pressed
code:00000E50                                         ; Bit 7 = Repeat eligible
code:00000E53                 mov     DPTR, #aWait
code:00000E56                 acall   WriteTerminalOnlineStatus
code:00000E58
code:00000E58 AbortDial:                              ; CODE XREF: PerformState:DialFinished↑j
code:00000E58                                         ; PerformState+149↑j ...
code:00000E58                 clr     FormatStatus.0  ; Bit 0 = Ctrl-F1 pressed
code:00000E58                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000E58                                         ; Bit 2 = In graphics mode
code:00000E5A                 jnb     TimerStatus.5, WaitForAnswer ; Bit 0 = ESC is tracked as pressed
code:00000E5A                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E5A                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E5A                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E5A                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E5A                                         ;         handler uses this to look for timeouts in each state.
code:00000E5A                                         ; Bit 4 = Use immediate dial buffer
code:00000E5A                                         ; Bit 5 = Dial voice
code:00000E5A                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E5A                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E5D
code:00000E5D ;
code:00000E5D ; Seems rude, but I confirmed with the service manaul:
code:00000E5D ; For voice calls, it will dial the number and then
code:00000E5D ; immediately hang up.  It's your responsibility to pick
code:00000E5D ; up the receiver before dialing is finished.
code:00000E5D ;
code:00000E5D                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000E5D                                         ; Bit 1 = Receive buffer is full
code:00000E5D                                         ; Bit 3 = Serial send register busy
code:00000E5D                                         ; Bit 4 = Busy drawing to screen
code:00000E5D                                         ; Bit 5 = Steady/Blink
code:00000E5D                                         ; Bit 6 = Disable keyboard
code:00000E5D                                         ; Bit 7 = Standard/Graphics
code:00000E5F                 acall   j_ForceStatusLineUpdate_0
code:00000E61                 ajmp    HangUpModem
code:00000E63 ; ---------------------------------------------------------------------------
code:00000E63
code:00000E63 WaitForAnswer:                          ; CODE XREF: PerformState+153↑j
code:00000E63                 mov     B, SecWaitForAnswer ; The actual value is this value*5
code:00000E66                 inc     B               ; B-Register
code:00000E68                 mov     A, #250         ; 5 second multiplier
code:00000E6A
code:00000E6A ResumeWaitForAnswer:                    ; CODE XREF: PerformState+185↓j
code:00000E6A                 acall   ProgramTimer0   ; A and B are multipliers.  The total duration is A*B/50
code:00000E6A                                         ; seconds
code:00000E6C
code:00000E6C ;
code:00000E6C ; State 14 waits for the handshake that the answering
code:00000E6C ; modem is supposed to send
code:00000E6C ;
code:00000E6C                 mov     TerminalState, #14
code:00000E6F
code:00000E6F TaskState14:                            ; CODE XREF: PerformState+23↑j
code:00000E6F                 jb      P15, HandshakeDetected ; Port 1
code:00000E72
code:00000E72
code:00000E72                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000E72                                         ; Bit 1 = BREAK is tracked as pressed
code:00000E72                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000E72                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000E72                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000E72                                         ;         handler uses this to look for timeouts in each state.
code:00000E72                                         ; Bit 4 = Use immediate dial buffer
code:00000E72                                         ; Bit 5 = Dial voice
code:00000E72                                         ; Bit 6 = Disabling/Enabling a setting
code:00000E72                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000E75                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000E75                                         ; Bit 1 = Receive buffer is full
code:00000E75                                         ; Bit 3 = Serial send register busy
code:00000E75                                         ; Bit 4 = Busy drawing to screen
code:00000E75                                         ; Bit 5 = Steady/Blink
code:00000E75                                         ; Bit 6 = Disable keyboard
code:00000E75                                         ; Bit 7 = Standard/Graphics
code:00000E77                 ajmp    RestoreStatusLine
code:00000E79 ; ---------------------------------------------------------------------------
code:00000E79
code:00000E79 ;
code:00000E79 ; We interrupt this waiting period for another waiting
code:00000E79 ; period.  But don't worry, we saved the time left so
code:00000E79 ; we can resume the original waiting period after this
code:00000E79 ; waiting period is over.
code:00000E79 ;
code:00000E79
code:00000E79 HandshakeDetected:                      ; CODE XREF: PerformState:TaskState14↑j
code:00000E79                 mov     Scratchpad, T0MultA ; Timer 0 frequency
code:00000E7C                 mov     SavedT0MultB, T0MultB ; Number of times T0 will expire before it is shut down
code:00000E7F
code:00000E7F
code:00000E7F                 mov     TerminalState, #15
code:00000E82                 acall   ProgramTimer0TwoHalfSecond ; 2.5s
code:00000E84
code:00000E84 TaskState15:                            ; CODE XREF: PerformState+25↑j
code:00000E84                 jb      P15, HandshakeStillDetected ; Port 1
code:00000E87
code:00000E87
code:00000E87                 mov     A, Scratchpad
code:00000E89                 mov     B, SavedT0MultB ; B-Register
code:00000E8C                 sjmp    ResumeWaitForAnswer
code:00000E8E ; ---------------------------------------------------------------------------
code:00000E8E
code:00000E8E HandshakeStillDetected:                 ; CODE XREF: PerformState:TaskState15↑j
code:00000E8E                 jb      TimerStatus.3, Done ; Drop through to ONLINE mode if enemy carrier is still
code:00000E8E                                         ; detected
code:00000E91
code:00000E91 ;
code:00000E91 ; State 16 seems to be waiting for the modem to detect end
code:00000E91 ; of call.  If a "blip" happens, drop to state 17.
code:00000E91 ; Otherwise remain here
code:00000E91 ;
code:00000E91
code:00000E91 ModemIsOnline:                          ; CODE XREF: PerformState+9C↑j
code:00000E91                                         ; PerformState:TaskState17↓j
code:00000E91                 mov     TerminalState, #16
code:00000E94                 setb    VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000E94                                         ; Bit 1 = Receive buffer is full
code:00000E94                                         ; Bit 3 = Serial send register busy
code:00000E94                                         ; Bit 4 = Busy drawing to screen
code:00000E94                                         ; Bit 5 = Steady/Blink
code:00000E94                                         ; Bit 6 = Disable keyboard
code:00000E94                                         ; Bit 7 = Standard/Graphics
code:00000E96                 setb    P14             ; Continue with carrier
code:00000E98
code:00000E98 TaskState16:                            ; CODE XREF: PerformState+27↑j
code:00000E98                 jb      P15, Done       ; If carrier is still detected, all is well
code:00000E9B
code:00000E9B ;
code:00000E9B ; Oops, a glitch in The Matrix!  See if we recover.
code:00000E9B ; Could be transient line noise.
code:00000E9B ;
code:00000E9B                 acall   ProgramTimer0TenthSecond ; 0.1s
code:00000E9D                 mov     TerminalState, #17
code:00000EA0
code:00000EA0 TaskState17:                            ; CODE XREF: PerformState+29↑j
code:00000EA0                 jb      P15, ModemIsOnline ; Whew, return to state 16
code:00000EA3
code:00000EA3
code:00000EA3                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000EA3                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EA3                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EA3                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EA3                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EA3                                         ;         handler uses this to look for timeouts in each state.
code:00000EA3                                         ; Bit 4 = Use immediate dial buffer
code:00000EA3                                         ; Bit 5 = Dial voice
code:00000EA3                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EA3                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EA6                 ajmp    RestoreStatusLine ; The call is over.  Hang up and return to listening
code:00000EA8 ; ---------------------------------------------------------------------------
code:00000EA8
code:00000EA8 Done:                                   ; CODE XREF: PerformState:TaskState11↑j
code:00000EA8                                         ; PerformState:TaskState12↑j ...
code:00000EA8                 ret
code:00000EA9 ; ---------------------------------------------------------------------------
code:00000EA9
code:00000EA9 ;
code:00000EA9 ; This state is from outside and indicates that the user
code:00000EA9 ; has chosen to voice dial with a manually entered number
code:00000EA9 ;
code:00000EA9
code:00000EA9 TaskState18:                            ; CODE XREF: PerformState+2B↑j
code:00000EA9                 setb    TimerStatus.4   ; Bit 0 = ESC is tracked as pressed
code:00000EA9                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EA9                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EA9                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EA9                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EA9                                         ;         handler uses this to look for timeouts in each state.
code:00000EA9                                         ; Bit 4 = Use immediate dial buffer
code:00000EA9                                         ; Bit 5 = Dial voice
code:00000EA9                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EA9                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EAB                 setb    TimerStatus.5   ; Bit 0 = ESC is tracked as pressed
code:00000EAB                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EAB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EAB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EAB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EAB                                         ;         handler uses this to look for timeouts in each state.
code:00000EAB                                         ; Bit 4 = Use immediate dial buffer
code:00000EAB                                         ; Bit 5 = Dial voice
code:00000EAB                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EAB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EAD                 ajmp    SetupForDialing
code:00000EAF ; ---------------------------------------------------------------------------
code:00000EAF
code:00000EAF ;
code:00000EAF ; This state is chosen from outside and indicates that the
code:00000EAF ; user has chosen data dial with a manually entered number
code:00000EAF ;
code:00000EAF
code:00000EAF TaskState19:                            ; CODE XREF: PerformState+2D↑j
code:00000EAF                 setb    TimerStatus.4   ; Bit 0 = ESC is tracked as pressed
code:00000EAF                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EAF                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EAF                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EAF                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EAF                                         ;         handler uses this to look for timeouts in each state.
code:00000EAF                                         ; Bit 4 = Use immediate dial buffer
code:00000EAF                                         ; Bit 5 = Dial voice
code:00000EAF                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EAF                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EB1                 clr     TimerStatus.5   ; Bit 0 = ESC is tracked as pressed
code:00000EB1                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EB1                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EB1                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EB1                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EB1                                         ;         handler uses this to look for timeouts in each state.
code:00000EB1                                         ; Bit 4 = Use immediate dial buffer
code:00000EB1                                         ; Bit 5 = Dial voice
code:00000EB1                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EB1                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EB3                 ajmp    SetupForDialing
code:00000EB5 ; ---------------------------------------------------------------------------
code:00000EB5
code:00000EB5 ;
code:00000EB5 ; This state is from outside and indicates that the user
code:00000EB5 ; has chosen to voice dial with a phone book entry
code:00000EB5 ;
code:00000EB5
code:00000EB5 TaskState20:                            ; CODE XREF: PerformState+2F↑j
code:00000EB5                 clr     TimerStatus.4   ; Bit 0 = ESC is tracked as pressed
code:00000EB5                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EB5                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EB5                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EB5                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EB5                                         ;         handler uses this to look for timeouts in each state.
code:00000EB5                                         ; Bit 4 = Use immediate dial buffer
code:00000EB5                                         ; Bit 5 = Dial voice
code:00000EB5                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EB5                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EB7                 setb    TimerStatus.5   ; Bit 0 = ESC is tracked as pressed
code:00000EB7                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EB7                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EB7                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EB7                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EB7                                         ;         handler uses this to look for timeouts in each state.
code:00000EB7                                         ; Bit 4 = Use immediate dial buffer
code:00000EB7                                         ; Bit 5 = Dial voice
code:00000EB7                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EB7                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EB9                 ajmp    SetupForDialing
code:00000EBB ; ---------------------------------------------------------------------------
code:00000EBB
code:00000EBB ;
code:00000EBB ; This state is chosen from outside and indicates that the
code:00000EBB ; user has chosen data dial with a phone book entry
code:00000EBB ;
code:00000EBB
code:00000EBB TaskState21:                            ; CODE XREF: PerformState+31↑j
code:00000EBB                 clr     TimerStatus.4   ; Bit 0 = ESC is tracked as pressed
code:00000EBB                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EBB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EBB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EBB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EBB                                         ;         handler uses this to look for timeouts in each state.
code:00000EBB                                         ; Bit 4 = Use immediate dial buffer
code:00000EBB                                         ; Bit 5 = Dial voice
code:00000EBB                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EBB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EBD                 clr     TimerStatus.5   ; Bit 0 = ESC is tracked as pressed
code:00000EBD                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EBD                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EBD                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EBD                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EBD                                         ;         handler uses this to look for timeouts in each state.
code:00000EBD                                         ; Bit 4 = Use immediate dial buffer
code:00000EBD                                         ; Bit 5 = Dial voice
code:00000EBD                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EBD                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EBF                 ajmp    SetupForDialing
code:00000EC1 ; ---------------------------------------------------------------------------
code:00000EC1
code:00000EC1 TurnOffAnswerMode:                      ; CODE XREF: PerformState+22A↓j
code:00000EC1                 clr     P11             ; Port 1
code:00000EC3
code:00000EC3 OffHookForAbort:                        ; CODE XREF: ConnectOriginate+8↓j
code:00000EC3                 clr     P10             ; Port 1
code:00000EC5
code:00000EC5
code:00000EC5                 acall   ProgramTimer0TenthSecond ; 0.1s
code:00000EC7
code:00000EC7
code:00000EC7                 mov     TerminalState, #22
code:00000ECA
code:00000ECA TaskState22:                            ; CODE XREF: PerformState+33↑j
code:00000ECA                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000ECA                                         ; Bit 1 = BREAK is tracked as pressed
code:00000ECA                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000ECA                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000ECA                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000ECA                                         ;         handler uses this to look for timeouts in each state.
code:00000ECA                                         ; Bit 4 = Use immediate dial buffer
code:00000ECA                                         ; Bit 5 = Dial voice
code:00000ECA                                         ; Bit 6 = Disabling/Enabling a setting
code:00000ECA                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000ECD                 clr     T0              ; Port 3
code:00000ECF
code:00000ECF
code:00000ECF                 jnb     FormatStatus.0, GoOnline ; Bit 0 = Ctrl-F1 pressed
code:00000ECF                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000ECF                                         ; Bit 2 = In graphics mode
code:00000ED2                 sjmp    AbortDial
code:00000ED4 ; ---------------------------------------------------------------------------
code:00000ED4
code:00000ED4 ;
code:00000ED4 ; State 23 - Go online.  Remain until externally reset.  If we are
code:00000ED4 ; in the menu, clear the screen and return to normal input.
code:00000ED4 ;
code:00000ED4
code:00000ED4 GoOnline:                               ; CODE XREF: PerformState+1C8↑j
code:00000ED4                 mov     TerminalState, #23
code:00000ED7                 setb    VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000ED7                                         ; Bit 1 = Receive buffer is full
code:00000ED7                                         ; Bit 3 = Serial send register busy
code:00000ED7                                         ; Bit 4 = Busy drawing to screen
code:00000ED7                                         ; Bit 5 = Steady/Blink
code:00000ED7                                         ; Bit 6 = Disable keyboard
code:00000ED7                                         ; Bit 7 = Standard/Graphics
code:00000ED9
code:00000ED9 TermState23:                            ; CODE XREF: PerformState+35↑j
code:00000ED9                 ret
code:00000EDA ; ---------------------------------------------------------------------------
code:00000EDA
code:00000EDA HangUpModem:                            ; CODE XREF: PerformState+BE↑j
code:00000EDA                                         ; PerformState+15A↑j ...
code:00000EDA                 setb    T0              ; Port 3
code:00000EDC                 acall   ProgramTimer0TenthSecond ; 0.1s
code:00000EDE
code:00000EDE
code:00000EDE                 mov     TerminalState, #24
code:00000EE1
code:00000EE1 ;
code:00000EE1 ; State 24:  Wait for a period of time, hang up the modem,
code:00000EE1 ; and move to state 0
code:00000EE1 ;
code:00000EE1
code:00000EE1 TermState24:                            ; CODE XREF: PerformState+37↑j
code:00000EE1                 jb      TimerStatus.3, Done ; Bit 0 = ESC is tracked as pressed
code:00000EE1                                         ; Bit 1 = BREAK is tracked as pressed
code:00000EE1                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000EE1                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000EE1                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000EE1                                         ;         handler uses this to look for timeouts in each state.
code:00000EE1                                         ; Bit 4 = Use immediate dial buffer
code:00000EE1                                         ; Bit 5 = Dial voice
code:00000EE1                                         ; Bit 6 = Disabling/Enabling a setting
code:00000EE1                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000EE4
code:00000EE4
code:00000EE4                 setb    P10             ; Modem to on-hook (hung up) state
code:00000EE6                 clr     VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00000EE6                                         ; Bit 1 = Receive buffer is full
code:00000EE6                                         ; Bit 3 = Serial send register busy
code:00000EE6                                         ; Bit 4 = Busy drawing to screen
code:00000EE6                                         ; Bit 5 = Steady/Blink
code:00000EE6                                         ; Bit 6 = Disable keyboard
code:00000EE6                                         ; Bit 7 = Standard/Graphics
code:00000EE8                 ajmp    ResetRingCount
code:00000EE8 ; End of function PerformState
code:00000EE8
code:00000EEA
code:00000EEA ; =============== S U B R O U T I N E =======================================
code:00000EEA
code:00000EEA ; 0.1s
code:00000EEA
code:00000EEA ProgramTimer0TenthSecond:               ; CODE XREF: PerformState+67↑p
code:00000EEA                                         ; PerformState+CF↑p ...
code:00000EEA                 mov     A, #5
code:00000EEC                 ajmp    ProgramTimer0A  ; The total duration is A
code:00000EEC ; End of function ProgramTimer0TenthSecond
code:00000EEC
code:00000EEE
code:00000EEE ; =============== S U B R O U T I N E =======================================
code:00000EEE
code:00000EEE ; 1s
code:00000EEE
code:00000EEE ProgramTimer0OneSecond:                 ; CODE XREF: PerformState:Wait1sThenDetectCarrier↑p
code:00000EEE                                         ; PerformState+119↑p
code:00000EEE                 mov     A, #50
code:00000EF0                 ajmp    ProgramTimer0A  ; The total duration is A
code:00000EF0 ; End of function ProgramTimer0OneSecond
code:00000EF0
code:00000EF2
code:00000EF2 ; =============== S U B R O U T I N E =======================================
code:00000EF2
code:00000EF2 ; 2.5s
code:00000EF2
code:00000EF2 ProgramTimer0TwoHalfSecond:             ; CODE XREF: PerformState:CarrierDetected↑p
code:00000EF2                                         ; PerformState+FB↑p ...
code:00000EF2                 mov     A, #125
code:00000EF4                 ajmp    ProgramTimer0A  ; The total duration is A
code:00000EF4 ; End of function ProgramTimer0TwoHalfSecond
code:00000EF4
code:00000EF6
code:00000EF6 ; =============== S U B R O U T I N E =======================================
code:00000EF6
code:00000EF6 ; 5s
code:00000EF6
code:00000EF6 ProgramTimer5seconds:                   ; CODE XREF: PerformState:WaitForRing↑p
code:00000EF6                                         ; PerformState:DetectCarrier↑p
code:00000EF6                 mov     A, #250
code:00000EF8
code:00000EF8 ProgramTimer0A:                         ; CODE XREF: PerformState+123↑p
code:00000EF8                                         ; PerformState+12F↑p ...
code:00000EF8                 mov     B, #1           ; The total duration is A
code:00000EF8 ; End of function ProgramTimer5seconds
code:00000EF8
code:00000EFB
code:00000EFB ; =============== S U B R O U T I N E =======================================
code:00000EFB
code:00000EFB ; A and B are multipliers.  The total duration is A*B/50
code:00000EFB ; seconds
code:00000EFB
code:00000EFB ProgramTimer0:                          ; CODE XREF: PerformState+5C↑p
code:00000EFB                                         ; PerformState+B3↑p ...
code:00000EFB                 clr     TR0             ; Timer 0/1 Control Register
code:00000EFD                 mov     T0MultA, A      ; Timer 0 frequency
code:00000EFF                 mov     T0MultB, B      ; Number of times T0 will expire before it is shut down
code:00000F02                 mov     T0MultACnt, T0MultA ; Timer 0 frequency
code:00000F05
code:00000F05
code:00000F05                 setb    TimerStatus.3   ; Bit 0 = ESC is tracked as pressed
code:00000F05                                         ; Bit 1 = BREAK is tracked as pressed
code:00000F05                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000F05                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000F05                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000F05                                         ;         handler uses this to look for timeouts in each state.
code:00000F05                                         ; Bit 4 = Use immediate dial buffer
code:00000F05                                         ; Bit 5 = Dial voice
code:00000F05                                         ; Bit 6 = Disabling/Enabling a setting
code:00000F05                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000F07
code:00000F07
code:00000F07                 mov     TMOD, #0x21     ; T1 8 bit auto-reload.  T0 16-bit
code:00000F0A                 mov     TL0, #0         ; Timer 0, Low Byte
code:00000F0D                 mov     TH0, #214       ; Program timer 0 for just short of 50Hz
code:00000F10                 setb    TR0             ; Timer 0/1 Control Register
code:00000F12                 ret
code:00000F12 ; End of function ProgramTimer0
code:00000F12
code:00000F13 ; ---------------------------------------------------------------------------
code:00000F13 ; START OF FUNCTION CHUNK FOR PerformState
code:00000F13
code:00000F13 SetupForDialing:                        ; CODE XREF: PerformState+1A6↑j
code:00000F13                                         ; PerformState+1AC↑j ...
code:00000F13                 jnb     TimerStatus.4, GetFromPhoneBook ; Bit 0 = ESC is tracked as pressed
code:00000F13                                         ; Bit 1 = BREAK is tracked as pressed
code:00000F13                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00000F13                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00000F13                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00000F13                                         ;         handler uses this to look for timeouts in each state.
code:00000F13                                         ; Bit 4 = Use immediate dial buffer
code:00000F13                                         ; Bit 5 = Dial voice
code:00000F13                                         ; Bit 6 = Disabling/Enabling a setting
code:00000F13                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00000F16                 mov     DPTR, #DialMiscBuffer
code:00000F19
code:00000F19 HaveNumber:                             ; CODE XREF: PerformState+231↓j
code:00000F19                 mov     R0, #(DigitsToDial & 0xFF) ; This buffer holds the digits that are currently being
code:00000F19                                         ; dialed.  The dial reader marks them out one by one as
code:00000F19                                         ; each digit is rendered to the phone line.
code:00000F1B                 mov     R1, #(DigitsToDial >> 8) ; This buffer holds the digits that are currently being
code:00000F1B                                         ; dialed.  The dial reader marks them out one by one as
code:00000F1B                                         ; each digit is rendered to the phone line.
code:00000F1D
code:00000F1D CopyNumberToDialMemLoop:                ; CODE XREF: PerformState:code_F2F↓j
code:00000F1D                 movx    A, @DPTR
code:00000F1E                 inc     DPTR
code:00000F1F                 anl     A, #0xF
code:00000F21                 push    IE              ; Interrupt Enable Register
code:00000F23                 clr     EA              ; Interrupt Enable Register
code:00000F25                 mov     P2, R1          ; Port 2
code:00000F27                 movx    @R0, A
code:00000F28                 pop     IE              ; Interrupt Enable Register
code:00000F2A                 inc     R0
code:00000F2B                 cjne    R0, #0, code_F2F
code:00000F2E
code:00000F2E
code:00000F2E                 inc     R1
code:00000F2F
code:00000F2F code_F2F:                               ; CODE XREF: PerformState+224↑j
code:00000F2F                 jnz     CopyNumberToDialMemLoop
code:00000F31
code:00000F31
code:00000F31                 jb      FormatStatus.0, TurnOffAnswerMode ; Bit 0 = Ctrl-F1 pressed
code:00000F31                                         ; Bit 1 = Save of Disable Status Bar flag
code:00000F31                                         ; Bit 2 = In graphics mode
code:00000F34                 ajmp    BeginDialing
code:00000F36 ; ---------------------------------------------------------------------------
code:00000F36
code:00000F36 GetFromPhoneBook:                       ; CODE XREF: PerformState:SetupForDialing↑j
code:00000F36                 acall   FindNthDirectoryEntry ; TmpI = entry number
code:00000F36                                         ;
code:00000F36                                         ; On return:
code:00000F36                                         ;
code:00000F36                                         ; A = entry type
code:00000F36                                         ; DPTR = entry address
code:00000F36                                         ; TmpI is destroyed
code:00000F38                 jnc     HaveNumber
code:00000F3A
code:00000F3A
code:00000F3A                 ajmp    ResetRingCount
code:00000F3A ; END OF FUNCTION CHUNK FOR PerformState
code:00000F3C
code:00000F3C ; =============== S U B R O U T I N E =======================================
code:00000F3C
code:00000F3C ; TmpI = entry number
code:00000F3C ;
code:00000F3C ; On return:
code:00000F3C ;
code:00000F3C ; A = entry type
code:00000F3C ; DPTR = entry address
code:00000F3C ; TmpI is destroyed
code:00000F3C
code:00000F3C FindNthDirectoryEntry:                  ; CODE XREF: PerformState:GetFromPhoneBook↑p
code:00000F3C                                         ; UnpackDialScript+8↓p ...
code:00000F3C                 mov     DPTR, #DirectoryStart
code:00000F3F                 movx    A, @DPTR
code:00000F40                 anl     A, #0xF
code:00000F42                 inc     DPTR
code:00000F43
code:00000F43
code:00000F43                 ajmp    FindEntryNext
code:00000F45 ; ---------------------------------------------------------------------------
code:00000F45
code:00000F45 FindEntryLoop:                          ; CODE XREF: FindNthDirectoryEntry:FindEntryNext↓j
code:00000F45                 acall   ToEndOfEncodedPhoneNumber ; Finds the end of a string of phone number digits which are
code:00000F45                                         ; encoded in nibble form
code:00000F47                 acall   ToEndOfEncodedText ; Finds the end of a string which has been encoded in nibble
code:00000F47                                         ; form
code:00000F49                 acall   ToEndOfEncodedText ; Finds the end of a string which has been encoded in nibble
code:00000F49                                         ; form
code:00000F4B
code:00000F4B FindEntryNext:                          ; CODE XREF: FindNthDirectoryEntry+7↑j
code:00000F4B                 djnz    TmpI, FindEntryLoop ; Often the phone book entry number, but can also be used as
code:00000F4B                                         ; settings index
code:00000F4E                 ret
code:00000F4E ; End of function FindNthDirectoryEntry
code:00000F4E
code:00000F4F
code:00000F4F ; =============== S U B R O U T I N E =======================================
code:00000F4F
code:00000F4F
code:00000F4F FindNibbleStringHighBitLoop:            ; CODE XREF: FindNibbleStringHighBitLoop+5↓j
code:00000F4F                 inc     DPTR
code:00000F50
code:00000F50 ToEndOfEncodedText:                     ; CODE XREF: FindNthDirectoryEntry+B↑p
code:00000F50                                         ; FindNthDirectoryEntry+D↑p ...
code:00000F50                 movx    A, @DPTR        ; Finds the end of a string which has been encoded in nibble
code:00000F50                                         ; form
code:00000F51                 inc     DPTR
code:00000F52                 anl     A, #0xF
code:00000F54                 jnb     ACC3, FindNibbleStringHighBitLoop ; Accumulator
code:00000F57                 ret
code:00000F57 ; End of function FindNibbleStringHighBitLoop
code:00000F57
code:00000F58
code:00000F58 ; =============== S U B R O U T I N E =======================================
code:00000F58
code:00000F58 ; Finds the end of a string of phone number digits which are
code:00000F58 ; encoded in nibble form
code:00000F58
code:00000F58 ToEndOfEncodedPhoneNumber:              ; CODE XREF: FindNthDirectoryEntry:FindEntryLoop↑p
code:00000F58                                         ; ToEndOfEncodedPhoneNumber+4↓j ...
code:00000F58                 movx    A, @DPTR
code:00000F59                 inc     DPTR
code:00000F5A                 anl     A, #0xF
code:00000F5C                 jnz     ToEndOfEncodedPhoneNumber ; Finds the end of a string of phone number digits which are
code:00000F5C                                         ; encoded in nibble form
code:00000F5E                 ret
code:00000F5E ; End of function ToEndOfEncodedPhoneNumber
code:00000F5E
code:00000F5F
code:00000F5F ; =============== S U B R O U T I N E =======================================
code:00000F5F
code:00000F5F ; This is a destructive read of DigitsToDial.  Every time it
code:00000F5F ; returns a digit, it also destroys that digit so that the
code:00000F5F ; next call will return the following digit.  Just use a
code:00000F5F ; cursor?  Nah.
code:00000F5F
code:00000F5F GetNextDigitToDial:                     ; CODE XREF: PerformState:LoadNextDialDigit↑p
code:00000F5F                 mov     DPTR, #DigitsToDial ; This buffer holds the digits that are currently being
code:00000F5F                                         ; dialed.  The dial reader marks them out one by one as
code:00000F5F                                         ; each digit is rendered to the phone line.
code:00000F62
code:00000F62 SkipCrossedOffDigitsLoop:               ; CODE XREF: GetNextDigitToDial+A↓j
code:00000F62                 movx    A, @DPTR
code:00000F63                 anl     A, #0xF
code:00000F65                 cjne    A, #0xF, TestEndOfDigits
code:00000F68
code:00000F68 ;
code:00000F68 ; Ignore 0xF
code:00000F68 ;
code:00000F68                 inc     DPTR
code:00000F69                 sjmp    SkipCrossedOffDigitsLoop
code:00000F6B ; ---------------------------------------------------------------------------
code:00000F6B
code:00000F6B TestEndOfDigits:                        ; CODE XREF: GetNextDigitToDial+6↑j
code:00000F6B                 jz      Done
code:00000F6D
code:00000F6D ;
code:00000F6D ; Mark the selected byte as 0xF so it will be skipped next
code:00000F6D ; time
code:00000F6D ;
code:00000F6D                 push    ACC             ; Accumulator
code:00000F6F                 mov     A, #0xF
code:00000F71                 movx    @DPTR, A
code:00000F72                 pop     ACC             ; Accumulator
code:00000F74
code:00000F74 Done:                                   ; CODE XREF: GetNextDigitToDial:TestEndOfDigits↑j
code:00000F74                 ret
code:00000F74 ; End of function GetNextDigitToDial
code:00000F74
code:00000F74 ; ---------------------------------------------------------------------------
code:00000F75 aAnswerVoiceCal:.text "Answer Voice call, press RETURN "
code:00000F75                                         ; DATA XREF: PerformState+A1↑o
code:00000F75                 .byte 0
code:00000F96 aPressHelp:     .text "Press HELP"      ; DATA XREF: UpdateStatusLine+1B↑o
code:00000F96                 .byte 0
code:00000FA1 aPressQuitToExi:.text "Press QUIT to exit"
code:00000FA1                                         ; DATA XREF: UpdateStatusLine:PressQUIT↑o
code:00000FA1                 .byte 0
code:00000FB4 aONLINE:        .byte 0x90              ; DATA XREF: UpdateStatusLine:PrintOnlineTopLine↑o
code:00000FB5                 .text "ON LINE"
code:00000FBC                 .byte 0x80,0x20,   0
code:00000FBF aOFFLINE:       .byte 0x80              ; DATA XREF: UpdateStatusLine+2A↑o
code:00000FC0                 .text "OFF LINE"
code:00000FC8                 .byte 0x80,   0
code:00000FCA aDialing:       .byte 0x92              ; DATA XREF: PerformState+F1↑o
code:00000FCB                 .text "DIALING"
code:00000FD2                 .byte 0x80,0x20,   0
code:00000FD5 aWait:          .byte 0x90              ; DATA XREF: PerformState+14C↑o
code:00000FD6                 .text "WAIT"
code:00000FD6                 .byte 0
code:00000FDB aPrinter:       .byte 0x90              ; DATA XREF: ModifySetting+53↑o
code:00000FDC                 .text "Printer"
code:00000FE3                 .byte 0x80,   0
code:00000FE5 aSpaces:        .byte 0x80              ; DATA XREF: ModifySetting:ForceWritePrintStatus↑o
code:00000FE6                 .text "       "
code:00000FED                 .byte 0x80,0x20,   0
code:00000FF0                 .byte    0
code:00000FF1                 .byte    0
code:00000FF2                 .byte    0
code:00000FF3                 .byte    0
code:00000FF4                 .byte    0
code:00000FF5                 .byte    0
code:00000FF6                 .byte    0
code:00000FF7                 .byte    0
code:00000FF8                 .byte    0
code:00000FF9                 .byte    0
code:00000FFA                 .byte    0
code:00000FFB                 .byte    0
code:00000FFC                 .byte    0
code:00000FFD                 .byte    0
code:00000FFE                 .byte    0
code:00000FFF                 .byte    0
code:00001000 ; [00000002 BYTES: COLLAPSED FUNCTION TerminalEntry. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001002 ; [00000001 BYTES: COLLAPSED FUNCTION nullsub_3. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001003 ; [00000003 BYTES: COLLAPSED FUNCTION j_WaitForSerialInput. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001006 ; [00000003 BYTES: COLLAPSED FUNCTION j_TypeCharAsIs. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001009 ; [00000003 BYTES: COLLAPSED FUNCTION j_PrintDPTRPrefixedHiBtTermString. PRESS CTRL-NUMPAD+ TO EXPAND]
code:0000100C ; [00000003 BYTES: COLLAPSED FUNCTION j_DecrementDPTR. PRESS CTRL-NUMPAD+ TO EXPAND]
code:0000100F
code:0000100F ; =============== S U B R O U T I N E =======================================
code:0000100F
code:0000100F
code:0000100F TerminalLoop:                           ; CODE XREF: TerminalEntry↑j
code:0000100F                                         ; TerminalLoop:CheckMenuRequest↓j ...
code:0000100F                 lcall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:0000100F                                         ; needed.
code:0000100F                                         ;
code:0000100F                                         ; At return:
code:0000100F                                         ;
code:0000100F                                         ; A = next character
code:0000100F                                         ; C = next character is valid
code:00001012                 jnc     CheckShiftQUIT
code:00001014
code:00001014
code:00001014                 lcall   ProcessInputWithContextFunction ; If printing, first sends the character to the printer.  Then if the
code:00001014                                         ; character is CANCEL, returns to normal typing mode instead.
code:00001014                                         ; Otherwise calls the current context function to handle the keypress.
code:00001017
code:00001017 ;
code:00001017 ; If Shift-QUIT (BREAK) is being held down, handle the interrupt
code:00001017 ; signal
code:00001017 ;
code:00001017
code:00001017 CheckShiftQUIT:                         ; CODE XREF: TerminalLoop+3↑j
code:00001017                 jnb     TimerStatus.1, CheckSerialOutput ; Bit 0 = ESC is tracked as pressed
code:00001017                                         ; Bit 1 = BREAK is tracked as pressed
code:00001017                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001017                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001017                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001017                                         ;         handler uses this to look for timeouts in each state.
code:00001017                                         ; Bit 4 = Use immediate dial buffer
code:00001017                                         ; Bit 5 = Dial voice
code:00001017                                         ; Bit 6 = Disabling/Enabling a setting
code:00001017                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000101A
code:0000101A
code:0000101A                 mov     DPTR, #(KeyboardGrid+5) ; Read keyboard grid row 5
code:0000101D                 movx    A, @DPTR
code:0000101E                 jnb     ACC7, UnbreakMyTerm ; Bit 7 is the QUIT key
code:00001021
code:00001021
code:00001021                 mov     DPTR, #KeyboardShift ; Bit 0 = ESC
code:00001021                                         ; Bit 1 = CAPS lock
code:00001021                                         ; Bit 2 = Ctrl key
code:00001021                                         ; Bit 3 = SHIFT key
code:00001024                 movx    A, @DPTR
code:00001025                 jnb     ACC3, UnbreakMyTerm ; Accumulator
code:00001028
code:00001028 ;
code:00001028 ; Turn off the TxD port, eliminating serial out and signaling an
code:00001028 ; interrupt to the modem
code:00001028 ;
code:00001028                 clr     TxD             ; Port 3
code:0000102A                 ajmp    ChecksDone
code:0000102C ; ---------------------------------------------------------------------------
code:0000102C
code:0000102C UnbreakMyTerm:                          ; CODE XREF: TerminalLoop+F↑j
code:0000102C                                         ; TerminalLoop+16↑j
code:0000102C                 clr     TimerStatus.1   ; Bit 0 = ESC is tracked as pressed
code:0000102C                                         ; Bit 1 = BREAK is tracked as pressed
code:0000102C                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000102C                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000102C                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000102C                                         ;         handler uses this to look for timeouts in each state.
code:0000102C                                         ; Bit 4 = Use immediate dial buffer
code:0000102C                                         ; Bit 5 = Dial voice
code:0000102C                                         ; Bit 6 = Disabling/Enabling a setting
code:0000102C                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000102E
code:0000102E ;
code:0000102E ; Turn on TxD port to resume serial output
code:0000102E ;
code:0000102E                 setb    TxD             ; Set P3.1 to TXD function
code:00001030
code:00001030 ;
code:00001030 ; First check if online.  If so, see if the serial output register is
code:00001030 ; busy.  If it's ready, send the next available serial output char
code:00001030 ;
code:00001030
code:00001030 CheckSerialOutput:                      ; CODE XREF: TerminalLoop:CheckShiftQUIT↑j
code:00001030                 jnb     VideoSettings.0, ChecksDone ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001030                                         ; Bit 1 = Receive buffer is full
code:00001030                                         ; Bit 3 = Serial send register busy
code:00001030                                         ; Bit 4 = Busy drawing to screen
code:00001030                                         ; Bit 5 = Steady/Blink
code:00001030                                         ; Bit 6 = Disable keyboard
code:00001030                                         ; Bit 7 = Standard/Graphics
code:00001033
code:00001033
code:00001033                 clr     EA              ; Interrupt Enable Register
code:00001035                 jb      VideoSettings.3, DoneSerialOutput ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001035                                         ; Bit 1 = Receive buffer is full
code:00001035                                         ; Bit 3 = Serial send register busy
code:00001035                                         ; Bit 4 = Busy drawing to screen
code:00001035                                         ; Bit 5 = Steady/Blink
code:00001035                                         ; Bit 6 = Disable keyboard
code:00001035                                         ; Bit 7 = Standard/Graphics
code:00001038
code:00001038
code:00001038                 lcall   GetNextSerialOutChar ; On return:
code:00001038                                         ; A = char
code:00001038                                         ; C = set if char valid
code:0000103B                 jnc     DoneSerialOutput
code:0000103D
code:0000103D
code:0000103D                 setb    VideoSettings.3 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000103D                                         ; Bit 1 = Receive buffer is full
code:0000103D                                         ; Bit 3 = Serial send register busy
code:0000103D                                         ; Bit 4 = Busy drawing to screen
code:0000103D                                         ; Bit 5 = Steady/Blink
code:0000103D                                         ; Bit 6 = Disable keyboard
code:0000103D                                         ; Bit 7 = Standard/Graphics
code:0000103F                 mov     SBUF, A         ; Serial Channel Buffer Register
code:00001041
code:00001041 DoneSerialOutput:                       ; CODE XREF: TerminalLoop+26↑j
code:00001041                                         ; TerminalLoop+2C↑j
code:00001041                 setb    EA              ; Interrupt Enable Register
code:00001043
code:00001043 ChecksDone:                             ; CODE XREF: TerminalLoop+1B↑j
code:00001043                                         ; TerminalLoop:CheckSerialOutput↑j
code:00001043                 lcall   PerformState
code:00001046
code:00001046
code:00001046                 lcall   UpdateStatusLine
code:00001049
code:00001049 ;
code:00001049 ; See if the printer status is marked for update
code:00001049 ;
code:00001049                 jnb     PrinterStatus.2, CheckMenuRequest ; Bit 0 = Printer
code:00001049                                         ; Bit 1 = Need to send XOFF
code:00001049                                         ; Bit 2 = Toggle printer state
code:00001049                                         ; Bit 3 = No writes to status line
code:00001049                                         ;         No update of time or print status.  Set cursor position ESC
code:00001049                                         ;         code cannot set cursor to row 1
code:00001049                                         ; Bit 4 = No writes to status line
code:00001049                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00001049                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00001049                                         ;         position to row 1
code:00001049                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00001049                                         ; Bit 6 = Key pressed
code:00001049                                         ; Bit 7 = Repeat eligible
code:0000104C                 lcall   TogglePrinterStatus
code:0000104F
code:0000104F ;
code:0000104F ; See if the menu has been requested
code:0000104F ;
code:0000104F
code:0000104F CheckMenuRequest:                       ; CODE XREF: TerminalLoop+3A↑j
code:0000104F                 jnb     PrinterStatus.5, TerminalLoop ; Bit 0 = Printer
code:0000104F                                         ; Bit 1 = Need to send XOFF
code:0000104F                                         ; Bit 2 = Toggle printer state
code:0000104F                                         ; Bit 3 = No writes to status line
code:0000104F                                         ;         No update of time or print status.  Set cursor position ESC
code:0000104F                                         ;         code cannot set cursor to row 1
code:0000104F                                         ; Bit 4 = No writes to status line
code:0000104F                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:0000104F                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:0000104F                                         ;         position to row 1
code:0000104F                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:0000104F                                         ; Bit 6 = Key pressed
code:0000104F                                         ; Bit 7 = Repeat eligible
code:00001052                 acall   ConnectMenuEntry
code:00001054
code:00001054
code:00001054                 clr     PrinterStatus.5 ; Bit 0 = Printer
code:00001054                                         ; Bit 1 = Need to send XOFF
code:00001054                                         ; Bit 2 = Toggle printer state
code:00001054                                         ; Bit 3 = No writes to status line
code:00001054                                         ;         No update of time or print status.  Set cursor position ESC
code:00001054                                         ;         code cannot set cursor to row 1
code:00001054                                         ; Bit 4 = No writes to status line
code:00001054                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
code:00001054                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
code:00001054                                         ;         position to row 1
code:00001054                                         ; Bit 5 = 1=MENU, 0=TERMINAL
code:00001054                                         ; Bit 6 = Key pressed
code:00001054                                         ; Bit 7 = Repeat eligible
code:00001056
code:00001056 ;
code:00001056 ; See if a directory entry has been selected
code:00001056 ;
code:00001056                 mov     A, DirEntryType
code:00001058                 jnb     ACC7, TerminalLoop ; Accumulator
code:0000105B
code:0000105B
code:0000105B                 lcall   UpdateStatusLine
code:0000105E
code:0000105E
code:0000105E                 acall   UnpackDialScript ; Copies the chosen phone book entry's script to scratch
code:0000105E                                         ; space while adding the responses.  This preparation allows
code:0000105E                                         ; the script to be executed with minimal effort.
code:00001060
code:00001060 NextScriptChar:                         ; CODE XREF: TerminalLoop+71↓j
code:00001060                                         ; TerminalLoop+9A↓j ...
code:00001060                 inc     DPTR
code:00001061
code:00001061 ContinueToWait:                         ; CODE XREF: TerminalLoop+82↓j
code:00001061                                         ; TerminalLoop+A1↓j
code:00001061                 jb      P15, StillConnected ; Port 1
code:00001064
code:00001064 LostConnection:                         ; CODE XREF: TerminalLoop:StillConnected↓j
code:00001064                                         ; TerminalLoop+60↓j ...
code:00001064                 mov     DirEntryType, #0
code:00001067
code:00001067
code:00001067                 acall   j_ForceStatusLineUpdate
code:00001069                 sjmp    TerminalLoop
code:0000106B ; ---------------------------------------------------------------------------
code:0000106B
code:0000106B StillConnected:                         ; CODE XREF: TerminalLoop:ContinueToWait↑j
code:0000106B                 jnb     VideoSettings.0, LostConnection ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000106B                                         ; Bit 1 = Receive buffer is full
code:0000106B                                         ; Bit 3 = Serial send register busy
code:0000106B                                         ; Bit 4 = Busy drawing to screen
code:0000106B                                         ; Bit 5 = Steady/Blink
code:0000106B                                         ; Bit 6 = Disable keyboard
code:0000106B                                         ; Bit 7 = Standard/Graphics
code:0000106E                 movx    A, @DPTR
code:0000106F                 jz      LostConnection
code:00001071
code:00001071
code:00001071                 cjne    A, #0xFF, PrintScript
code:00001074
code:00001074 ;
code:00001074 ; FF character means long pause
code:00001074 ;
code:00001074                 mov     R0, #2
code:00001076
code:00001076 LongDelayLoopL1:                        ; CODE XREF: TerminalLoop+6F↓j
code:00001076                 mov     R1, #0
code:00001078
code:00001078 LongDelayLoopL2:                        ; CODE XREF: TerminalLoop+6D↓j
code:00001078                 mov     R2, #0
code:0000107A
code:0000107A LongDelayLoopL3:                        ; CODE XREF: TerminalLoop:LongDelayLoopL3↓j
code:0000107A                 djnz    R2, LongDelayLoopL3
code:0000107C                 djnz    R1, LongDelayLoopL2
code:0000107E                 djnz    R0, LongDelayLoopL1
code:00001080
code:00001080
code:00001080                 sjmp    NextScriptChar
code:00001082 ; ---------------------------------------------------------------------------
code:00001082
code:00001082 ;
code:00001082 ; When the high bit is set, this is data to send.
code:00001082 ; Otherwise it is data to wait for.
code:00001082 ;
code:00001082
code:00001082 PrintScript:                            ; CODE XREF: TerminalLoop+62↑j
code:00001082                 jb      ACC7, SendByte  ; Accumulator
code:00001085
code:00001085
code:00001085                 mov     R3, A
code:00001086
code:00001086
code:00001086                 push    DPL             ; Data Pointer, Low Byte
code:00001088                 push    DPH             ; Data Pointer, High Byte
code:0000108A                 lcall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:0000108A                                         ; needed.
code:0000108A                                         ;
code:0000108A                                         ; At return:
code:0000108A                                         ;
code:0000108A                                         ; A = next character
code:0000108A                                         ; C = next character is valid
code:0000108D                 pop     DPH             ; Data Pointer, High Byte
code:0000108F                 pop     DPL             ; Data Pointer, Low Byte
code:00001091                 jnc     ContinueToWait
code:00001093
code:00001093
code:00001093                 push    ACC             ; Accumulator
code:00001095                 push    DPL             ; Data Pointer, Low Byte
code:00001097                 push    DPH             ; Data Pointer, High Byte
code:00001099                 push    B0R3
code:0000109B                 lcall   ProcessInputWithContextFunction ; If printing, first sends the character to the printer.  Then if the
code:0000109B                                         ; character is CANCEL, returns to normal typing mode instead.
code:0000109B                                         ; Otherwise calls the current context function to handle the keypress.
code:0000109E                 pop     B0R3
code:000010A0                 pop     DPH             ; Data Pointer, High Byte
code:000010A2                 pop     DPL             ; Data Pointer, Low Byte
code:000010A4                 pop     ACC             ; Accumulator
code:000010A6                 cjne    A, B0R3, NoPromptMatch
code:000010A9
code:000010A9
code:000010A9                 sjmp    NextScriptChar
code:000010AB ; ---------------------------------------------------------------------------
code:000010AB
code:000010AB ;
code:000010AB ; Input has not matched all of the prompt string.  Rewind
code:000010AB ; and wait again.
code:000010AB ;
code:000010AB
code:000010AB NoPromptMatch:                          ; CODE XREF: TerminalLoop+97↑j
code:000010AB                                         ; TerminalLoop+A6↓j
code:000010AB                 mov     A, DPL          ; Data Pointer, Low Byte
code:000010AD                 cjne    A, #(DialMiscBuffer & 0xFF), ReturnToPromptStart ; Don't rewind past the beginning
code:000010B0
code:000010B0
code:000010B0                 sjmp    ContinueToWait
code:000010B2 ; ---------------------------------------------------------------------------
code:000010B2
code:000010B2 ReturnToPromptStart:                    ; CODE XREF: TerminalLoop+9E↑j
code:000010B2                 acall   j_DecrementDPTR
code:000010B4                 movx    A, @DPTR
code:000010B5                 jnb     ACC7, NoPromptMatch ; Accumulator
code:000010B8
code:000010B8
code:000010B8                 sjmp    NextScriptChar
code:000010BA ; ---------------------------------------------------------------------------
code:000010BA
code:000010BA SendByte:                               ; CODE XREF: TerminalLoop:PrintScript↑j
code:000010BA                 clr     ACC7            ; Accumulator
code:000010BC                 cjne    A, #'., SendResponseChar
code:000010BF
code:000010BF
code:000010BF                 sjmp    LostConnection
code:000010C1 ; ---------------------------------------------------------------------------
code:000010C1
code:000010C1 SendResponseChar:                       ; CODE XREF: TerminalLoop+AD↑j
code:000010C1                 lcall   SafeSerialSend  ; Waits until serial buffer is empty before sending next
code:000010C1                                         ; character
code:000010C4                 sjmp    NextScriptChar
code:000010C4 ; End of function TerminalLoop
code:000010C4
code:000010C6
code:000010C6 ; =============== S U B R O U T I N E =======================================
code:000010C6
code:000010C6 ; Copies the chosen phone book entry's script to scratch
code:000010C6 ; space while adding the responses.  This preparation allows
code:000010C6 ; the script to be executed with minimal effort.
code:000010C6
code:000010C6 UnpackDialScript:                       ; CODE XREF: TerminalLoop+4F↑p
code:000010C6                 mov     R0, #(DialMiscBuffer & 0xFF)
code:000010C8                 mov     R1, #(DialMiscBuffer >> 8)
code:000010CA
code:000010CA
code:000010CA                 mov     A, DirEntryNumber
code:000010CC                 mov     TmpI, A         ; Often the phone book entry number, but can also be used as
code:000010CC                                         ; settings index
code:000010CE                 lcall   FindNthDirectoryEntry ; TmpI = entry number
code:000010CE                                         ;
code:000010CE                                         ; On return:
code:000010CE                                         ;
code:000010CE                                         ; A = entry type
code:000010CE                                         ; DPTR = entry address
code:000010CE                                         ; TmpI is destroyed
code:000010D1                 lcall   ToEndOfEncodedPhoneNumber ; Skip the digits
code:000010D4                 lcall   ToEndOfEncodedText ; And the name
code:000010D7                 mov     DialScriptDataPtr, DPL ; Save the start of the scripting data input
code:000010DA                 mov     DialScriptDataPtr+1, DPH ; Data Pointer, High Byte
code:000010DD
code:000010DD
code:000010DD                 acall   LookupDialTypeScript ; Find out what kind of script will be run
code:000010DF
code:000010DF ScriptingLoop:                          ; CODE XREF: UnpackDialScript+2D↓j
code:000010DF                                         ; UnpackDialScript+40↓j ...
code:000010DF                 acall   GetNextNibbleFromByteString ; uses DialStringCursor and DPTR to get next nibble from a byte string
code:000010E1                 jnz     PromptType
code:000010E3
code:000010E3
code:000010E3                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000010E3                                         ;
code:000010E3                                         ; R1:R0 = destination
code:000010E3                                         ; A = character
code:000010E3                                         ;
code:000010E3                                         ; Auto-increments R1:R0
code:000010E5
code:000010E5
code:000010E5                 mov     DPTR, #(DialMiscBuffer-1)
code:000010E8                 ret
code:000010E9 ; ---------------------------------------------------------------------------
code:000010E9
code:000010E9 j_PutCharToVRAM:                        ; CODE XREF: UnpackDialScript+1D↑p
code:000010E9                                         ; UnpackDialScript+2B↓p ...
code:000010E9                 ljmp    PrintCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000010E9                                         ;
code:000010E9                                         ; R1:R0 = destination
code:000010E9                                         ; A = character
code:000010E9                                         ;
code:000010E9                                         ; Auto-increments R1:R0
code:000010EC ; ---------------------------------------------------------------------------
code:000010EC
code:000010EC ;
code:000010EC ; Translate 0xF to 0xFF
code:000010EC ;
code:000010EC
code:000010EC PromptType:                             ; CODE XREF: UnpackDialScript+1B↑j
code:000010EC                 cjne    A, #0xF, TestPrompt
code:000010EF
code:000010EF ;
code:000010EF ; F means pause
code:000010EF ;
code:000010EF                 mov     A, #0xFF
code:000010F1                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000010F1                                         ;
code:000010F1                                         ; R1:R0 = destination
code:000010F1                                         ; A = character
code:000010F1                                         ;
code:000010F1                                         ; Auto-increments R1:R0
code:000010F3                 sjmp    ScriptingLoop
code:000010F5 ; ---------------------------------------------------------------------------
code:000010F5
code:000010F5 ;
code:000010F5 ; If the high bit is set, wait for a specific prompt and
code:000010F5 ; then send the response
code:000010F5 ;
code:000010F5
code:000010F5 TestPrompt:                             ; CODE XREF: UnpackDialScript:PromptType↑j
code:000010F5                 jb      ACC3, DoPromptResponse ; Accumulator
code:000010F8
code:000010F8 ;
code:000010F8 ; High bit not set:  Write a string from the script
code:000010F8 ;
code:000010F8
code:000010F8 VerbatimLoop:                           ; CODE XREF: UnpackDialScript+3E↓j
code:000010F8                 push    ACC             ; Accumulator
code:000010FA
code:000010FA
code:000010FA                 mov     A, B            ; B-Register
code:000010FC                 movc    A, @A+DPTR
code:000010FD                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000010FD                                         ;
code:000010FD                                         ; R1:R0 = destination
code:000010FD                                         ; A = character
code:000010FD                                         ;
code:000010FD                                         ; Auto-increments R1:R0
code:000010FF                 pop     ACC             ; Accumulator
code:00001101                 dec     A
code:00001102                 inc     B               ; B-Register
code:00001104                 jnz     VerbatimLoop
code:00001106
code:00001106
code:00001106                 sjmp    ScriptingLoop
code:00001108 ; ---------------------------------------------------------------------------
code:00001108
code:00001108 DoPromptResponse:                       ; CODE XREF: UnpackDialScript:TestPrompt↑j
code:00001108                 clr     ACC3            ; Accumulator
code:0000110A
code:0000110A PromptLoop:                             ; CODE XREF: UnpackDialScript+54↓j
code:0000110A                 jz      CopyResponse
code:0000110C
code:0000110C
code:0000110C                 push    ACC             ; Accumulator
code:0000110E                 mov     A, B            ; B-Register
code:00001110                 movc    A, @A+DPTR
code:00001111                 setb    ACC7            ; Accumulator
code:00001113                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:00001113                                         ;
code:00001113                                         ; R1:R0 = destination
code:00001113                                         ; A = character
code:00001113                                         ;
code:00001113                                         ; Auto-increments R1:R0
code:00001115                 pop     ACC             ; Accumulator
code:00001117                 dec     A
code:00001118                 inc     B               ; B-Register
code:0000111A                 jnz     PromptLoop
code:0000111C                 sjmp    ScriptingLoop
code:0000111E ; ---------------------------------------------------------------------------
code:0000111E
code:0000111E CopyResponse:                           ; CODE XREF: UnpackDialScript:PromptLoop↑j
code:0000111E                 push    DPL             ; Data Pointer, Low Byte
code:00001120                 push    DPH             ; Data Pointer, High Byte
code:00001122                 mov     DPL, DialScriptDataPtr ; Data Pointer, Low Byte
code:00001125                 mov     DPH, DialScriptDataPtr+1 ; Data Pointer, High Byte
code:00001128
code:00001128 CopyResponseLoop:                       ; CODE XREF: UnpackDialScript+6E↓j
code:00001128                 lcall   NibblesToByte   ; Read 2 consecutive nibbles as one byte from DPTR.  This is
code:00001128                                         ; used for name and password text stored in phone book memory.
code:0000112B                 jb      ACC7, CopyResponseDone ; Accumulator
code:0000112E                 jz      CopyResponseDone
code:00001130
code:00001130
code:00001130                 setb    ACC7            ; Accumulator
code:00001132                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:00001132                                         ;
code:00001132                                         ; R1:R0 = destination
code:00001132                                         ; A = character
code:00001132                                         ;
code:00001132                                         ; Auto-increments R1:R0
code:00001134                 sjmp    CopyResponseLoop
code:00001136 ; ---------------------------------------------------------------------------
code:00001136
code:00001136 CopyResponseDone:                       ; CODE XREF: UnpackDialScript+65↑j
code:00001136                                         ; UnpackDialScript+68↑j
code:00001136                 mov     DialScriptDataPtr+1, DPH ; Data Pointer, High Byte
code:00001139                 mov     DialScriptDataPtr, DPL ; Data Pointer, Low Byte
code:0000113C                 pop     DPH             ; Data Pointer, High Byte
code:0000113E                 pop     DPL             ; Data Pointer, Low Byte
code:00001140                 sjmp    ScriptingLoop
code:00001140 ; End of function UnpackDialScript
code:00001140
code:00001142
code:00001142 ; =============== S U B R O U T I N E =======================================
code:00001142
code:00001142 ; uses DialStringCursor and DPTR to get next nibble from a byte string
code:00001142
code:00001142 GetNextNibbleFromByteString:            ; CODE XREF: UnpackDialScript:ScriptingLoop↑p
code:00001142                                         ; EraseAllEntries+109↓p ...
code:00001142                 mov     A, DialStringCursor
code:00001144                 inc     DialStringCursor
code:00001146
code:00001146 ;
code:00001146 ; Calculate the byte half and which nibble to access based on linear
code:00001146 ; counter.  Sample outcomes:
code:00001146 ;   0 - high, offset 1
code:00001146 ;   1 - low, offset 1
code:00001146 ;   2 - high, offset 2
code:00001146 ;   3 - low, offset 2
code:00001146 ;
code:00001146                 clr     C
code:00001147                 rrc     A
code:00001148                 inc     A
code:00001149
code:00001149
code:00001149                 movc    A, @A+DPTR
code:0000114A                 jnc     code_114D
code:0000114C
code:0000114C
code:0000114C                 swap    A
code:0000114D
code:0000114D code_114D:                              ; CODE XREF: GetNextNibbleFromByteString+8↑j
code:0000114D                 swap    A
code:0000114E                 anl     A, #0xF
code:00001150                 ret
code:00001150 ; End of function GetNextNibbleFromByteString
code:00001150
code:00001151
code:00001151 ; =============== S U B R O U T I N E =======================================
code:00001151
code:00001151 ; Stores address of script into DPTR.  Uses DirEntryType to look up
code:00001151 ; script.  Clears DialStringCursor.
code:00001151
code:00001151 LookupDialTypeScript:                   ; CODE XREF: UnpackDialScript+17↑p
code:00001151                                         ; EraseAllEntries+107↓p ...
code:00001151                 mov     DPTR, #DirEntryTypeTable
code:00001154                 mov     A, DirEntryType
code:00001156                 anl     A, #7
code:00001158                 rl      A
code:00001159
code:00001159
code:00001159                 push    ACC             ; Accumulator
code:0000115B                 movc    A, @A+DPTR
code:0000115C                 mov     B, A            ; B-Register
code:0000115E                 inc     DPTR
code:0000115F                 pop     ACC             ; Accumulator
code:00001161                 movc    A, @A+DPTR
code:00001162
code:00001162
code:00001162                 mov     DPL, A          ; Data Pointer, Low Byte
code:00001164                 mov     DPH, B          ; Data Pointer, High Byte
code:00001167
code:00001167
code:00001167                 clr     A
code:00001168                 mov     DialStringCursor, A
code:0000116A
code:0000116A
code:0000116A                 movc    A, @A+DPTR
code:0000116B                 mov     B, A            ; B-Register
code:0000116D
code:0000116D ReturnGate_11:                          ; CODE XREF: ConnectMenu:code_11A4↓j
code:0000116D                 ret
code:0000116D ; End of function LookupDialTypeScript
code:0000116D
code:0000116E ; F1 - MANUAL DIAL
code:0000116E ; F2 - CHANGE Directory
code:0000116E ; F3 - SETUP
code:0000116E ; F4 - ON LINE
code:0000116E ; < - Connect in originate
code:0000116E ; > - Connect in answer
code:0000116E ; ~ - Return to voice
code:0000116E ; | - Hang up
code:0000116E
code:0000116E ; =============== S U B R O U T I N E =======================================
code:0000116E
code:0000116E
code:0000116E ConnectMenu:                            ; CODE XREF: EraseAllEntries+71↓j
code:0000116E                                         ; DATA XREF: ChangeSettings+86↓o
code:0000116E
code:0000116E ; FUNCTION CHUNK AT code:00000978 SIZE 0000000C BYTES
code:0000116E
code:0000116E                 pop     ACC             ; Accumulator
code:00001170                 pop     ACC             ; Accumulator
code:00001172
code:00001172 ConnectMenuEntry:                       ; CODE XREF: TerminalLoop+43↑p
code:00001172                                         ; ManualDial+58↓j
code:00001172                 lcall   CheckAndInitDirectory ; Initializes the directory if it fails its checksum and
code:00001172                                         ; watermark tests
code:00001175                 lcall   PrintConnectMenu
code:00001178
code:00001178 SetConnectMenuHandler:                  ; CODE XREF: QuitConnectMenu+6↓j
code:00001178                 mov     ContextFunctionPtr+1, #(ConnectMenuHandler & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000117B                 mov     ContextFunctionPtr, #(ConnectMenuHandler >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000117E
code:0000117E ;
code:0000117E ; Simple menu loop
code:0000117E ;
code:0000117E ;
code:0000117E ; If we become ONLINE, leave the menu
code:0000117E
code:0000117E ConnectMenuLoop:                        ; CODE XREF: ConnectMenu+2D↓j
code:0000117E                 jb      VideoSettings.0, LeaveMenu ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000117E                                         ; Bit 1 = Receive buffer is full
code:0000117E                                         ; Bit 3 = Serial send register busy
code:0000117E                                         ; Bit 4 = Busy drawing to screen
code:0000117E                                         ; Bit 5 = Steady/Blink
code:0000117E                                         ; Bit 6 = Disable keyboard
code:0000117E                                         ; Bit 7 = Standard/Graphics
code:00001181
code:00001181 ;
code:00001181 ; If terminal state is 7, don't don't respond to serial input
code:00001181 ;
code:00001181                 mov     A, TerminalState
code:00001183                 cjne    A, #7, code_1188
code:00001186
code:00001186
code:00001186                 ajmp    ConnectMenuNext
code:00001188 ; ---------------------------------------------------------------------------
code:00001188
code:00001188 code_1188:                              ; CODE XREF: ConnectMenu+15↑j
code:00001188                 lcall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:00001188                                         ; needed.
code:00001188                                         ;
code:00001188                                         ; At return:
code:00001188                                         ;
code:00001188                                         ; A = next character
code:00001188                                         ; C = next character is valid
code:0000118B                 jnc     ConnectMenuNext
code:0000118D
code:0000118D ; Ignore the CANcel code
code:0000118D                 cjne    A, #0x18, HandleKey
code:00001190
code:00001190
code:00001190                 ajmp    ConnectMenuNext
code:00001192 ; ---------------------------------------------------------------------------
code:00001192
code:00001192 HandleKey:                              ; CODE XREF: ConnectMenu+1F↑j
code:00001192                 lcall   CallContextFunction ; If A is 0x18 (CANcel), enters typing mode instead of calling current
code:00001192                                         ; context function
code:00001195
code:00001195 ConnectMenuNext:                        ; CODE XREF: ConnectMenu+18↑j
code:00001195                                         ; ConnectMenu+1D↑j ...
code:00001195                 lcall   UpdateStatusLine
code:00001198                 lcall   PerformState
code:0000119B                 sjmp    ConnectMenuLoop
code:0000119D ; ---------------------------------------------------------------------------
code:0000119D
code:0000119D LeaveConnectMenu:                       ; DATA XREF: ConnectMenuESCHandler+12↓o
code:0000119D                 mov     A, TerminalState
code:0000119F                 jz      PopAndLeave
code:000011A1
code:000011A1
code:000011A1                 cjne    A, #16, code_11A4
code:000011A4
code:000011A4 code_11A4:                              ; CODE XREF: ConnectMenu+33↑j
code:000011A4                 jc      ReturnGate_11
code:000011A6
code:000011A6 PopAndLeave:                            ; CODE XREF: ConnectMenu+31↑j
code:000011A6                 pop     ACC             ; Accumulator
code:000011A8                 pop     ACC             ; Accumulator
code:000011AA
code:000011AA LeaveMenu:                              ; CODE XREF: ConnectMenu:ConnectMenuLoop↑j
code:000011AA                 lcall   SetNormalInputMode
code:000011AD
code:000011AD
code:000011AD                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000011AD                                         ; Bit 1 = Receive buffer is full
code:000011AD                                         ; Bit 3 = Serial send register busy
code:000011AD                                         ; Bit 4 = Busy drawing to screen
code:000011AD                                         ; Bit 5 = Steady/Blink
code:000011AD                                         ; Bit 6 = Disable keyboard
code:000011AD                                         ; Bit 7 = Standard/Graphics
code:000011AF                 lcall   j_ForceStatusLineUpdate
code:000011B2                 ljmp    ClearTTY
code:000011B2 ; End of function ConnectMenu
code:000011B2
code:000011B5
code:000011B5 ; =============== S U B R O U T I N E =======================================
code:000011B5
code:000011B5 ; If the desired value is found in the tag lookup table, the
code:000011B5 ; function does not return.  Instead it jumps to the tag's
code:000011B5 ; associated code pointer.
code:000011B5 ;
code:000011B5 ; A = value to look up
code:000011B5 ; B = number of entries in table
code:000011B5 ; DPTR = table start
code:000011B5
code:000011B5 JmpSpecialFunction:                     ; CODE XREF: ConnectMenuHandler+6↓p
code:000011B5                                         ; ConnectMenuESCHandler+8↓p ...
code:000011B5                 lcall   LookupFunctionByTag ; A = tag to look for
code:000011B5                                         ; B = number of tags in list
code:000011B5                                         ;
code:000011B5                                         ; On return:
code:000011B5                                         ;
code:000011B5                                         ; C = found tag
code:000011B5                                         ; DPTR = function ptr for tag
code:000011B8                 jc      ReturnGate_9
code:000011BA
code:000011BA
code:000011BA                 pop     ACC             ; Accumulator
code:000011BC                 pop     ACC             ; Accumulator
code:000011BE
code:000011BE
code:000011BE                 clr     A
code:000011BF                 jmp     @A+DPTR
code:000011BF ; End of function JmpSpecialFunction
code:000011BF
code:000011C0
code:000011C0 ; =============== S U B R O U T I N E =======================================
code:000011C0
code:000011C0
code:000011C0 ConnectMenuHandler:                     ; DATA XREF: ConnectMenu:SetConnectMenuHandler↑o
code:000011C0                                         ; ConnectMenu+D↑o ...
code:000011C0                 mov     B, #9           ; B-Register
code:000011C3                 mov     DPTR, #ConnectMenuTable
code:000011C6                 acall   JmpSpecialFunction ; If the desired value is found in the tag lookup table, the
code:000011C6                                         ; function does not return.  Instead it jumps to the tag's
code:000011C6                                         ; associated code pointer.
code:000011C6                                         ;
code:000011C6                                         ; A = value to look up
code:000011C6                                         ; B = number of entries in table
code:000011C6                                         ; DPTR = table start
code:000011C8                 push    ACC             ; Accumulator
code:000011CA                 mov     A, TerminalState
code:000011CC                 jz      CheckForDialKey
code:000011CE
code:000011CE
code:000011CE                 pop     ACC             ; Accumulator
code:000011D0                 ret
code:000011D1 ; ---------------------------------------------------------------------------
code:000011D1
code:000011D1 ;
code:000011D1 ; In terminal state 0 (reset number of rings, wait for ring),
code:000011D1 ; we will also allow dialing out.
code:000011D1 ;
code:000011D1
code:000011D1 CheckForDialKey:                        ; CODE XREF: ConnectMenuHandler+C↑j
code:000011D1                 pop     ACC             ; Accumulator
code:000011D3
code:000011D3
code:000011D3                 lcall   LetterTest      ; On return:
code:000011D3                                         ;
code:000011D3                                         ; B = original value
code:000011D3                                         ; A = capitalized value
code:000011D3                                         ; C = set if not a letter
code:000011D6                 jc      ReturnGate_9
code:000011D8
code:000011D8
code:000011D8                 subb    A, #'@
code:000011DA                 mov     TmpI, A         ; Often the phone book entry number, but can also be used as
code:000011DA                                         ; settings index
code:000011DC                 mov     DirEntryNumber, A
code:000011DE                 lcall   LookupNthDirectoryEntry ; TmpI = entry number
code:000011DE                                         ;
code:000011DE                                         ; Sets DirEntryType.
code:000011DE                                         ;
code:000011DE                                         ; Returns start of name
code:000011E1
code:000011E1
code:000011E1                 jz      ReturnGate_9
code:000011E3
code:000011E3
code:000011E3                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000011E3                                         ; Bit 1 = Receive buffer is full
code:000011E3                                         ; Bit 3 = Serial send register busy
code:000011E3                                         ; Bit 4 = Busy drawing to screen
code:000011E3                                         ; Bit 5 = Steady/Blink
code:000011E3                                         ; Bit 6 = Disable keyboard
code:000011E3                                         ; Bit 7 = Standard/Graphics
code:000011E5                 mov     A, TmpI         ; Often the phone book entry number, but can also be used as
code:000011E5                                         ; settings index
code:000011E7                 lcall   EntryIndexToScreenCoords ; A = directory entry index
code:000011EA
code:000011EA
code:000011EA                 mov     TerminalState, #20
code:000011ED
code:000011ED
code:000011ED                 mov     A, DirEntryType
code:000011EF                 cjne    A, #8, code_11F3
code:000011F2
code:000011F2
code:000011F2                 ret
code:000011F3 ; ---------------------------------------------------------------------------
code:000011F3
code:000011F3 code_11F3:                              ; CODE XREF: ConnectMenuHandler+2F↑j
code:000011F3                 mov     TerminalState, #21
code:000011F6                 cjne    A, #9, code_11FA
code:000011F9
code:000011F9
code:000011F9                 ret
code:000011FA ; ---------------------------------------------------------------------------
code:000011FA
code:000011FA code_11FA:                              ; CODE XREF: ConnectMenuHandler+36↑j
code:000011FA                 orl     DirEntryType, #0x80
code:000011FD
code:000011FD ReturnGate_9:                           ; CODE XREF: JmpSpecialFunction+3↑j
code:000011FD                                         ; ConnectMenuHandler+16↑j ...
code:000011FD                 ret
code:000011FD ; ---------------------------------------------------------------------------
code:000011FE ConnectMenuTable:.byte 0x1B             ; DATA XREF: ConnectMenuHandler+3↑o
code:000011FF                 .word ConnectMenuESC
code:00001201                 .byte 0x5C              ; Backslash
code:00001202                 .word HangUpChosen
code:00001204                 .byte '`
code:00001205                 .word ReturnToVoice
code:00001207                 .byte ',
code:00001208                 .word ConnectOriginate
code:0000120A                 .byte '.
code:0000120B                 .word ConnectAnswer
code:0000120D                 .byte '|
code:0000120E                 .word HangUpChosen
code:00001210                 .byte '~
code:00001211                 .word ReturnToVoice
code:00001213                 .byte '<
code:00001214                 .word ConnectOriginate
code:00001216                 .byte '>
code:00001217                 .word ConnectAnswer
code:00001219 ; ---------------------------------------------------------------------------
code:00001219
code:00001219 ConnectMenuESC:                         ; DATA XREF: ConnectMenuHandler+3F↑o
code:00001219                 mov     ContextFunctionPtr+1, #(ConnectMenuESCHandler & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000121C                 mov     ContextFunctionPtr, #(ConnectMenuESCHandler >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000121F                 ret
code:0000121F ; End of function ConnectMenuHandler
code:0000121F
code:00001220
code:00001220 ; =============== S U B R O U T I N E =======================================
code:00001220
code:00001220
code:00001220 ConnectOriginate:                       ; DATA XREF: ConnectMenuHandler+48↑o
code:00001220                                         ; ConnectMenuHandler+54↑o
code:00001220                 clr     P11             ; Turn off listen mode
code:00001222
code:00001222
code:00001222                 ajmp    DoConnect
code:00001224 ; ---------------------------------------------------------------------------
code:00001224
code:00001224 ConnectAnswer:                          ; DATA XREF: ConnectMenuHandler+4B↑o
code:00001224                                         ; ConnectMenuHandler+57↑o
code:00001224                 setb    P11             ; Turn on listen mode
code:00001226
code:00001226 DoConnect:                              ; CODE XREF: ConnectOriginate+2↑j
code:00001226                 setb    P14             ; Turn on carrier
code:00001228
code:00001228
code:00001228                 ljmp    OffHookForAbort
code:00001228 ; End of function ConnectOriginate
code:00001228
code:0000122B
code:0000122B ; =============== S U B R O U T I N E =======================================
code:0000122B
code:0000122B
code:0000122B ReturnToVoice:                          ; DATA XREF: ConnectMenuHandler+45↑o
code:0000122B                                         ; ConnectMenuHandler+51↑o
code:0000122B                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000122B                                         ; Bit 1 = Receive buffer is full
code:0000122B                                         ; Bit 3 = Serial send register busy
code:0000122B                                         ; Bit 4 = Busy drawing to screen
code:0000122B                                         ; Bit 5 = Steady/Blink
code:0000122B                                         ; Bit 6 = Disable keyboard
code:0000122B                                         ; Bit 7 = Standard/Graphics
code:0000122D                 mov     DirEntryType, #0
code:00001230                 acall   j_ForceStatusLineUpdate
code:00001232                 ljmp    HangUpModem
code:00001232 ; End of function ReturnToVoice
code:00001232
code:00001235
code:00001235 ; =============== S U B R O U T I N E =======================================
code:00001235
code:00001235
code:00001235 HangUpChosen:                           ; DATA XREF: ConnectMenuHandler+42↑o
code:00001235                                         ; ConnectMenuHandler+4E↑o
code:00001235                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001235                                         ; Bit 1 = Receive buffer is full
code:00001235                                         ; Bit 3 = Serial send register busy
code:00001235                                         ; Bit 4 = Busy drawing to screen
code:00001235                                         ; Bit 5 = Steady/Blink
code:00001235                                         ; Bit 6 = Disable keyboard
code:00001235                                         ; Bit 7 = Standard/Graphics
code:00001237                 mov     DirEntryType, #0
code:0000123A                 ljmp    RestoreStatusLine
code:0000123A ; End of function HangUpChosen
code:0000123A
code:0000123D
code:0000123D ; =============== S U B R O U T I N E =======================================
code:0000123D
code:0000123D
code:0000123D ConnectMenuESCHandler:                  ; DATA XREF: ConnectMenuHandler:ConnectMenuESC↑o
code:0000123D                                         ; ConnectMenuHandler+5C↑o
code:0000123D                 clr     FormatStatus.0  ; Bit 0 = Ctrl-F1 pressed
code:0000123D                                         ; Bit 1 = Save of Disable Status Bar flag
code:0000123D                                         ; Bit 2 = In graphics mode
code:0000123F                 mov     B, #7           ; B-Register
code:00001242                 mov     DPTR, #ConnectMenuESCTable
code:00001245                 acall   JmpSpecialFunction ; If the desired value is found in the tag lookup table, the
code:00001245                                         ; function does not return.  Instead it jumps to the tag's
code:00001245                                         ; associated code pointer.
code:00001245                                         ;
code:00001245                                         ; A = value to look up
code:00001245                                         ; B = number of entries in table
code:00001245                                         ; DPTR = table start
code:00001247
code:00001247
code:00001247                 mov     ContextFunctionPtr+1, #(ConnectMenuHandler & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000124A                 mov     ContextFunctionPtr, #(ConnectMenuHandler >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000124D
code:0000124D IgnoreESC:                              ; DATA XREF: ConnectMenuESCHandler+24↓o
code:0000124D                 ret
code:0000124D ; ---------------------------------------------------------------------------
code:0000124E ConnectMenuESCTable:.byte '|            ; DATA XREF: ConnectMenuESCHandler+5↑o
code:0000124F                 .word LeaveConnectMenu
code:00001251                 .byte 'A
code:00001252                 .word ManualDial
code:00001254                 .byte 'B
code:00001255                 .word ChangeDirectory
code:00001257                 .byte 'C
code:00001258                 .word ChangeSettings
code:0000125A                 .byte 'D
code:0000125B                 .word GoOnline
code:0000125D                 .byte 'W
code:0000125E                 .word QuitConnectMenu
code:00001260                 .byte 0x1B
code:00001261                 .word IgnoreESC
code:00001263 ; ---------------------------------------------------------------------------
code:00001263
code:00001263 GoOnline:                               ; DATA XREF: ConnectMenuESCHandler+1E↑o
code:00001263                 setb    VideoSettings.0 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001263 ; End of function ConnectMenuESCHandler ; Bit 1 = Receive buffer is full
code:00001263                                         ; Bit 3 = Serial send register busy
code:00001263                                         ; Bit 4 = Busy drawing to screen
code:00001263                                         ; Bit 5 = Steady/Blink
code:00001263                                         ; Bit 6 = Disable keyboard
code:00001263                                         ; Bit 7 = Standard/Graphics
code:00001265
code:00001265 ; =============== S U B R O U T I N E =======================================
code:00001265
code:00001265 ; Attributes: thunk
code:00001265
code:00001265 j_ForceStatusLineUpdate:                ; CODE XREF: TerminalLoop+58↑p
code:00001265                                         ; ConnectMenu+41↑p ...
code:00001265                 ljmp    ForceStatusLineUpdate ; A second bit is used to detect online status change so that the
code:00001265 ; End of function j_ForceStatusLineUpdate ; terminal software knows to react to it.  This is called to signal
code:00001265                                         ; a change, such as when the clock updates.
code:00001268
code:00001268 ; =============== S U B R O U T I N E =======================================
code:00001268
code:00001268
code:00001268 QuitConnectMenu:                        ; DATA XREF: ConnectMenuESCHandler+21↑o
code:00001268                 setb    FormatStatus.0  ; Bit 0 = Ctrl-F1 pressed
code:00001268                                         ; Bit 1 = Save of Disable Status Bar flag
code:00001268                                         ; Bit 2 = In graphics mode
code:0000126A                 pop     ACC             ; Accumulator
code:0000126C                 pop     ACC             ; Accumulator
code:0000126E                 ajmp    SetConnectMenuHandler
code:0000126E ; End of function QuitConnectMenu
code:0000126E
code:00001270
code:00001270 ; =============== S U B R O U T I N E =======================================
code:00001270
code:00001270
code:00001270 ChangeSettings:                         ; CODE XREF: SettingsSaveChanges+1E↓j
code:00001270                                         ; DATA XREF: ConnectMenuESCHandler+1B↑o
code:00001270
code:00001270 ; FUNCTION CHUNK AT code:0000134C SIZE 0000002C BYTES
code:00001270
code:00001270                 lcall   DrawLargeBox
code:00001273
code:00001273
code:00001273                 mov     DPTR, #aSetup
code:00001276                 acall   j_PrintDPTRPrefixedHiBtTermString
code:00001278
code:00001278
code:00001278                 lcall   DrawFunctionKeyMenu
code:0000127B
code:0000127B UpdateSettingsDisplay:                  ; CODE XREF: ChangeSettings+42↓j
code:0000127B                                         ; ChangeSettings+4F↓j ...
code:0000127B                 acall   DrawSettingsKeyMenu
code:0000127D
code:0000127D
code:0000127D                 mov     TmpI, #0        ; Often the phone book entry number, but can also be used as
code:0000127D                                         ; settings index
code:00001280
code:00001280 SettingsLoop:                           ; CODE XREF: ChangeSettings+21↓j
code:00001280                                         ; ChangeSettings+26↓j ...
code:00001280                 acall   PrintSettingsToScreen
code:00001282                 acall   j_WaitForSerialInput ; On return:
code:00001282                                         ;
code:00001282                                         ; A = next character
code:00001284                 cjne    A, #0x1B, NotESC
code:00001287
code:00001287
code:00001287                 acall   j_WaitForSerialInput ; On return:
code:00001287                                         ;
code:00001287                                         ; A = next character
code:00001289                 mov     DPTR, #SettingsESCLookupTable
code:0000128C                 mov     B, #5           ; B-Register
code:0000128F                 acall   JmpSpecialFunction ; If the desired value is found in the tag lookup table, the
code:0000128F                                         ; function does not return.  Instead it jumps to the tag's
code:0000128F                                         ; associated code pointer.
code:0000128F                                         ;
code:0000128F                                         ; A = value to look up
code:0000128F                                         ; B = number of entries in table
code:0000128F                                         ; DPTR = table start
code:00001291                 sjmp    SettingsLoop
code:00001293 ; ---------------------------------------------------------------------------
code:00001293
code:00001293 NotESC:                                 ; CODE XREF: ChangeSettings+14↑j
code:00001293                 lcall   LetterTest      ; On return:
code:00001293                                         ;
code:00001293                                         ; B = original value
code:00001293                                         ; A = capitalized value
code:00001293                                         ; C = set if not a letter
code:00001296                 jc      SettingsLoop
code:00001298
code:00001298
code:00001298                 subb    A, #'@
code:0000129A                 mov     TmpI, A         ; TmpI is used for the setting index here
code:0000129C
code:0000129C
code:0000129C                 mov     R7, A
code:0000129D                 acall   EntryIndexToScreenCoords ; A = directory entry index
code:0000129F
code:0000129F
code:0000129F                 cjne    R7, #1, SettingsLoop ; Setting 1 is set clock.  We do special code to set the clock.  Oterwise
code:0000129F                                         ; loop back to wait for input
code:000012A2
code:000012A2
code:000012A2                 mov     CursorColumn, #15
code:000012A5                 mov     CursorRow, #2
code:000012A8                 lcall   CalcCursorAddr  ; Updates the CursorAddr pointer using the cursor row and
code:000012A8                                         ; column and the line table for calculation.
code:000012A8                                         ;
code:000012A8                                         ; Does not account for attributes in the row.  This is a
code:000012A8                                         ; bug.
code:000012AB
code:000012AB
code:000012AB                 mov     R0, #(TimeDigitsEX & 0xFF)
code:000012AD                 mov     R1, #(TimeDigitsEX >> 8)
code:000012AF                 lcall   ReadDigit02     ; Read a digit between 0 and 2
code:000012B2                 jz      UpdateSettingsDisplay
code:000012B4
code:000012B4
code:000012B4                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000012B4                                         ;
code:000012B4                                         ; R1:R0 = destination
code:000012B4                                         ; A = character
code:000012B4                                         ;
code:000012B4                                         ; Auto-increments R1:R0
code:000012B6                 mov     R7, A
code:000012B7                 acall   j_TypeCharAsIs
code:000012B9                 cjne    R7, #'2, Hours09
code:000012BC
code:000012BC
code:000012BC                 lcall   ReadDigit03     ; Read a digit between 0 and 3
code:000012BF                 jz      UpdateSettingsDisplay
code:000012C1
code:000012C1
code:000012C1                 ajmp    StoreHoursLow
code:000012C3 ; ---------------------------------------------------------------------------
code:000012C3
code:000012C3 Hours09:                                ; CODE XREF: ChangeSettings+49↑j
code:000012C3                 lcall   ReadDigit09     ; Read a digit between 0 and 9
code:000012C6                 jz      UpdateSettingsDisplay
code:000012C8
code:000012C8 StoreHoursLow:                          ; CODE XREF: ChangeSettings+51↑j
code:000012C8                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000012C8                                         ;
code:000012C8                                         ; R1:R0 = destination
code:000012C8                                         ; A = character
code:000012C8                                         ;
code:000012C8                                         ; Auto-increments R1:R0
code:000012CA                 acall   j_TypeCharAsIs
code:000012CC
code:000012CC
code:000012CC                 mov     R3, #2
code:000012CE
code:000012CE NextUnit:                               ; CODE XREF: ChangeSettings+74↓j
code:000012CE                 mov     A, #':
code:000012D0                 acall   j_TypeCharAsIs
code:000012D2
code:000012D2
code:000012D2                 lcall   ReadDigit05     ; Read a digit between 0 and 5
code:000012D5                 jz      UpdateSettingsDisplay
code:000012D7
code:000012D7
code:000012D7                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000012D7                                         ;
code:000012D7                                         ; R1:R0 = destination
code:000012D7                                         ; A = character
code:000012D7                                         ;
code:000012D7                                         ; Auto-increments R1:R0
code:000012D9                 acall   j_TypeCharAsIs
code:000012DB
code:000012DB
code:000012DB                 lcall   ReadDigit09     ; Read a digit between 0 and 9
code:000012DE                 jz      UpdateSettingsDisplay
code:000012E0
code:000012E0
code:000012E0                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000012E0                                         ;
code:000012E0                                         ; R1:R0 = destination
code:000012E0                                         ; A = character
code:000012E0                                         ;
code:000012E0                                         ; Auto-increments R1:R0
code:000012E2                 acall   j_TypeCharAsIs
code:000012E4                 djnz    R3, NextUnit
code:000012E6
code:000012E6 SettingsSetTime:                        ; DATA XREF: ChangeSettings+8F↓o
code:000012E6                 mov     R0, #(TimeDigitsINT+5)
code:000012E8                 mov     DPTR, #TimeDigitsEX
code:000012EB                 mov     R1, #6
code:000012ED
code:000012ED CopyToTimeLoop:                         ; CODE XREF: ChangeSettings+81↓j
code:000012ED                 movx    A, @DPTR
code:000012EE                 inc     DPTR
code:000012EF                 mov     @R0, A
code:000012F0                 dec     R0
code:000012F1                 djnz    R1, CopyToTimeLoop
code:000012F3
code:000012F3
code:000012F3                 sjmp    UpdateSettingsDisplay
code:000012F3 ; ---------------------------------------------------------------------------
code:000012F5 SettingsESCLookupTable:.byte '|         ; DATA XREF: ChangeSettings+19↑o
code:000012F6                 .word ConnectMenu
code:000012F8                 .byte 'A
code:000012F9                 .word SettingsIncrease
code:000012FB                 .byte 'B
code:000012FC                 .word SettingsDecrease
code:000012FE                 .byte 'C
code:000012FF                 .word SettingsSetTime
code:00001301                 .byte 'D
code:00001302                 .word SettingsSaveChanges
code:00001304 ; ---------------------------------------------------------------------------
code:00001304
code:00001304 SettingsIncrease:                       ; DATA XREF: ChangeSettings+89↑o
code:00001304                 clr     TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:00001304                                         ; Bit 1 = BREAK is tracked as pressed
code:00001304                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001304                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001304                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001304                                         ;         handler uses this to look for timeouts in each state.
code:00001304                                         ; Bit 4 = Use immediate dial buffer
code:00001304                                         ; Bit 5 = Dial voice
code:00001304                                         ; Bit 6 = Disabling/Enabling a setting
code:00001304                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001306                 ajmp    AdjustSetting
code:00001308 ; ---------------------------------------------------------------------------
code:00001308
code:00001308 SettingsDecrease:                       ; DATA XREF: ChangeSettings+8C↑o
code:00001308                 setb    TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:00001308                                         ; Bit 1 = BREAK is tracked as pressed
code:00001308                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001308                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001308                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001308                                         ;         handler uses this to look for timeouts in each state.
code:00001308                                         ; Bit 4 = Use immediate dial buffer
code:00001308                                         ; Bit 5 = Dial voice
code:00001308                                         ; Bit 6 = Disabling/Enabling a setting
code:00001308                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000130A
code:0000130A AdjustSetting:                          ; CODE XREF: ChangeSettings+96↑j
code:0000130A                 mov     DPTR, #SettingsLoop
code:0000130D                 push    DPL             ; Data Pointer, Low Byte
code:0000130F                 push    DPH             ; Data Pointer, High Byte
code:00001311
code:00001311
code:00001311                 mov     DPTR, #AdjustSettingTable
code:00001314                 mov     A, TmpI         ; Often the phone book entry number, but can also be used as
code:00001314                                         ; settings index
code:00001316                 movc    A, @A+DPTR      ; switch 27 cases
code:00001317                 jmp     @A+DPTR         ; switch jump
code:00001317 ; ---------------------------------------------------------------------------
code:00001318 AdjustSettingTable:.byte DoNothing - 0x1318
code:00001318                                         ; DATA XREF: ChangeSettings+A1↑o
code:00001318                 .byte DoNothing - 0x1318 ; jump table for switch statement
code:00001318                 .byte ToggleClockDisplay - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte AdjustAutoAnswerRings - 0x1318
code:00001318                 .byte AdjustWaitForAnswerSecs - 0x1318
code:00001318                 .byte AdjustSlashPause - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte ToggleDuplex - 0x1318
code:00001318                 .byte ToggleFlowControl - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte ToggleAutoRepeat - 0x1318
code:00001318                 .byte ToggleKeyClick - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte ToggleCursorStyle - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte ToggleEOLWrap - 0x1318
code:00001318                 .byte ToggleCRtoCRLF - 0x1318
code:00001318                 .byte ToggleLFtoCRLF - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001318                 .byte DoNothing - 0x1318
code:00001333 ; ---------------------------------------------------------------------------
code:00001333
code:00001333 DoNothing:                              ; CODE XREF: ChangeSettings+A7↑j
code:00001333                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001333                 ret                     ; jumptable 00001317 cases 0,1,3,7,10-13,16,18-20,24-26
code:00001334 ; ---------------------------------------------------------------------------
code:00001334
code:00001334 ToggleClockDisplay:                     ; CODE XREF: ChangeSettings+A7↑j
code:00001334                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001334                 cpl     SerialSettings.0 ; jumptable 00001317 case 2
code:00001336                 acall   j_ForceStatusLineUpdate
code:00001338                 ljmp    UpdateStatusLine
code:0000133B ; ---------------------------------------------------------------------------
code:0000133B
code:0000133B AdjustAutoAnswerRings:                  ; CODE XREF: ChangeSettings+A7↑j
code:0000133B                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:0000133B                 mov     A, AutoAnswerAfter ; jumptable 00001317 case 4
code:0000133D                 acall   IncreaseOrDecrease
code:0000133F                 mov     AutoAnswerAfter, A ; Number of rings to wait
code:00001341                 ret
code:00001341 ; End of function ChangeSettings
code:00001341
code:00001342
code:00001342 ; =============== S U B R O U T I N E =======================================
code:00001342
code:00001342
code:00001342 IncreaseOrDecrease:                     ; CODE XREF: ChangeSettings+CD↑p
code:00001342                                         ; ChangeSettings+DE↓p ...
code:00001342                 jnb     TimerStatus.6, code_1348 ; Bit 0 = ESC is tracked as pressed
code:00001342                                         ; Bit 1 = BREAK is tracked as pressed
code:00001342                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001342                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001342                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001342                                         ;         handler uses this to look for timeouts in each state.
code:00001342                                         ; Bit 4 = Use immediate dial buffer
code:00001342                                         ; Bit 5 = Dial voice
code:00001342                                         ; Bit 6 = Disabling/Enabling a setting
code:00001342                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001345
code:00001345
code:00001345                 dec     A
code:00001346                 ajmp    code_1349
code:00001348 ; ---------------------------------------------------------------------------
code:00001348
code:00001348 code_1348:                              ; CODE XREF: IncreaseOrDecrease↑j
code:00001348                 inc     A
code:00001349
code:00001349 code_1349:                              ; CODE XREF: IncreaseOrDecrease+4↑j
code:00001349                 anl     A, #0xF
code:0000134B                 ret
code:0000134B ; End of function IncreaseOrDecrease
code:0000134B
code:0000134C ; ---------------------------------------------------------------------------
code:0000134C ; START OF FUNCTION CHUNK FOR ChangeSettings
code:0000134C
code:0000134C AdjustWaitForAnswerSecs:                ; CODE XREF: ChangeSettings+A7↑j
code:0000134C                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:0000134C                 mov     A, SecWaitForAnswer ; jumptable 00001317 case 5
code:0000134E                 acall   IncreaseOrDecrease
code:00001350                 mov     SecWaitForAnswer, A ; The actual value is this value*5
code:00001352                 ret
code:00001353 ; ---------------------------------------------------------------------------
code:00001353
code:00001353 AdjustSlashPause:                       ; CODE XREF: ChangeSettings+A7↑j
code:00001353                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001353                 mov     A, SlashPause   ; jumptable 00001317 case 6
code:00001355                 acall   IncreaseOrDecrease
code:00001357                 mov     SlashPause, A   ; Time to wait when / is seen.  Value is 3*number+12
code:00001359                 ret
code:0000135A ; ---------------------------------------------------------------------------
code:0000135A
code:0000135A ToggleDuplex:                           ; CODE XREF: ChangeSettings+A7↑j
code:0000135A                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:0000135A                 cpl     SerialSettings.2 ; jumptable 00001317 case 8
code:0000135C                 ret
code:0000135D ; ---------------------------------------------------------------------------
code:0000135D
code:0000135D ToggleFlowControl:                      ; CODE XREF: ChangeSettings+A7↑j
code:0000135D                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:0000135D                 cpl     SerialSettings.1 ; jumptable 00001317 case 9
code:0000135F                 ret
code:00001360 ; ---------------------------------------------------------------------------
code:00001360
code:00001360 ToggleAutoRepeat:                       ; CODE XREF: ChangeSettings+A7↑j
code:00001360                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001360                 cpl     SerialSettings.3 ; jumptable 00001317 case 14
code:00001362                 ret
code:00001363 ; ---------------------------------------------------------------------------
code:00001363
code:00001363 ToggleKeyClick:                         ; CODE XREF: ChangeSettings+A7↑j
code:00001363                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001363                 cpl     SerialSettings.4 ; jumptable 00001317 case 15
code:00001365                 ret
code:00001366 ; ---------------------------------------------------------------------------
code:00001366
code:00001366 ToggleCursorStyle:                      ; CODE XREF: ChangeSettings+A7↑j
code:00001366                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001366                 jb      VideoSettings.5, code_136C ; jumptable 00001317 case 17
code:00001369                 ljmp    CursorRevVideo  ; jumptable 000005D2 case 10
code:0000136C ; ---------------------------------------------------------------------------
code:0000136C
code:0000136C code_136C:                              ; CODE XREF: ChangeSettings:ToggleCursorStyle↑j
code:0000136C                 ljmp    CursorBlink     ; jumptable 000005D2 case 10
code:0000136F ; ---------------------------------------------------------------------------
code:0000136F
code:0000136F ToggleEOLWrap:                          ; CODE XREF: ChangeSettings+A7↑j
code:0000136F                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:0000136F                 cpl     SerialSettings.7 ; jumptable 00001317 case 21
code:00001371                 ret
code:00001372 ; ---------------------------------------------------------------------------
code:00001372
code:00001372 ToggleCRtoCRLF:                         ; CODE XREF: ChangeSettings+A7↑j
code:00001372                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001372                 cpl     SerialSettings.6 ; jumptable 00001317 case 22
code:00001374                 ret
code:00001375 ; ---------------------------------------------------------------------------
code:00001375
code:00001375 ToggleLFtoCRLF:                         ; CODE XREF: ChangeSettings+A7↑j
code:00001375                                         ; DATA XREF: ChangeSettings:AdjustSettingTable↑o
code:00001375                 cpl     SerialSettings.5 ; jumptable 00001317 case 23
code:00001377                 ret
code:00001377 ; END OF FUNCTION CHUNK FOR ChangeSettings
code:00001378
code:00001378 ; =============== S U B R O U T I N E =======================================
code:00001378
code:00001378
code:00001378 SettingsSaveChanges:                    ; DATA XREF: ChangeSettings+92↑o
code:00001378                 lcall   PrintHoldSaveReturnMsg
code:0000137B
code:0000137B code_137B:                              ; CODE XREF: SettingsSaveChanges+5↓j
code:0000137B                 acall   j_WaitForSerialInput ; On return:
code:0000137B                                         ;
code:0000137B                                         ; A = next character
code:0000137D                 cjne    A, #0xD, code_137B
code:00001380
code:00001380
code:00001380                 mov     A, SerialSettings ; Bit 0 = Clock display off
code:00001380                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00001380                                         ; Bit 2 = Half/Full duplex
code:00001380                                         ; Bit 3 = Auto Repeat disable
code:00001380                                         ; Bit 4 = Key click disable
code:00001380                                         ; Bit 5 = LF->CRLF
code:00001380                                         ; Bit 6 = CR->CRLF
code:00001380                                         ; Bit 7 = Wrap at EOL off
code:00001382                 mov     DPTR, #SavedSerialSettings
code:00001385                 swap    A
code:00001386                 movx    @DPTR, A
code:00001387                 inc     DPTR
code:00001388                 mov     A, SerialSettings ; Bit 0 = Clock display off
code:00001388                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00001388                                         ; Bit 2 = Half/Full duplex
code:00001388                                         ; Bit 3 = Auto Repeat disable
code:00001388                                         ; Bit 4 = Key click disable
code:00001388                                         ; Bit 5 = LF->CRLF
code:00001388                                         ; Bit 6 = CR->CRLF
code:00001388                                         ; Bit 7 = Wrap at EOL off
code:0000138A                 movx    @DPTR, A
code:0000138B
code:0000138B
code:0000138B                 inc     DPTR
code:0000138C                 mov     A, SlashPause   ; Time to wait when / is seen.  Value is 3*number+12
code:0000138E                 movx    @DPTR, A
code:0000138F
code:0000138F
code:0000138F                 inc     DPTR
code:00001390                 mov     A, SecWaitForAnswer ; The actual value is this value*5
code:00001392                 movx    @DPTR, A
code:00001393
code:00001393
code:00001393                 lcall   UpdatePhoneBookCksum
code:00001396                 ajmp    ChangeSettings
code:00001396 ; End of function SettingsSaveChanges
code:00001396
code:00001398
code:00001398 ; =============== S U B R O U T I N E =======================================
code:00001398
code:00001398
code:00001398 DrawSettingsKeyMenu:                    ; CODE XREF: ChangeSettings:UpdateSettingsDisplay↑p
code:00001398                 mov     DPTR, #aSettingsKeys
code:0000139B                 acall   j_PrintDPTRPrefixedHiBtTermString
code:0000139D                 mov     DPTR, #aSelect
code:000013A0                 ljmp    PrintRowColPrefixedHiBitTermString
code:000013A0 ; End of function DrawSettingsKeyMenu
code:000013A0
code:000013A3
code:000013A3 ; =============== S U B R O U T I N E =======================================
code:000013A3
code:000013A3 ; A = directory entry index
code:000013A3
code:000013A3 EntryIndexToScreenCoords:               ; CODE XREF: ConnectMenuHandler+27↑p
code:000013A3                                         ; ChangeSettings+2D↑p
code:000013A3                 inc     A
code:000013A4                 mov     CursorColumn, #1
code:000013A7                 cjne    A, #15, code_13AA
code:000013AA
code:000013AA code_13AA:                              ; CODE XREF: EntryIndexToScreenCoords+4↑j
code:000013AA                 jc      code_13B1
code:000013AC
code:000013AC
code:000013AC                 subb    A, #13
code:000013AE                 mov     CursorColumn, #40
code:000013B1
code:000013B1 code_13B1:                              ; CODE XREF: EntryIndexToScreenCoords:code_13AA↑j
code:000013B1                 mov     CursorRow, A
code:000013B3                 ret
code:000013B3 ; End of function EntryIndexToScreenCoords
code:000013B3
code:000013B4
code:000013B4 ; =============== S U B R O U T I N E =======================================
code:000013B4
code:000013B4 ; C = off/on flag
code:000013B4 ; R1:R0 = destination
code:000013B4 ;
code:000013B4 ; Auto-increments R1:R0.  Uses logical NOT of C flag
code:000013B4
code:000013B4 PrintOnOffNOTToScreen:                  ; CODE XREF: PrintSettingsToScreen+2A↓p
code:000013B4                                         ; PrintSettingsToScreen+41↓p ...
code:000013B4                 cpl     C
code:000013B4 ; End of function PrintOnOffNOTToScreen
code:000013B4
code:000013B5
code:000013B5 ; =============== S U B R O U T I N E =======================================
code:000013B5
code:000013B5 ; C = on/off flag
code:000013B5 ; R1:R0 = destination
code:000013B5 ;
code:000013B5 ; Auto-increments R1:R0
code:000013B5
code:000013B5 PrintOnOffToScreen:                     ; CODE XREF: PrintSettingsToScreen+1A↓p
code:000013B5                                         ; PrintSettingsToScreen+22↓p
code:000013B5                 mov     DPTR, #aOn      ; "on "
code:000013B8                 jc      code_13BD
code:000013BA
code:000013BA
code:000013BA                 mov     DPTR, #aOff     ; "off"
code:000013BD
code:000013BD code_13BD:                              ; CODE XREF: PrintOnOffToScreen+3↑j
code:000013BD                 ajmp    j_PrintCStringEntry ; R1:R0 = destination
code:000013BD ; End of function PrintOnOffToScreen    ; DPTR = source
code:000013BD                                         ;
code:000013BD                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:000013BF
code:000013BF ; =============== S U B R O U T I N E =======================================
code:000013BF
code:000013BF
code:000013BF PrintSettingsToScreen:                  ; CODE XREF: ChangeSettings:SettingsLoop↑p
code:000013BF                 mov     DPTR, #TimeDigitsEX
code:000013C2                 mov     R0, #((VideoLine3+0xF) & 0xFF)
code:000013C4                 mov     R1, #((VideoLine3+0xF) >> 8)
code:000013C6
code:000013C6
code:000013C6                 mov     R3, #3
code:000013C8
code:000013C8 CopyTimeStringLoop:                     ; CODE XREF: PrintSettingsToScreen+12↓j
code:000013C8                 movx    A, @DPTR
code:000013C9                 inc     DPTR
code:000013CA                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000013CA                                         ;
code:000013CA                                         ; R1:R0 = destination
code:000013CA                                         ; A = character
code:000013CA                                         ;
code:000013CA                                         ; Auto-increments R1:R0
code:000013CC                 movx    A, @DPTR
code:000013CD                 inc     DPTR
code:000013CE                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000013CE                                         ;
code:000013CE                                         ; R1:R0 = destination
code:000013CE                                         ; A = character
code:000013CE                                         ;
code:000013CE                                         ; Auto-increments R1:R0
code:000013D0                 inc     R0
code:000013D1                 djnz    R3, CopyTimeStringLoop
code:000013D3
code:000013D3
code:000013D3                 mov     R0, #((VideoLine11+0x3B) & 0xFF)
code:000013D5                 mov     R1, #((VideoLine11+0x3B) >> 8)
code:000013D7                 mov     C, SerialSettings.6 ; Bit 0 = Clock display off
code:000013D7                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000013D7                                         ; Bit 2 = Half/Full duplex
code:000013D7                                         ; Bit 3 = Auto Repeat disable
code:000013D7                                         ; Bit 4 = Key click disable
code:000013D7                                         ; Bit 5 = LF->CRLF
code:000013D7                                         ; Bit 6 = CR->CRLF
code:000013D7                                         ; Bit 7 = Wrap at EOL off
code:000013D9                 acall   PrintOnOffToScreen ; C = on/off flag
code:000013D9                                         ; R1:R0 = destination
code:000013D9                                         ;
code:000013D9                                         ; Auto-increments R1:R0
code:000013DB
code:000013DB
code:000013DB                 mov     R0, #((VideoLine12+0x3B) & 0xFF)
code:000013DD                 mov     R1, #((VideoLine12+0x3B) >> 8)
code:000013DF                 mov     C, SerialSettings.5 ; Bit 0 = Clock display off
code:000013DF                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000013DF                                         ; Bit 2 = Half/Full duplex
code:000013DF                                         ; Bit 3 = Auto Repeat disable
code:000013DF                                         ; Bit 4 = Key click disable
code:000013DF                                         ; Bit 5 = LF->CRLF
code:000013DF                                         ; Bit 6 = CR->CRLF
code:000013DF                                         ; Bit 7 = Wrap at EOL off
code:000013E1                 acall   PrintOnOffToScreen ; C = on/off flag
code:000013E1                                         ; R1:R0 = destination
code:000013E1                                         ;
code:000013E1                                         ; Auto-increments R1:R0
code:000013E3
code:000013E3
code:000013E3                 mov     R0, #((VideoLine10+0x41) & 0xFF)
code:000013E5                 mov     R1, #((VideoLine10+0x41) >> 8)
code:000013E7                 mov     C, SerialSettings.7 ; Bit 0 = Clock display off
code:000013E7                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000013E7                                         ; Bit 2 = Half/Full duplex
code:000013E7                                         ; Bit 3 = Auto Repeat disable
code:000013E7                                         ; Bit 4 = Key click disable
code:000013E7                                         ; Bit 5 = LF->CRLF
code:000013E7                                         ; Bit 6 = CR->CRLF
code:000013E7                                         ; Bit 7 = Wrap at EOL off
code:000013E9                 acall   PrintOnOffNOTToScreen ; C = off/on flag
code:000013E9                                         ; R1:R0 = destination
code:000013E9                                         ;
code:000013E9                                         ; Auto-increments R1:R0.  Uses logical NOT of C flag
code:000013EB
code:000013EB
code:000013EB                 mov     R0, #((VideoLine6+0x34) & 0xFF)
code:000013ED                 mov     R1, #((VideoLine6+0x34) >> 8)
code:000013EF                 mov     DPTR, #aBlink   ; "blink "
code:000013F2                 jnb     VideoSettings.5, code_13F8 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000013F2                                         ; Bit 1 = Receive buffer is full
code:000013F2                                         ; Bit 3 = Serial send register busy
code:000013F2                                         ; Bit 4 = Busy drawing to screen
code:000013F2                                         ; Bit 5 = Steady/Blink
code:000013F2                                         ; Bit 6 = Disable keyboard
code:000013F2                                         ; Bit 7 = Standard/Graphics
code:000013F5
code:000013F5
code:000013F5                 mov     DPTR, #aSteady  ; "steady"
code:000013F8
code:000013F8 code_13F8:                              ; CODE XREF: PrintSettingsToScreen+33↑j
code:000013F8                 acall   j_PrintCStringEntry ; R1:R0 = destination
code:000013F8                                         ; DPTR = source
code:000013F8                                         ;
code:000013F8                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:000013FA
code:000013FA
code:000013FA                 mov     R0, #((VideoLine3+0x39) & 0xFF)
code:000013FC                 mov     R1, #((VideoLine3+0x39) >> 8)
code:000013FE                 mov     C, SerialSettings.3 ; Bit 0 = Clock display off
code:000013FE                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:000013FE                                         ; Bit 2 = Half/Full duplex
code:000013FE                                         ; Bit 3 = Auto Repeat disable
code:000013FE                                         ; Bit 4 = Key click disable
code:000013FE                                         ; Bit 5 = LF->CRLF
code:000013FE                                         ; Bit 6 = CR->CRLF
code:000013FE                                         ; Bit 7 = Wrap at EOL off
code:00001400                 acall   PrintOnOffNOTToScreen ; C = off/on flag
code:00001400                                         ; R1:R0 = destination
code:00001400                                         ;
code:00001400                                         ; Auto-increments R1:R0.  Uses logical NOT of C flag
code:00001402
code:00001402
code:00001402                 mov     R0, #((VideoLine4+0x37) & 0xFF)
code:00001404                 mov     R1, #((VideoLine4+0x37) >> 8)
code:00001406                 mov     C, SerialSettings.4 ; Bit 0 = Clock display off
code:00001406                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00001406                                         ; Bit 2 = Half/Full duplex
code:00001406                                         ; Bit 3 = Auto Repeat disable
code:00001406                                         ; Bit 4 = Key click disable
code:00001406                                         ; Bit 5 = LF->CRLF
code:00001406                                         ; Bit 6 = CR->CRLF
code:00001406                                         ; Bit 7 = Wrap at EOL off
code:00001408                 acall   PrintOnOffNOTToScreen ; C = off/on flag
code:00001408                                         ; R1:R0 = destination
code:00001408                                         ;
code:00001408                                         ; Auto-increments R1:R0.  Uses logical NOT of C flag
code:0000140A
code:0000140A
code:0000140A                 mov     R0, #((VideoLine10+6) & 0xFF)
code:0000140C                 mov     R1, #((VideoLine10+6) >> 8)
code:0000140E                 mov     DPTR, #aFull    ; "Full"
code:00001411                 jnb     SerialSettings.2, code_1417 ; Bit 0 = Clock display off
code:00001411                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:00001411                                         ; Bit 2 = Half/Full duplex
code:00001411                                         ; Bit 3 = Auto Repeat disable
code:00001411                                         ; Bit 4 = Key click disable
code:00001411                                         ; Bit 5 = LF->CRLF
code:00001411                                         ; Bit 6 = CR->CRLF
code:00001411                                         ; Bit 7 = Wrap at EOL off
code:00001414
code:00001414
code:00001414                 mov     DPTR, #aHalf    ; "Half"
code:00001417
code:00001417 code_1417:                              ; CODE XREF: PrintSettingsToScreen+52↑j
code:00001417                 acall   j_PrintCStringEntry ; R1:R0 = destination
code:00001417                                         ; DPTR = source
code:00001417                                         ;
code:00001417                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00001419
code:00001419
code:00001419                 mov     R0, #((VideoLine4+0x14) & 0xFF)
code:0000141B                 mov     R1, #((VideoLine4+0x14) >> 8)
code:0000141D                 mov     C, SerialSettings.0 ; Bit 0 = Clock display off
code:0000141D                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
code:0000141D                                         ; Bit 2 = Half/Full duplex
code:0000141D                                         ; Bit 3 = Auto Repeat disable
code:0000141D                                         ; Bit 4 = Key click disable
code:0000141D                                         ; Bit 5 = LF->CRLF
code:0000141D                                         ; Bit 6 = CR->CRLF
code:0000141D                                         ; Bit 7 = Wrap at EOL off
code:0000141F                 acall   PrintOnOffNOTToScreen ; C = off/on flag
code:0000141F                                         ; R1:R0 = destination
code:0000141F                                         ;
code:0000141F                                         ; Auto-increments R1:R0.  Uses logical NOT of C flag
code:00001421
code:00001421
code:00001421                 mov     DPTR, #(VideoLine6+0x18)
code:00001424                 mov     A, AutoAnswerAfter ; Number of rings to wait
code:00001426                 acall   Bin2Digits      ; A = number to convert
code:00001426                                         ;
code:00001426                                         ; On return:
code:00001426                                         ;
code:00001426                                         ; B = 100's digit
code:00001426                                         ; R1 = 10's digit
code:00001426                                         ; R0 = 1's digit
code:00001426                                         ;
code:00001426                                         ; Leading 0's become blanks
code:00001428                 mov     A, R1
code:00001429                 movx    @DPTR, A
code:0000142A                 inc     DPTR
code:0000142B                 mov     A, R0
code:0000142C                 movx    @DPTR, A
code:0000142D
code:0000142D
code:0000142D                 mov     A, SecWaitForAnswer ; The actual value is this value*5
code:0000142F                 inc     A
code:00001430                 mov     B, #5           ; B-Register
code:00001433                 mul     AB
code:00001434                 acall   Bin2Digits      ; A = number to convert
code:00001434                                         ;
code:00001434                                         ; On return:
code:00001434                                         ;
code:00001434                                         ; B = 100's digit
code:00001434                                         ; R1 = 10's digit
code:00001434                                         ; R0 = 1's digit
code:00001434                                         ;
code:00001434                                         ; Leading 0's become blanks
code:00001436                 mov     DPTR, #(VideoLine7+0xB)
code:00001439                 mov     A, B            ; B-Register
code:0000143B                 movx    @DPTR, A
code:0000143C                 inc     DPTR
code:0000143D                 mov     A, R1
code:0000143E                 movx    @DPTR, A
code:0000143F                 inc     DPTR
code:00001440                 mov     A, R0
code:00001441                 movx    @DPTR, A
code:00001442
code:00001442
code:00001442                 mov     A, SlashPause   ; Time to wait when / is seen.  Value is 3*number+12
code:00001444                 add     A, SlashPause   ; Time to wait when / is seen.  Value is 3*number+12
code:00001446                 add     A, SlashPause   ; Time to wait when / is seen.  Value is 3*number+12
code:00001448                 add     A, #12
code:0000144A                 acall   Bin2Digits      ; A = number to convert
code:0000144A                                         ;
code:0000144A                                         ; On return:
code:0000144A                                         ;
code:0000144A                                         ; B = 100's digit
code:0000144A                                         ; R1 = 10's digit
code:0000144A                                         ; R0 = 1's digit
code:0000144A                                         ;
code:0000144A                                         ; Leading 0's become blanks
code:0000144C                 mov     DPTR, #(VideoLine8+0xE)
code:0000144F                 mov     A, R1
code:00001450                 movx    @DPTR, A
code:00001451                 inc     DPTR
code:00001452                 mov     A, #'.
code:00001454                 movx    @DPTR, A
code:00001455                 inc     DPTR
code:00001456                 mov     A, R0
code:00001457                 movx    @DPTR, A
code:00001458
code:00001458
code:00001458                 mov     R0, #((VideoLine11+0x12) & 0xFF)
code:0000145A                 mov     R1, #((VideoLine11+0x12) >> 8)
code:0000145C                 mov     DPTR, #aXonXoff ; "XON/XOFF"
code:0000145F                 jnb     SerialSettings.1, j_PrintCStringEntry ; R1:R0 = destination
code:0000145F                                         ; DPTR = source
code:0000145F                                         ;
code:0000145F                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00001462                 mov     DPTR, #aNone    ; "none    "
code:00001462 ; End of function PrintSettingsToScreen
code:00001462
code:00001465 ; [00000003 BYTES: COLLAPSED FUNCTION j_PrintCStringEntry. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001468
code:00001468 ; =============== S U B R O U T I N E =======================================
code:00001468
code:00001468 ; A = number to convert
code:00001468 ;
code:00001468 ; On return:
code:00001468 ;
code:00001468 ; B = 100's digit
code:00001468 ; R1 = 10's digit
code:00001468 ; R0 = 1's digit
code:00001468 ;
code:00001468 ; Leading 0's become blanks
code:00001468
code:00001468 Bin2Digits:                             ; CODE XREF: PrintSettingsToScreen+67↑p
code:00001468                                         ; PrintSettingsToScreen+75↑p ...
code:00001468                 mov     B, #100         ; B-Register
code:0000146B                 div     AB
code:0000146C                 push    ACC             ; Accumulator
code:0000146E
code:0000146E
code:0000146E                 mov     A, B            ; B-Register
code:00001470                 mov     B, #10          ; B-Register
code:00001473                 div     AB
code:00001474                 add     A, #'0
code:00001476                 mov     R1, A
code:00001477
code:00001477
code:00001477                 mov     A, B            ; B-Register
code:00001479                 add     A, #'0
code:0000147B                 mov     R0, A
code:0000147C                 pop     ACC             ; Accumulator
code:0000147E                 jnz     code_1489
code:00001480
code:00001480
code:00001480                 mov     B, #'           ; B-Register
code:00001483                 cjne    R1, #'0, code_1488
code:00001486
code:00001486
code:00001486                 mov     R1, #'
code:00001488
code:00001488 code_1488:                              ; CODE XREF: Bin2Digits+1B↑j
code:00001488                 ret
code:00001489 ; ---------------------------------------------------------------------------
code:00001489
code:00001489 code_1489:                              ; CODE XREF: Bin2Digits+16↑j
code:00001489                 add     A, #'0
code:0000148B                 mov     B, A            ; B-Register
code:0000148D                 ret
code:0000148D ; End of function Bin2Digits
code:0000148D
code:0000148E
code:0000148E ; =============== S U B R O U T I N E =======================================
code:0000148E
code:0000148E
code:0000148E ManualDial:                             ; CODE XREF: ManualDial+86↓j
code:0000148E                                         ; DATA XREF: ConnectMenuESCHandler+15↑o
code:0000148E                 mov     DPTR, #VideoLine2
code:00001491                 mov     R2, #15
code:00001493                 lcall   ClearNLines
code:00001496                 lcall   DrawFunctionKeyMenu
code:00001499
code:00001499
code:00001499                 mov     DPTR, #aEntryMenu
code:0000149C                 acall   j_PrintDPTRPrefixedHiBtTermString
code:0000149E
code:0000149E
code:0000149E                 mov     DPTR, #DialStringEncoded
code:000014A1                 movx    A, @DPTR
code:000014A2                 jz      ChangeNumber
code:000014A4
code:000014A4
code:000014A4                 mov     DPTR, #DialStringEncoded
code:000014A7                 mov     R0, #((VideoLine20+0xF) & 0xFF)
code:000014A9                 mov     R1, #((VideoLine20+0xF) >> 8)
code:000014AB                 lcall   CStringCopy     ; Source = DPTR
code:000014AB                                         ; Dest = R1:R0
code:000014AE
code:000014AE MenuLoop:                               ; CODE XREF: ManualDial+2B↓j
code:000014AE                 lcall   WaitForSerialESCCode ; Returns the char after the ESC
code:000014B1
code:000014B1
code:000014B1                 mov     B, #4           ; B-Register
code:000014B4                 mov     DPTR, #ManualDialTable
code:000014B7                 acall   JmpSpecialFunction ; If the desired value is found in the tag lookup table, the
code:000014B7                                         ; function does not return.  Instead it jumps to the tag's
code:000014B7                                         ; associated code pointer.
code:000014B7                                         ;
code:000014B7                                         ; A = value to look up
code:000014B7                                         ; B = number of entries in table
code:000014B7                                         ; DPTR = table start
code:000014B9                 sjmp    MenuLoop
code:000014B9 ; ---------------------------------------------------------------------------
code:000014BB ManualDialTable:                        ; DATA XREF: ManualDial+26↑o
code:000014BB                 .byte '|
code:000014BC                 .word GoToConnectMenu
code:000014BE                 .byte 'A
code:000014BF                 .word ChangeNumber
code:000014C1                 .byte 'C
code:000014C2                 .word DialData
code:000014C4                 .byte 'D
code:000014C5                 .word DialVoice
code:000014C7 ; ---------------------------------------------------------------------------
code:000014C7
code:000014C7 DialVoice:                              ; DATA XREF: ManualDial+37↑o
code:000014C7                 setb    TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:000014C7                                         ; Bit 1 = BREAK is tracked as pressed
code:000014C7                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000014C7                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000014C7                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000014C7                                         ;         handler uses this to look for timeouts in each state.
code:000014C7                                         ; Bit 4 = Use immediate dial buffer
code:000014C7                                         ; Bit 5 = Dial voice
code:000014C7                                         ; Bit 6 = Disabling/Enabling a setting
code:000014C7                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000014C9                 ajmp    BeginDial
code:000014CB ; ---------------------------------------------------------------------------
code:000014CB
code:000014CB DialData:                               ; DATA XREF: ManualDial+34↑o
code:000014CB                 clr     TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:000014CB                                         ; Bit 1 = BREAK is tracked as pressed
code:000014CB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000014CB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000014CB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000014CB                                         ;         handler uses this to look for timeouts in each state.
code:000014CB                                         ; Bit 4 = Use immediate dial buffer
code:000014CB                                         ; Bit 5 = Dial voice
code:000014CB                                         ; Bit 6 = Disabling/Enabling a setting
code:000014CB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000014CD
code:000014CD BeginDial:                              ; CODE XREF: ManualDial+3B↑j
code:000014CD                 mov     DPTR, #DialStringEncoded
code:000014D0                 mov     R0, #(DialMiscBuffer & 0xFF)
code:000014D2                 mov     R1, #(DialMiscBuffer >> 8)
code:000014D4                 mov     R2, #0
code:000014D6                 lcall   DecodePhoneNumber
code:000014D9
code:000014D9
code:000014D9                 mov     TerminalState, #18 ; 18 is voice dial of immediate number
code:000014DC                 jb      TimerStatus.6, GoToConnectMenu ; Bit 0 = ESC is tracked as pressed
code:000014DC                                         ; Bit 1 = BREAK is tracked as pressed
code:000014DC                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000014DC                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000014DC                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000014DC                                         ;         handler uses this to look for timeouts in each state.
code:000014DC                                         ; Bit 4 = Use immediate dial buffer
code:000014DC                                         ; Bit 5 = Dial voice
code:000014DC                                         ; Bit 6 = Disabling/Enabling a setting
code:000014DC                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000014DF
code:000014DF
code:000014DF                 mov     TerminalState, #19 ; 19 is data dial of immediate number
code:000014E2
code:000014E2 GoToConnectMenu:                        ; CODE XREF: ManualDial+4E↑j
code:000014E2                                         ; ManualDial+71↓j ...
code:000014E2                 pop     ACC             ; Accumulator
code:000014E4                 pop     ACC             ; Accumulator
code:000014E6                 ajmp    ConnectMenuEntry
code:000014E8 ; ---------------------------------------------------------------------------
code:000014E8
code:000014E8 ChangeNumber:                           ; CODE XREF: ManualDial+14↑j
code:000014E8                                         ; DATA XREF: ManualDial+31↑o
code:000014E8                 mov     DPTR, #(VideoLine20+0xF)
code:000014EB                 mov     B, #21          ; B-Register
code:000014EE                 lcall   memset_spaces   ; B = count
code:000014EE                                         ; DPTR = address
code:000014F1
code:000014F1
code:000014F1                 mov     CursorColumn, #15
code:000014F4                 mov     CursorRow, #19
code:000014F7                 lcall   CalcCursorAddr  ; Updates the CursorAddr pointer using the cursor row and
code:000014F7                                         ; column and the line table for calculation.
code:000014F7                                         ;
code:000014F7                                         ; Does not account for attributes in the row.  This is a
code:000014F7                                         ; bug.
code:000014FA
code:000014FA
code:000014FA                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000014FA                                         ; Bit 1 = Receive buffer is full
code:000014FA                                         ; Bit 3 = Serial send register busy
code:000014FA                                         ; Bit 4 = Busy drawing to screen
code:000014FA                                         ; Bit 5 = Steady/Blink
code:000014FA                                         ; Bit 6 = Disable keyboard
code:000014FA                                         ; Bit 7 = Standard/Graphics
code:000014FC                 lcall   EditDialString
code:000014FF                 jnz     GoToConnectMenu
code:00001501
code:00001501
code:00001501                 mov     DPTR, #DigitsToDial ; This buffer holds the digits that are currently being
code:00001501                                         ; dialed.  The dial reader marks them out one by one as
code:00001501                                         ; each digit is rendered to the phone line.
code:00001504                 mov     R0, #(DialStringEncoded & 0xFF)
code:00001506                 mov     R1, #(DialStringEncoded >> 8)
code:00001508                 lcall   CStringCopy     ; Source = DPTR
code:00001508                                         ; Dest = R1:R0
code:0000150B
code:0000150B
code:0000150B                 push    IE              ; Interrupt Enable Register
code:0000150D                 clr     EA              ; Interrupt Enable Register
code:0000150F                 mov     P2, R1          ; Port 2
code:00001511                 movx    @R0, A
code:00001512                 pop     IE              ; Interrupt Enable Register
code:00001514
code:00001514
code:00001514                 ajmp    ManualDial
code:00001514 ; End of function ManualDial
code:00001514
code:00001516
code:00001516 ; =============== S U B R O U T I N E =======================================
code:00001516
code:00001516
code:00001516 EraseAllEntries:                        ; DATA XREF: EraseAllEntries+4F↓o
code:00001516                 lcall   ExecuteBell
code:00001519
code:00001519 ;
code:00001519 ; It would appear that holding ESC while pressing F4 will change from
code:00001519 ; "erase all entries" to "erase RAM"
code:00001519 ;
code:00001519                 mov     DPTR, #KeyboardShift ; Bit 0 = ESC
code:00001519                                         ; Bit 1 = CAPS lock
code:00001519                                         ; Bit 2 = Ctrl key
code:00001519                                         ; Bit 3 = SHIFT key
code:0000151C                 movx    A, @DPTR
code:0000151D                 mov     C, ACC0         ; Accumulator
code:0000151F                 mov     TimerStatus.6, C ; Bit 0 = ESC is tracked as pressed
code:0000151F                                         ; Bit 1 = BREAK is tracked as pressed
code:0000151F                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000151F                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000151F                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000151F                                         ;         handler uses this to look for timeouts in each state.
code:0000151F                                         ; Bit 4 = Use immediate dial buffer
code:0000151F                                         ; Bit 5 = Dial voice
code:0000151F                                         ; Bit 6 = Disabling/Enabling a setting
code:0000151F                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001521
code:00001521
code:00001521                 lcall   ClearBottomHalfScreen
code:00001524
code:00001524
code:00001524                 mov     R0, #(VideoLine18 & 0xFF)
code:00001526                 mov     R1, #(VideoLine18 >> 8)
code:00001528                 mov     DPTR, #aEraseAllEntries
code:0000152B                 jnb     TimerStatus.6, PrintEraseMsg ; Bit 0 = ESC is tracked as pressed
code:0000152B                                         ; Bit 1 = BREAK is tracked as pressed
code:0000152B                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000152B                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000152B                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000152B                                         ;         handler uses this to look for timeouts in each state.
code:0000152B                                         ; Bit 4 = Use immediate dial buffer
code:0000152B                                         ; Bit 5 = Dial voice
code:0000152B                                         ; Bit 6 = Disabling/Enabling a setting
code:0000152B                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000152E                 mov     DPTR, #aEraseRAM
code:00001531
code:00001531 PrintEraseMsg:                          ; CODE XREF: EraseAllEntries+15↑j
code:00001531                 acall   j_PrintCStringEntry ; R1:R0 = destination
code:00001531                                         ; DPTR = source
code:00001531                                         ;
code:00001531                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:00001533                 lcall   PrintOKConfirmationMsg
code:00001536
code:00001536 WaitForConfirmation:                    ; CODE XREF: EraseAllEntries:NotY↓j
code:00001536                 acall   j_WaitForSerialInput ; On return:
code:00001536                                         ;
code:00001536                                         ; A = next character
code:00001538                 lcall   Capitalize      ; Translates lower-case letters to upper-case.
code:00001538                                         ;
code:00001538                                         ; A = old value
code:00001538                                         ;
code:00001538                                         ; On return:
code:00001538                                         ;
code:00001538                                         ; C = untranslated
code:00001538                                         ; A = new value
code:0000153B                 cjne    A, #'Y, NotY
code:0000153E
code:0000153E
code:0000153E                 ajmp    GetDoubleConfirmation
code:00001540 ; ---------------------------------------------------------------------------
code:00001540
code:00001540 NotY:                                   ; CODE XREF: EraseAllEntries+25↑j
code:00001540                 cjne    A, #'N, WaitForConfirmation
code:00001543
code:00001543 ChangeDirectory:                        ; CODE XREF: EraseAllEntries+79↓j
code:00001543                                         ; EraseAllEntries+83↓j ...
code:00001543                 lcall   DrawFunctionKeyMenu
code:00001546                 mov     DPTR, #aDirectoryMenu
code:00001549                 acall   j_PrintDPTRPrefixedHiBtTermString
code:0000154B
code:0000154B WaitCommandLoop:                        ; CODE XREF: EraseAllEntries+40↓j
code:0000154B                 lcall   WaitForSerialESCCode ; Returns the char after the ESC
code:0000154E                 mov     B, #5           ; B-Register
code:00001551                 mov     DPTR, #ChangeDirectoryTable
code:00001554                 acall   JmpSpecialFunction ; If the desired value is found in the tag lookup table, the
code:00001554                                         ; function does not return.  Instead it jumps to the tag's
code:00001554                                         ; associated code pointer.
code:00001554                                         ;
code:00001554                                         ; A = value to look up
code:00001554                                         ; B = number of entries in table
code:00001554                                         ; DPTR = table start
code:00001556                 sjmp    WaitCommandLoop
code:00001556 ; ---------------------------------------------------------------------------
code:00001558 ChangeDirectoryTable:                   ; DATA XREF: EraseAllEntries+3B↑o
code:00001558                 .byte '|
code:00001559                 .word GoToConnectMenu
code:0000155B                 .byte 'A
code:0000155C                 .word AddEntry
code:0000155E                 .byte 'B
code:0000155F                 .word EraseEntry
code:00001561                 .byte 'C
code:00001562                 .word ChangeEntry
code:00001564                 .byte 'D
code:00001565                 .word EraseAllEntries
code:00001567 ; ---------------------------------------------------------------------------
code:00001567
code:00001567 ChangeEntry:                            ; DATA XREF: EraseAllEntries+4C↑o
code:00001567                 setb    TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:00001567                                         ; Bit 1 = BREAK is tracked as pressed
code:00001567                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001567                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001567                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001567                                         ;         handler uses this to look for timeouts in each state.
code:00001567                                         ; Bit 4 = Use immediate dial buffer
code:00001567                                         ; Bit 5 = Dial voice
code:00001567                                         ; Bit 6 = Disabling/Enabling a setting
code:00001567                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001569                 lcall   ClearBottomHalfScreen
code:0000156C                 lcall   PrintDialEntryForm
code:0000156F                 mov     DPTR, #aChange  ; "CHANGE "
code:00001572                 ajmp    PrintEntryForm
code:00001574 ; ---------------------------------------------------------------------------
code:00001574
code:00001574 GetDoubleConfirmation:                  ; CODE XREF: EraseAllEntries+28↑j
code:00001574                 lcall   PrintHoldSaveReturnMsg
code:00001577
code:00001577 WaitForDoubleConfirmation:              ; CODE XREF: EraseAllEntries:CheckForQuit↓j
code:00001577                                         ; EraseAllEntries+80↓j
code:00001577                 acall   j_WaitForSerialInput ; On return:
code:00001577                                         ;
code:00001577                                         ; A = next character
code:00001579                 cjne    A, #0xD, CheckForQuit
code:0000157C
code:0000157C
code:0000157C                 jnb     TimerStatus.6, DoEraseAllEntries ; Bit 0 = ESC is tracked as pressed
code:0000157C                                         ; Bit 1 = BREAK is tracked as pressed
code:0000157C                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000157C                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000157C                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000157C                                         ;         handler uses this to look for timeouts in each state.
code:0000157C                                         ; Bit 4 = Use immediate dial buffer
code:0000157C                                         ; Bit 5 = Dial voice
code:0000157C                                         ; Bit 6 = Disabling/Enabling a setting
code:0000157C                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000157F
code:0000157F ;
code:0000157F ; Confirmed to erase all RAM
code:0000157F ;
code:0000157F                 mov     DPTR, #DialMemoryCksum
code:00001582                 mov     R2, #11
code:00001584                 lcall   ClearNLines     ; Using the line-clear function on the dial memory to zero 11*96 bytes
code:00001587
code:00001587
code:00001587                 ajmp    ConnectMenu
code:00001589 ; ---------------------------------------------------------------------------
code:00001589
code:00001589 DoEraseAllEntries:                      ; CODE XREF: EraseAllEntries+66↑j
code:00001589                 lcall   InitializeDirectory
code:0000158C                 lcall   UpdateChecksumAndPrintDirectoryContents
code:0000158F                 sjmp    ChangeDirectory
code:00001591 ; ---------------------------------------------------------------------------
code:00001591
code:00001591 CheckForQuit:                           ; CODE XREF: EraseAllEntries+63↑j
code:00001591                 cjne    A, #0x1B, WaitForDoubleConfirmation
code:00001594                 acall   j_WaitForSerialInput ; On return:
code:00001594                                         ;
code:00001594                                         ; A = next character
code:00001596                 cjne    A, #'|, WaitForDoubleConfirmation
code:00001599                 sjmp    ChangeDirectory
code:0000159B ; ---------------------------------------------------------------------------
code:0000159B
code:0000159B AddEntry:                               ; DATA XREF: EraseAllEntries+46↑o
code:0000159B                 clr     TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:0000159B                                         ; Bit 1 = BREAK is tracked as pressed
code:0000159B                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000159B                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000159B                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000159B                                         ;         handler uses this to look for timeouts in each state.
code:0000159B                                         ; Bit 4 = Use immediate dial buffer
code:0000159B                                         ; Bit 5 = Dial voice
code:0000159B                                         ; Bit 6 = Disabling/Enabling a setting
code:0000159B                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000159D                 lcall   ClearBottomHalfScreen
code:000015A0                 lcall   PrintDialEntryForm
code:000015A3                 mov     DPTR, #aAdd     ; "ADD "
code:000015A6
code:000015A6 PrintEntryForm:                         ; CODE XREF: EraseAllEntries+5C↑j
code:000015A6                 lcall   PrintHiBitTermString
code:000015A9                 lcall   WaitDirectoryItemSelection
code:000015AC                 jnz     SelectedEntry
code:000015AE
code:000015AE
code:000015AE                 sjmp    ChangeDirectory
code:000015B0 ; ---------------------------------------------------------------------------
code:000015B0
code:000015B0 SelectedEntry:                          ; CODE XREF: EraseAllEntries+96↑j
code:000015B0                 jb      TimerStatus.6, SelectionOk ; Bit 0 = ESC is tracked as pressed
code:000015B0                                         ; Bit 1 = BREAK is tracked as pressed
code:000015B0                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000015B0                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000015B0                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000015B0                                         ;         handler uses this to look for timeouts in each state.
code:000015B0                                         ; Bit 4 = Use immediate dial buffer
code:000015B0                                         ; Bit 5 = Dial voice
code:000015B0                                         ; Bit 6 = Disabling/Enabling a setting
code:000015B0                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000015B3                 lcall   LookupNthDirectoryEntry ; TmpI = entry number
code:000015B3                                         ;
code:000015B3                                         ; Sets DirEntryType.
code:000015B3                                         ;
code:000015B3                                         ; Returns start of name
code:000015B6                 jz      SelectionOk
code:000015B8
code:000015B8 ;
code:000015B8 ; Can't add if it already exists!
code:000015B8 ;
code:000015B8                 mov     DPTR, #aInUsePressRETURN
code:000015BB                 lcall   PrintRowColPrefixedHiBitTermString
code:000015BE                 acall   j_WaitForSerialInput ; On return:
code:000015BE                                         ;
code:000015BE                                         ; A = next character
code:000015C0                 sjmp    ChangeDirectory
code:000015C2 ; ---------------------------------------------------------------------------
code:000015C2
code:000015C2 SelectionOk:                            ; CODE XREF: EraseAllEntries:SelectedEntry↑j
code:000015C2                                         ; EraseAllEntries+A0↑j
code:000015C2                 mov     DPTR, #DialLoginScript
code:000015C5                 clr     A
code:000015C6                 movx    @DPTR, A
code:000015C7                 inc     DPTR
code:000015C8                 movx    @DPTR, A
code:000015C9
code:000015C9
code:000015C9                 mov     DPTR, #aName
code:000015CC                 lcall   PrintRowColPrefixedHiBitTermString
code:000015CF
code:000015CF
code:000015CF                 mov     ContextFunctionPtr+1, #(DialName & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000015D2                 mov     ContextFunctionPtr, #(DialName >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000015D5
code:000015D5
code:000015D5                 mov     R7, #12
code:000015D7                 lcall   InputFormLine   ; DPTR = where on screen
code:000015D7                                         ; ContextFunctionPtr = final destination buffer
code:000015D7                                         ; R7 = limit
code:000015DA                 jz      NameSuccess
code:000015DC
code:000015DC
code:000015DC                 ajmp    j_ChangeDirectory
code:000015DE ; ---------------------------------------------------------------------------
code:000015DE
code:000015DE NameSuccess:                            ; CODE XREF: EraseAllEntries+C4↑j
code:000015DE                                         ; EraseAllEntries+D8↓j
code:000015DE                 mov     DPTR, #aPhone
code:000015E1                 lcall   PrintRowColPrefixedHiBitTermString
code:000015E4                 lcall   EditDialString
code:000015E7                 jz      NumberSuccess
code:000015E9
code:000015E9
code:000015E9                 ajmp    j_ChangeDirectory
code:000015EB ; ---------------------------------------------------------------------------
code:000015EB
code:000015EB ;
code:000015EB ; If we left the number blank, go back to ask for the name
code:000015EB ;
code:000015EB
code:000015EB NumberSuccess:                          ; CODE XREF: EraseAllEntries+D1↑j
code:000015EB                 cjne    R6, #0, GetCallType
code:000015EE
code:000015EE
code:000015EE                 sjmp    NameSuccess
code:000015F0 ; ---------------------------------------------------------------------------
code:000015F0
code:000015F0 GetCallType:                            ; CODE XREF: EraseAllEntries:NumberSuccess↑j
code:000015F0                 mov     DPTR, #aCallType ; "Call type ("
code:000015F3                 mov     R0, #(VideoLine21 & 0xFF)
code:000015F5                 mov     R1, #(VideoLine21 >> 8)
code:000015F7                 acall   j_PrintCStringEntry ; R1:R0 = destination
code:000015F7                                         ; DPTR = source
code:000015F7                                         ;
code:000015F7                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:000015F9                 mov     CursorRow, #20
code:000015FC                 mov     CursorColumn, #59
code:000015FF                 lcall   CalcColumnPtr   ; Find the address of the row and column, accounting for
code:000015FF                                         ; attributes
code:00001602
code:00001602
code:00001602                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001602                                         ; Bit 1 = Receive buffer is full
code:00001602                                         ; Bit 3 = Serial send register busy
code:00001602                                         ; Bit 4 = Busy drawing to screen
code:00001602                                         ; Bit 5 = Steady/Blink
code:00001602                                         ; Bit 6 = Disable keyboard
code:00001602                                         ; Bit 7 = Standard/Graphics
code:00001604
code:00001604 WaitCallTypeLoop:                       ; CODE XREF: EraseAllEntries+F5↓j
code:00001604                                         ; EraseAllEntries+103↓j
code:00001604                 acall   j_WaitForSerialInput ; On return:
code:00001604                                         ;
code:00001604                                         ; A = next character
code:00001606                 cjne    A, #0x1B, NotESC
code:00001609                 acall   j_WaitForSerialInput ; On return:
code:00001609                                         ;
code:00001609                                         ; A = next character
code:0000160B                 cjne    A, #'|, WaitCallTypeLoop
code:0000160E                 ajmp    j_ChangeDirectory
code:00001610 ; ---------------------------------------------------------------------------
code:00001610
code:00001610 NotESC:                                 ; CODE XREF: EraseAllEntries+F0↑j
code:00001610                 lcall   Capitalize      ; Translates lower-case letters to upper-case.
code:00001610                                         ;
code:00001610                                         ; A = old value
code:00001610                                         ;
code:00001610                                         ; On return:
code:00001610                                         ;
code:00001610                                         ; C = untranslated
code:00001610                                         ; A = new value
code:00001613                 push    ACC             ; Accumulator
code:00001615                 acall   TranslateCallTypeText ; Result will be:
code:00001615                                         ;   8 = Voice
code:00001615                                         ;   9 = Data
code:00001615                                         ;   10 = Source Direct
code:00001615                                         ;   11 = Tymnet
code:00001615                                         ;   12 = Telenet
code:00001615                                         ;   CY = invalid
code:00001615                                         ;
code:00001615                                         ; Valid results will be written to DirEntryType
code:00001617                 pop     ACC             ; Accumulator
code:00001619                 jc      WaitCallTypeLoop
code:0000161B
code:0000161B
code:0000161B                 acall   j_TypeCharAsIs
code:0000161D
code:0000161D
code:0000161D                 acall   LookupDialTypeScript ; Stores address of script into DPTR.  Uses DirEntryType to look up
code:0000161D                                         ; script.  Clears DialStringCursor.
code:0000161F                 acall   GetNextNibbleFromByteString ; uses DialStringCursor and DPTR to get next nibble from a byte string
code:00001621
code:00001621
code:00001621                 mov     ContextFunctionPtr+1, #(DialLoginScript & 0xFF) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00001624                 mov     ContextFunctionPtr, #(DialLoginScript >> 8) ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00001627                 mov     R0, ContextFunctionPtr+1 ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00001629                 mov     R1, ContextFunctionPtr ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:0000162B
code:0000162B
code:0000162B                 jz      NoLogon
code:0000162D
code:0000162D
code:0000162D                 mov     DPTR, #aLogOn
code:00001630                 lcall   PrintRowColPrefixedHiBitTermString
code:00001633
code:00001633
code:00001633                 acall   LookupDialTypeScript ; Stores address of script into DPTR.  Uses DirEntryType to look up
code:00001633                                         ; script.  Clears DialStringCursor.
code:00001635                 mov     R7, #67
code:00001637
code:00001637 GetLength:                              ; CODE XREF: EraseAllEntries+125↓j
code:00001637                                         ; EraseAllEntries+172↓j
code:00001637                 acall   GetNextNibbleFromByteString ; uses DialStringCursor and DPTR to get next nibble from a byte string
code:00001639                 jz      NoLogon
code:0000163B
code:0000163B
code:0000163B                 cjne    A, #8, GetLength
code:0000163E
code:0000163E
code:0000163E                 push    DPL             ; Data Pointer, Low Byte
code:00001640                 push    DPH             ; Data Pointer, High Byte
code:00001642                 lcall   InputFormLine   ; DPTR = where on screen
code:00001642                                         ; ContextFunctionPtr = final destination buffer
code:00001642                                         ; R7 = limit
code:00001645                 jz      TerminateString
code:00001647
code:00001647
code:00001647                 pop     DPH             ; Data Pointer, High Byte
code:00001649                 pop     DPL             ; Data Pointer, Low Byte
code:0000164B                 ajmp    j_ChangeDirectory
code:0000164D ; ---------------------------------------------------------------------------
code:0000164D
code:0000164D TerminateString:                        ; CODE XREF: EraseAllEntries+12F↑j
code:0000164D                 movx    @DPTR, A
code:0000164E
code:0000164E
code:0000164E                 inc     CursorColumn
code:00001650                 inc     DPTR
code:00001651                 mov     CursorAddr, DPH ; Data Pointer, High Byte
code:00001654                 mov     CursorAddr+1, DPL ; Data Pointer, Low Byte
code:00001657                 pop     DPH             ; Data Pointer, High Byte
code:00001659                 pop     DPL             ; Data Pointer, Low Byte
code:0000165B                 cjne    A, B0R0, code_165F
code:0000165E
code:0000165E
code:0000165E                 dec     R1
code:0000165F
code:0000165F code_165F:                              ; CODE XREF: EraseAllEntries+145↑j
code:0000165F                 dec     R0
code:00001660                 dec     R2
code:00001661                 cjne    A, B0R6, code_167A
code:00001664
code:00001664
code:00001664                 mov     A, #'.
code:00001666                 lcall   PrintCharToVRAMIncR2 ; Increments R2 and writes a character to the screen.
code:00001666                                         ;
code:00001666                                         ; R1:R0 = screen location
code:00001666                                         ; R2 = count
code:00001669
code:00001669 NoLogon:                                ; CODE XREF: EraseAllEntries+115↑j
code:00001669                                         ; EraseAllEntries+123↑j ...
code:00001669                 mov     A, #0xFF
code:0000166B                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:0000166B                                         ;
code:0000166B                                         ; R1:R0 = destination
code:0000166B                                         ; A = character
code:0000166B                                         ;
code:0000166B                                         ; Auto-increments R1:R0
code:0000166D                 lcall   PrintOKConfirmationMsg
code:00001670
code:00001670 WaitYNConfirmationLoop:                 ; CODE XREF: EraseAllEntries:TestForNo↓j
code:00001670                 acall   j_WaitForSerialInput ; On return:
code:00001670                                         ;
code:00001670                                         ; A = next character
code:00001672                 lcall   Capitalize      ; Translates lower-case letters to upper-case.
code:00001672                                         ;
code:00001672                                         ; A = old value
code:00001672                                         ;
code:00001672                                         ; On return:
code:00001672                                         ;
code:00001672                                         ; C = untranslated
code:00001672                                         ; A = new value
code:00001675                 cjne    A, #'Y, TestForNo
code:00001678
code:00001678
code:00001678                 ajmp    AssembleDialBuffer
code:0000167A ; ---------------------------------------------------------------------------
code:0000167A
code:0000167A code_167A:                              ; CODE XREF: EraseAllEntries+14B↑j
code:0000167A                 acall   GetNextNibbleFromByteString ; uses DialStringCursor and DPTR to get next nibble from a byte string
code:0000167C                 jz      NoLogon
code:0000167E
code:0000167E
code:0000167E                 dec     DialStringCursor
code:00001680                 clr     A
code:00001681                 lcall   PrintCharToVRAMIncR2 ; Increments R2 and writes a character to the screen.
code:00001681                                         ;
code:00001681                                         ; R1:R0 = screen location
code:00001681                                         ; R2 = count
code:00001684                 mov     ContextFunctionPtr, R1 ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00001686                 mov     ContextFunctionPtr+1, R0 ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:00001688                 sjmp    GetLength
code:0000168A ; ---------------------------------------------------------------------------
code:0000168A
code:0000168A TestForNo:                              ; CODE XREF: EraseAllEntries+15F↑j
code:0000168A                 cjne    A, #'N, WaitYNConfirmationLoop
code:0000168D
code:0000168D j_ChangeDirectory:                      ; CODE XREF: EraseAllEntries+C6↑j
code:0000168D                                         ; EraseAllEntries+D3↑j ...
code:0000168D                 ajmp    ChangeDirectory
code:0000168F ; ---------------------------------------------------------------------------
code:0000168F
code:0000168F AssembleDialBuffer:                     ; CODE XREF: EraseAllEntries+162↑j
code:0000168F                 lcall   TranslateDirTypeAndTelNumText
code:00001692                 lcall   StringToNibbles ; DialName = Source
code:00001692                                         ; R0:R1 = Destination
code:00001692                                         ; R2 = output count
code:00001692                                         ;
code:00001692                                         ; Copies until 0 found
code:00001695                 mov     A, #0xF
code:00001697                 lcall   PrintCharToVRAMIncR2 ; Increments R2 and writes a character to the screen.
code:00001697                                         ;
code:00001697                                         ; R1:R0 = screen location
code:00001697                                         ; R2 = count
code:0000169A
code:0000169A
code:0000169A                 lcall   SaveLoginScript
code:0000169D
code:0000169D
code:0000169D                 mov     B0R7, R2
code:0000169F                 acall   GetEntryMovementAmount ; Sets carry if no room in dialup memory
code:0000169F                                         ;
code:0000169F                                         ; R7 = new entry size
code:000016A1                 jnc     CanMakeChange
code:000016A3
code:000016A3
code:000016A3                 lcall   ExecuteBell
code:000016A6                 mov     DPTR, #aMemoryFull
code:000016A9                 mov     R0, #(VideoLine25 & 0xFF)
code:000016AB                 mov     R1, #(VideoLine25 >> 8)
code:000016AD                 acall   j_PrintCStringEntry ; R1:R0 = destination
code:000016AD                                         ; DPTR = source
code:000016AD                                         ;
code:000016AD                                         ; Prints until a 0 found.  Auto-increments R1:R0
code:000016AF                 mov     CursorColumn, #25
code:000016B2                 mov     CursorRow, #24
code:000016B5                 acall   j_WaitForSerialInput ; On return:
code:000016B5                                         ;
code:000016B5                                         ; A = next character
code:000016B7                 sjmp    j_ChangeDirectory
code:000016B9 ; ---------------------------------------------------------------------------
code:000016B9
code:000016B9 CanMakeChange:                          ; CODE XREF: EraseAllEntries+18B↑j
code:000016B9                 lcall   PrintHoldSaveReturnMsg
code:000016BC
code:000016BC WaitConfirmationLoop:                   ; CODE XREF: EraseAllEntries:CheckForQuit1↓j
code:000016BC                                         ; EraseAllEntries+1BB↓j
code:000016BC                 acall   j_WaitForSerialInput ; On return:
code:000016BC                                         ;
code:000016BC                                         ; A = next character
code:000016BE                 cjne    A, #0xD, CheckForQuit1
code:000016C1
code:000016C1
code:000016C1                 lcall   MoveMemory      ; Shifts memory to make room for the modified entry.
code:000016C4                 lcall   SaveDirectoryEntry
code:000016C7                 lcall   UpdatePhoneBookCksum
code:000016CA                 ajmp    GoToConnectMenu
code:000016CC ; ---------------------------------------------------------------------------
code:000016CC
code:000016CC CheckForQuit1:                          ; CODE XREF: EraseAllEntries+1A8↑j
code:000016CC                 cjne    A, #0x1B, WaitConfirmationLoop
code:000016CF                 acall   j_WaitForSerialInput ; On return:
code:000016CF                                         ;
code:000016CF                                         ; A = next character
code:000016D1                 cjne    A, #'|, WaitConfirmationLoop
code:000016D4                 sjmp    j_ChangeDirectory
code:000016D4 ; End of function EraseAllEntries
code:000016D4
code:000016D6
code:000016D6 ; =============== S U B R O U T I N E =======================================
code:000016D6
code:000016D6 ; 16-bit subtraction
code:000016D6 ; DPTR = LHS
code:000016D6 ; R1:R0 = RHS
code:000016D6 ;
code:000016D6 ; On return:
code:000016D6 ;
code:000016D6 ; R3:R2 = difference
code:000016D6 ;
code:000016D6
code:000016D6 Sub16:                                  ; CODE XREF: GetEntryMovementAmount+1C↓p
code:000016D6                                         ; GetLengthOfNthEntry+12↓p ...
code:000016D6                 mov     A, DPL          ; Data Pointer, Low Byte
code:000016D8                 clr     C
code:000016D9                 subb    A, R0
code:000016DA                 mov     R2, A
code:000016DB                 mov     A, DPH          ; Data Pointer, High Byte
code:000016DD                 subb    A, R1
code:000016DE                 mov     R3, A
code:000016DF                 ret
code:000016DF ; End of function Sub16
code:000016DF
code:000016E0
code:000016E0 ; =============== S U B R O U T I N E =======================================
code:000016E0
code:000016E0 ; Sets carry if no room in dialup memory
code:000016E0 ;
code:000016E0 ; R7 = new entry size
code:000016E0
code:000016E0 GetEntryMovementAmount:                 ; CODE XREF: EraseAllEntries+189↑p
code:000016E0                 acall   GetLengthOfNthEntry ; Sets TimerStatus.6 if current length is different from new length
code:000016E0                                         ; Sets TimerStatus.7 to borrow flag (New length is shorter)
code:000016E0                                         ; R7 = new length
code:000016E2                 mov     R6, B0R2
code:000016E4                 clr     C
code:000016E5                 jnb     TimerStatus.7, IsLonger ; Bit 0 = ESC is tracked as pressed
code:000016E5                                         ; Bit 1 = BREAK is tracked as pressed
code:000016E5                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000016E5                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000016E5                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000016E5                                         ;         handler uses this to look for timeouts in each state.
code:000016E5                                         ; Bit 4 = Use immediate dial buffer
code:000016E5                                         ; Bit 5 = Dial voice
code:000016E5                                         ; Bit 6 = Disabling/Enabling a setting
code:000016E5                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000016E8                 ret
code:000016E9 ; ---------------------------------------------------------------------------
code:000016E9
code:000016E9 IsLonger:                               ; CODE XREF: GetEntryMovementAmount+5↑j
code:000016E9                 subb    A, R2           ; Find out how much to move the rest
code:000016EA                 mov     R4, A
code:000016EB
code:000016EB
code:000016EB                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:000016EB                                         ; settings index
code:000016ED                 mov     TmpI, #27       ; Often the phone book entry number, but can also be used as
code:000016ED                                         ; settings index
code:000016F0                 lcall   FindNthDirectoryEntry ; TmpI = entry number
code:000016F0                                         ;
code:000016F0                                         ; On return:
code:000016F0                                         ;
code:000016F0                                         ; A = entry type
code:000016F0                                         ; DPTR = entry address
code:000016F0                                         ; TmpI is destroyed
code:000016F3                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:000016F3                                         ; settings index
code:000016F5
code:000016F5
code:000016F5                 mov     R0, DPL         ; Data Pointer, Low Byte
code:000016F7                 mov     R1, DPH         ; Data Pointer, High Byte
code:000016F9                 mov     DPTR, #DialMemoryLimit
code:000016FC                 acall   Sub16           ; 16-bit subtraction
code:000016FC                                         ; DPTR = LHS
code:000016FC                                         ; R1:R0 = RHS
code:000016FC                                         ;
code:000016FC                                         ; On return:
code:000016FC                                         ;
code:000016FC                                         ; R3:R2 = difference
code:000016FC                                         ;
code:000016FE                 cjne    R3, #0, ThereIsRoom
code:00001701
code:00001701
code:00001701                 mov     A, R4
code:00001702                 cjne    A, B0R2, code_1705
code:00001705
code:00001705 code_1705:                              ; CODE XREF: GetEntryMovementAmount+22↑j
code:00001705                 jnc     NoRoom
code:00001707
code:00001707 ThereIsRoom:                            ; CODE XREF: GetEntryMovementAmount+1E↑j
code:00001707                 clr     C
code:00001708                 ret
code:00001709 ; ---------------------------------------------------------------------------
code:00001709
code:00001709 NoRoom:                                 ; CODE XREF: GetEntryMovementAmount:code_1705↑j
code:00001709                 setb    C
code:0000170A                 ret
code:0000170A ; End of function GetEntryMovementAmount
code:0000170A
code:0000170B ; [00000003 BYTES: COLLAPSED FUNCTION j_FindNthDirectoryEntry. PRESS CTRL-NUMPAD+ TO EXPAND]
code:0000170E
code:0000170E ; =============== S U B R O U T I N E =======================================
code:0000170E
code:0000170E ; Sets TimerStatus.6 if current length is different from new length
code:0000170E ; Sets TimerStatus.7 to borrow flag (New length is shorter)
code:0000170E ; R7 = new length
code:0000170E
code:0000170E GetLengthOfNthEntry:                    ; CODE XREF: GetEntryMovementAmount↑p
code:0000170E                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:0000170E                                         ; settings index
code:00001710                 acall   j_FindNthDirectoryEntry ; TmpI = entry number
code:00001710                                         ;
code:00001710                                         ; On return:
code:00001710                                         ;
code:00001710                                         ; A = entry type
code:00001712                 mov     R0, DPL         ; Data Pointer, Low Byte
code:00001714                 mov     R1, DPH         ; Data Pointer, High Byte
code:00001716                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:00001716                                         ; settings index
code:00001718
code:00001718
code:00001718                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:00001718                                         ; settings index
code:0000171A                 inc     TmpI            ; Often the phone book entry number, but can also be used as
code:0000171A                                         ; settings index
code:0000171C                 acall   j_FindNthDirectoryEntry ; TmpI = entry number
code:0000171C                                         ;
code:0000171C                                         ; On return:
code:0000171C                                         ;
code:0000171C                                         ; A = entry type
code:0000171E                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:0000171E                                         ; settings index
code:00001720
code:00001720
code:00001720                 acall   Sub16           ; 16-bit subtraction
code:00001720                                         ; DPTR = LHS
code:00001720                                         ; R1:R0 = RHS
code:00001720                                         ;
code:00001720                                         ; On return:
code:00001720                                         ;
code:00001720                                         ; R3:R2 = difference
code:00001720                                         ;
code:00001722                 mov     A, R7
code:00001723
code:00001723
code:00001723                 clr     TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:00001723                                         ; Bit 1 = BREAK is tracked as pressed
code:00001723                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001723                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001723                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001723                                         ;         handler uses this to look for timeouts in each state.
code:00001723                                         ; Bit 4 = Use immediate dial buffer
code:00001723                                         ; Bit 5 = Dial voice
code:00001723                                         ; Bit 6 = Disabling/Enabling a setting
code:00001723                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001725                 clr     TimerStatus.7   ; Bit 0 = ESC is tracked as pressed
code:00001725                                         ; Bit 1 = BREAK is tracked as pressed
code:00001725                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:00001725                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:00001725                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:00001725                                         ;         handler uses this to look for timeouts in each state.
code:00001725                                         ; Bit 4 = Use immediate dial buffer
code:00001725                                         ; Bit 5 = Dial voice
code:00001725                                         ; Bit 6 = Disabling/Enabling a setting
code:00001725                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:00001727                 cjne    A, B0R2, code_172B
code:0000172A
code:0000172A
code:0000172A                 ret
code:0000172B ; ---------------------------------------------------------------------------
code:0000172B
code:0000172B code_172B:                              ; CODE XREF: GetLengthOfNthEntry+19↑j
code:0000172B                 setb    TimerStatus.6   ; Bit 0 = ESC is tracked as pressed
code:0000172B                                         ; Bit 1 = BREAK is tracked as pressed
code:0000172B                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000172B                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000172B                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000172B                                         ;         handler uses this to look for timeouts in each state.
code:0000172B                                         ; Bit 4 = Use immediate dial buffer
code:0000172B                                         ; Bit 5 = Dial voice
code:0000172B                                         ; Bit 6 = Disabling/Enabling a setting
code:0000172B                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000172D                 mov     TimerStatus.7, C ; Bit 0 = ESC is tracked as pressed
code:0000172D                                         ; Bit 1 = BREAK is tracked as pressed
code:0000172D                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:0000172D                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:0000172D                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:0000172D                                         ;         handler uses this to look for timeouts in each state.
code:0000172D                                         ; Bit 4 = Use immediate dial buffer
code:0000172D                                         ; Bit 5 = Dial voice
code:0000172D                                         ; Bit 6 = Disabling/Enabling a setting
code:0000172D                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:0000172F                 ret
code:0000172F ; End of function GetLengthOfNthEntry
code:0000172F
code:00001730
code:00001730 ; =============== S U B R O U T I N E =======================================
code:00001730
code:00001730 ; Result will be:
code:00001730 ;   8 = Voice
code:00001730 ;   9 = Data
code:00001730 ;   10 = Source Direct
code:00001730 ;   11 = Tymnet
code:00001730 ;   12 = Telenet
code:00001730 ;   CY = invalid
code:00001730 ;
code:00001730 ; Valid results will be written to DirEntryType
code:00001730
code:00001730 TranslateCallTypeText:                  ; CODE XREF: EraseAllEntries+FF↑p
code:00001730                 mov     DPTR, #aVdsyt   ; "VDSYT   "
code:00001733                 mov     R0, #5
code:00001735                 mov     R2, A
code:00001736                 mov     R1, #7
code:00001738
code:00001738 CharSearchLoop:                         ; CODE XREF: TranslateCallTypeText:NextLetter↓j
code:00001738                 inc     R1
code:00001739                 clr     A
code:0000173A                 movc    A, @A+DPTR
code:0000173B                 inc     DPTR
code:0000173C                 cjne    A, B0R2, NextLetter
code:0000173F
code:0000173F
code:0000173F                 clr     C
code:00001740                 mov     DirEntryType, R1
code:00001742                 ret
code:00001743 ; ---------------------------------------------------------------------------
code:00001743
code:00001743 NextLetter:                             ; CODE XREF: TranslateCallTypeText+C↑j
code:00001743                 djnz    R0, CharSearchLoop
code:00001745
code:00001745
code:00001745                 setb    C
code:00001746                 ret
code:00001746 ; End of function TranslateCallTypeText
code:00001746
code:00001747
code:00001747 ; =============== S U B R O U T I N E =======================================
code:00001747
code:00001747
code:00001747 EraseEntry:                             ; DATA XREF: EraseAllEntries+49↑o
code:00001747                 lcall   ClearBottomHalfScreen
code:0000174A                 lcall   PrintDialEntryForm
code:0000174D
code:0000174D
code:0000174D                 mov     DPTR, #aErase   ; "ERASE "
code:00001750                 lcall   PrintHiBitTermString
code:00001753
code:00001753
code:00001753                 lcall   WaitDirectoryItemSelection
code:00001756                 jnz     CheckDirectorySlot
code:00001758
code:00001758 ReturnGate:                             ; CODE XREF: EraseEntry+72↓j
code:00001758                 ajmp    ChangeDirectory
code:0000175A ; ---------------------------------------------------------------------------
code:0000175A
code:0000175A CheckDirectorySlot:                     ; CODE XREF: EraseEntry+F↑j
code:0000175A                 lcall   LookupNthDirectoryEntry ; TmpI = entry number
code:0000175A                                         ;
code:0000175A                                         ; Sets DirEntryType.
code:0000175A                                         ;
code:0000175A                                         ; Returns start of name
code:0000175D                 jnz     IsIndeedInUse
code:0000175F
code:0000175F
code:0000175F                 mov     DPTR, #aNotUsedPressRETURN
code:00001762                 lcall   PrintRowColPrefixedHiBitTermString
code:00001765
code:00001765
code:00001765                 acall   j_WaitForSerialInput ; On return:
code:00001765                                         ;
code:00001765                                         ; A = next character
code:00001767                 ajmp    ChangeDirectory
code:00001769 ; ---------------------------------------------------------------------------
code:00001769
code:00001769 IsIndeedInUse:                          ; CODE XREF: EraseEntry+16↑j
code:00001769                 lcall   PrintHoldSaveReturnMsg
code:0000176C
code:0000176C WaitConfirmationLoop:                   ; CODE XREF: EraseEntry:CheckQuit↓j
code:0000176C                                         ; EraseEntry+6F↓j
code:0000176C                 acall   j_WaitForSerialInput ; On return:
code:0000176C                                         ;
code:0000176C                                         ; A = next character
code:0000176E                 cjne    A, #0xD, CheckQuit
code:00001771
code:00001771
code:00001771                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:00001771                                         ; settings index
code:00001773                 acall   j_FindNthDirectoryEntry ; TmpI = entry number
code:00001773                                         ;
code:00001773                                         ; On return:
code:00001773                                         ;
code:00001773                                         ; A = entry type
code:00001775                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:00001775                                         ; settings index
code:00001777
code:00001777
code:00001777                 push    DPL             ; Data Pointer, Low Byte
code:00001779                 push    DPH             ; Data Pointer, High Byte
code:0000177B                 lcall   GetRemainingSizeOfDirectory ; On return:
code:0000177B                                         ;
code:0000177B                                         ; R3:R2 = difference
code:0000177E                 pop     DPH             ; Data Pointer, High Byte
code:00001780                 pop     DPL             ; Data Pointer, Low Byte
code:00001782
code:00001782 ;
code:00001782 ; Write an empty directory entry
code:00001782 ;
code:00001782                 acall   j_DecrementDPTR
code:00001784                 mov     A, #0xF
code:00001786                 movx    @DPTR, A
code:00001787
code:00001787
code:00001787                 inc     DPTR
code:00001788                 clr     A
code:00001789                 movx    @DPTR, A
code:0000178A
code:0000178A
code:0000178A                 inc     DPTR
code:0000178B                 mov     A, #0xF
code:0000178D                 movx    @DPTR, A
code:0000178E
code:0000178E ;
code:0000178E ; Calculate how much to shrink phone book memory
code:0000178E ;
code:0000178E                 inc     DPTR
code:0000178F                 mov     A, R0
code:00001790                 dec     A
code:00001791                 clr     C
code:00001792                 subb    A, DPL          ; Data Pointer, Low Byte
code:00001794
code:00001794
code:00001794                 mov     B, R2           ; B-Register
code:00001796                 inc     B               ; B-Register
code:00001798                 djnz    B, code_179D    ; B-Register
code:0000179B
code:0000179B
code:0000179B                 ajmp    DeleteFullBlocks
code:0000179D ; ---------------------------------------------------------------------------
code:0000179D
code:0000179D code_179D:                              ; CODE XREF: EraseEntry+51↑j
code:0000179D                 lcall   MoveNCharsBack  ; DPTR+A = source of move
code:0000179D                                         ; DPTR = destination of move
code:0000179D                                         ; B = number of chars to move
code:000017A0
code:000017A0 DeleteFullBlocks:                       ; CODE XREF: EraseEntry+54↑j
code:000017A0                 inc     R3
code:000017A1
code:000017A1 DeleteBlockNext:                        ; CODE XREF: EraseEntry+68↓j
code:000017A1                 djnz    R3, DeleteBlockLoop
code:000017A3
code:000017A3
code:000017A3                 mov     A, #0xF
code:000017A5                 acall   j_PutCharToVRAM ; Note that this is sometimes called for beyond displayed range of VRAM
code:000017A5                                         ;
code:000017A5                                         ; R1:R0 = destination
code:000017A5                                         ; A = character
code:000017A5                                         ;
code:000017A5                                         ; Auto-increments R1:R0
code:000017A7
code:000017A7
code:000017A7                 lcall   UpdatePhoneBookCksum
code:000017AA                 ajmp    GoToConnectMenu
code:000017AC ; ---------------------------------------------------------------------------
code:000017AC
code:000017AC DeleteBlockLoop:                        ; CODE XREF: EraseEntry:DeleteBlockNext↑j
code:000017AC                 lcall   CopyBlock       ; Copies B chars from DPTR to R1:R0
code:000017AC                                         ;
code:000017AC                                         ; If B=0, copies 256 bytes
code:000017AF                 sjmp    DeleteBlockNext
code:000017B1 ; ---------------------------------------------------------------------------
code:000017B1
code:000017B1 CheckQuit:                              ; CODE XREF: EraseEntry+27↑j
code:000017B1                 cjne    A, #0x1B, WaitConfirmationLoop
code:000017B4                 acall   j_WaitForSerialInput ; On return:
code:000017B4                                         ;
code:000017B4                                         ; A = next character
code:000017B6                 cjne    A, #'|, WaitConfirmationLoop
code:000017B9                 sjmp    ReturnGate
code:000017B9 ; End of function EraseEntry
code:000017B9
code:000017BB
code:000017BB ; =============== S U B R O U T I N E =======================================
code:000017BB
code:000017BB ; Shifts memory to make room for the modified entry.
code:000017BB
code:000017BB MoveMemory:                             ; CODE XREF: EraseAllEntries+1AB↑p
code:000017BB                 jnb     TimerStatus.6, ReturnGate ; Bit 0 = ESC is tracked as pressed
code:000017BB                                         ; Bit 1 = BREAK is tracked as pressed
code:000017BB                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000017BB                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000017BB                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000017BB                                         ;         handler uses this to look for timeouts in each state.
code:000017BB                                         ; Bit 4 = Use immediate dial buffer
code:000017BB                                         ; Bit 5 = Dial voice
code:000017BB                                         ; Bit 6 = Disabling/Enabling a setting
code:000017BB                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000017BE                 lcall   GetRemainingSizeOfDirectory ; On return:
code:000017BE                                         ;
code:000017BE                                         ; R3:R2 = difference
code:000017C1
code:000017C1
code:000017C1                 mov     B, R2           ; B-Register
code:000017C3                 inc     B               ; B-Register
code:000017C5                 jnb     TimerStatus.7, AddPartialBlock ; Bit 0 = ESC is tracked as pressed
code:000017C5                                         ; Bit 1 = BREAK is tracked as pressed
code:000017C5                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
code:000017C5                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
code:000017C5                                         ;         cleared by the timer ISR when it expires.  The terminal state
code:000017C5                                         ;         handler uses this to look for timeouts in each state.
code:000017C5                                         ; Bit 4 = Use immediate dial buffer
code:000017C5                                         ; Bit 5 = Dial voice
code:000017C5                                         ; Bit 6 = Disabling/Enabling a setting
code:000017C5                                         ; Bit 7 = Dial memory must expand/contract for new entry
code:000017C8                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:000017C8                                         ; settings index
code:000017CA                 acall   j_FindNthDirectoryEntry ; TmpI = entry number
code:000017CA                                         ;
code:000017CA                                         ; On return:
code:000017CA                                         ;
code:000017CA                                         ; A = entry type
code:000017CC                 acall   j_DecrementDPTR
code:000017CE                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:000017CE                                         ; settings index
code:000017D0
code:000017D0
code:000017D0                 mov     A, R7
code:000017D1                 add     A, DPL          ; Data Pointer, Low Byte
code:000017D3                 mov     DPL, A          ; Data Pointer, Low Byte
code:000017D5                 jnc     DeletePartialBlock
code:000017D7
code:000017D7
code:000017D7                 inc     DPH             ; Data Pointer, High Byte
code:000017D9
code:000017D9 ;
code:000017D9 ; First shift over the low byte length of data
code:000017D9 ;
code:000017D9
code:000017D9 DeletePartialBlock:                     ; CODE XREF: MoveMemory+1A↑j
code:000017D9                 mov     A, R6
code:000017DA                 clr     C
code:000017DB                 subb    A, R7
code:000017DC                 lcall   MoveNCharsBack  ; DPTR+A = source of move
code:000017DC                                         ; DPTR = destination of move
code:000017DC                                         ; B = number of chars to move
code:000017DF
code:000017DF ;
code:000017DF ; And now we only have some number of full blocks to copy.  Could be
code:000017DF ; 0.
code:000017DF                 inc     R3
code:000017E0
code:000017E0 DeleteBlockNext:                        ; CODE XREF: MoveMemory+2B↓j
code:000017E0                 djnz    R3, DeleteBlockLoop
code:000017E2                 ret
code:000017E3 ; ---------------------------------------------------------------------------
code:000017E3
code:000017E3 DeleteBlockLoop:                        ; CODE XREF: MoveMemory:DeleteBlockNext↑j
code:000017E3                 lcall   CopyBlock       ; Copies B chars from DPTR to R1:R0
code:000017E3                                         ;
code:000017E3                                         ; If B=0, copies 256 bytes
code:000017E6                 sjmp    DeleteBlockNext
code:000017E8 ; ---------------------------------------------------------------------------
code:000017E8
code:000017E8 AddPartialBlock:                        ; CODE XREF: MoveMemory+A↑j
code:000017E8                 acall   j_DecrementDPTR
code:000017EA                 mov     A, R7
code:000017EB                 clr     C
code:000017EC                 subb    A, R6
code:000017ED                 lcall   InsertNChars    ; DPTR = End of source address
code:000017ED                                         ; DPTR+A = End of destination address
code:000017ED                                         ; B = Number of chars to move
code:000017ED                                         ;
code:000017ED                                         ; Since this function moves in reverse, DPTR must point to
code:000017ED                                         ; the end of the buffer to move, not the start.
code:000017F0
code:000017F0
code:000017F0                 inc     R3
code:000017F1
code:000017F1 InsertBlockNext:                        ; CODE XREF: MoveMemory+3C↓j
code:000017F1                 djnz    R3, InsertBlockLoop
code:000017F3
code:000017F3 ReturnGate:                             ; CODE XREF: MoveMemory↑j
code:000017F3                 ret
code:000017F4 ; ---------------------------------------------------------------------------
code:000017F4
code:000017F4 InsertBlockLoop:                        ; CODE XREF: MoveMemory:InsertBlockNext↑j
code:000017F4                 lcall   InsertLoop
code:000017F7                 sjmp    InsertBlockNext
code:000017F7 ; End of function MoveMemory
code:000017F7
code:000017F9
code:000017F9 ; =============== S U B R O U T I N E =======================================
code:000017F9
code:000017F9 ; On return:
code:000017F9 ;
code:000017F9 ; R3:R2 = difference
code:000017F9
code:000017F9 GetRemainingSizeOfDirectory:            ; CODE XREF: EraseEntry+34↑p
code:000017F9                                         ; MoveMemory+3↑p
code:000017F9                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:000017F9                                         ; settings index
code:000017FB                 inc     TmpI            ; Often the phone book entry number, but can also be used as
code:000017FB                                         ; settings index
code:000017FD                 acall   j_FindNthDirectoryEntry ; TmpI = entry number
code:000017FD                                         ;
code:000017FD                                         ; On return:
code:000017FD                                         ;
code:000017FD                                         ; A = entry type
code:000017FF                 mov     R0, DPL         ; Data Pointer, Low Byte
code:00001801                 mov     R1, DPH         ; Data Pointer, High Byte
code:00001803                 mov     TmpI, #27       ; Often the phone book entry number, but can also be used as
code:00001803                                         ; settings index
code:00001806                 lcall   j_FindNthDirectoryEntry ; TmpI = entry number
code:00001806                                         ;
code:00001806                                         ; On return:
code:00001806                                         ;
code:00001806                                         ; A = entry type
code:00001809                 lcall   Sub16           ; 16-bit subtraction
code:00001809                                         ; DPTR = LHS
code:00001809                                         ; R1:R0 = RHS
code:00001809                                         ;
code:00001809                                         ; On return:
code:00001809                                         ;
code:00001809                                         ; R3:R2 = difference
code:00001809                                         ;
code:0000180C                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:0000180C                                         ; settings index
code:0000180E                 ret
code:0000180E ; End of function GetRemainingSizeOfDirectory
code:0000180E
code:0000180F
code:0000180F ; =============== S U B R O U T I N E =======================================
code:0000180F
code:0000180F
code:0000180F SaveDirectoryEntry:                     ; CODE XREF: EraseAllEntries+1AE↑p
code:0000180F                 lcall   j_FindNthDirectoryEntry ; TmpI = entry number
code:0000180F                                         ;
code:0000180F                                         ; On return:
code:0000180F                                         ;
code:0000180F                                         ; A = entry type
code:00001812                 lcall   j_DecrementDPTR
code:00001815
code:00001815
code:00001815                 mov     R0, DPL         ; Data Pointer, Low Byte
code:00001817                 mov     R1, DPH         ; Data Pointer, High Byte
code:00001819                 mov     DPTR, #DialMiscBuffer
code:0000181C                 mov     B, R7           ; B-Register
code:0000181E                 lcall   CopyBuffer      ; DPTR = Source
code:0000181E                                         ; R1:R0 = Destination
code:0000181E                                         ; B = length
code:00001821                 ret
code:00001821 ; End of function SaveDirectoryEntry
code:00001821
code:00001822
code:00001822 ; =============== S U B R O U T I N E =======================================
code:00001822
code:00001822 ; DialName = Source
code:00001822 ; R0:R1 = Destination
code:00001822 ; R2 = output count
code:00001822 ;
code:00001822 ; Copies until 0 found
code:00001822
code:00001822 StringToNibbles:                        ; CODE XREF: EraseAllEntries+17C↑p
code:00001822                 mov     DPTR, #DialName
code:00001825
code:00001825 CopyBytesLoop:                          ; CODE XREF: StringToNibbles+A↓j
code:00001825                 movx    A, @DPTR
code:00001826                 inc     DPTR
code:00001827                 jnz     code_182A
code:00001829                 ret
code:0000182A ; ---------------------------------------------------------------------------
code:0000182A
code:0000182A code_182A:                              ; CODE XREF: StringToNibbles+5↑j
code:0000182A                 acall   ByteToNibbles   ; A = byte
code:0000182A                                         ; R1:R0 = Destination
code:0000182A                                         ; R2 = output count
code:0000182C                 ajmp    CopyBytesLoop
code:0000182C ; End of function StringToNibbles
code:0000182C
code:0000182E
code:0000182E ; =============== S U B R O U T I N E =======================================
code:0000182E
code:0000182E ; A = byte
code:0000182E ; R1:R0 = Destination
code:0000182E ; R2 = output count
code:0000182E
code:0000182E ByteToNibbles:                          ; CODE XREF: StringToNibbles:code_182A↑p
code:0000182E                                         ; SaveLoginScript:code_1872↓p
code:0000182E                 push    ACC             ; Accumulator
code:00001830                 anl     A, #0xF0
code:00001832                 swap    A
code:00001833                 acall   j_PrintCharToScreenIncR2 ; Increments R2 and writes a character to the screen.
code:00001833                                         ;
code:00001833                                         ; R1:R0 = screen location
code:00001833                                         ; R2 = count
code:00001835                 pop     ACC             ; Accumulator
code:00001837                 anl     A, #0xF
code:00001839                 acall   j_PrintCharToScreenIncR2 ; Increments R2 and writes a character to the screen.
code:00001839                                         ;
code:00001839                                         ; R1:R0 = screen location
code:00001839                                         ; R2 = count
code:0000183B                 ret
code:0000183B ; End of function ByteToNibbles
code:0000183B
code:0000183C
code:0000183C ; =============== S U B R O U T I N E =======================================
code:0000183C
code:0000183C
code:0000183C TranslateDirTypeAndTelNumText:          ; CODE XREF: EraseAllEntries:AssembleDialBuffer↑p
code:0000183C                 mov     DPTR, #DigitsToDial ; This buffer holds the digits that are currently being
code:0000183C                                         ; dialed.  The dial reader marks them out one by one as
code:0000183C                                         ; each digit is rendered to the phone line.
code:0000183F                 mov     R0, #(DialMiscBuffer & 0xFF)
code:00001841                 mov     R1, #(DialMiscBuffer >> 8)
code:00001843                 mov     R2, #0
code:00001845
code:00001845
code:00001845                 mov     A, DirEntryType
code:00001847                 acall   j_PrintCharToScreenIncR2 ; Increments R2 and writes a character to the screen.
code:00001847                                         ;
code:00001847                                         ; R1:R0 = screen location
code:00001847                                         ; R2 = count
code:00001849
code:00001849 DecodePhoneNumber:                      ; CODE XREF: ManualDial+48↑p
code:00001849                                         ; TranslateDirTypeAndTelNumText+2C↓j
code:00001849                 movx    A, @DPTR
code:0000184A                 inc     DPTR
code:0000184B                 jnz     CheckDash
code:0000184D
code:0000184D
code:0000184D                 clr     A
code:0000184E
code:0000184E j_PrintCharToScreenIncR2:               ; CODE XREF: ByteToNibbles+5↑p
code:0000184E                                         ; ByteToNibbles+B↑p ...
code:0000184E                 ljmp    PrintCharToVRAMIncR2 ; Increments R2 and writes a character to the screen.
code:0000184E                                         ;
code:0000184E                                         ; R1:R0 = screen location
code:0000184E                                         ; R2 = count
code:00001851 ; ---------------------------------------------------------------------------
code:00001851
code:00001851 CheckDash:                              ; CODE XREF: TranslateDirTypeAndTelNumText+F↑j
code:00001851                 cjne    A, #'-, CheckSlash
code:00001854                 mov     A, #14
code:00001856                 ajmp    EnterPNCode
code:00001858 ; ---------------------------------------------------------------------------
code:00001858
code:00001858 CheckSlash:                             ; CODE XREF: TranslateDirTypeAndTelNumText:CheckDash↑j
code:00001858                 cjne    A, #'/, Check0
code:0000185B                 mov     A, #13
code:0000185D                 ajmp    EnterPNCode
code:0000185F ; ---------------------------------------------------------------------------
code:0000185F
code:0000185F Check0:                                 ; CODE XREF: TranslateDirTypeAndTelNumText:CheckSlash↑j
code:0000185F                 cjne    A, #'0, Digit1to9
code:00001862                 mov     A, #0xA
code:00001864
code:00001864 Digit1to9:                              ; CODE XREF: TranslateDirTypeAndTelNumText:Check0↑j
code:00001864                 anl     A, #0xF
code:00001866
code:00001866 EnterPNCode:                            ; CODE XREF: TranslateDirTypeAndTelNumText+1A↑j
code:00001866                                         ; TranslateDirTypeAndTelNumText+21↑j
code:00001866                 acall   j_PrintCharToScreenIncR2 ; Increments R2 and writes a character to the screen.
code:00001866                                         ;
code:00001866                                         ; R1:R0 = screen location
code:00001866                                         ; R2 = count
code:00001868                 sjmp    DecodePhoneNumber
code:00001868 ; End of function TranslateDirTypeAndTelNumText
code:00001868
code:0000186A
code:0000186A ; =============== S U B R O U T I N E =======================================
code:0000186A
code:0000186A ; R0:R1 = Destination
code:0000186A ; R2 = Output count
code:0000186A ; DialLoginScript = Source
code:0000186A
code:0000186A SaveLoginScript:                        ; CODE XREF: EraseAllEntries+184↑p
code:0000186A                 mov     DPTR, #DialLoginScript
code:0000186D
code:0000186D SaveLoop:                               ; CODE XREF: SaveLoginScript+B↓j
code:0000186D                 movx    A, @DPTR
code:0000186E                 cjne    A, #0xFF, code_1872
code:00001871
code:00001871
code:00001871                 ret
code:00001872 ; ---------------------------------------------------------------------------
code:00001872
code:00001872 code_1872:                              ; CODE XREF: SaveLoginScript+4↑j
code:00001872                 acall   ByteToNibbles   ; A = byte
code:00001872                                         ; R1:R0 = Destination
code:00001872                                         ; R2 = output count
code:00001874                 inc     DPTR
code:00001875                 sjmp    SaveLoop
code:00001875 ; End of function SaveLoginScript
code:00001875
code:00001877
code:00001877 ; =============== S U B R O U T I N E =======================================
code:00001877
code:00001877
code:00001877 WaitDirectoryItemSelection:             ; CODE XREF: EraseAllEntries+93↑p
code:00001877                                         ; EraseEntry+C↑p ...
code:00001877                 acall   WaitForSerialInput ; On return:
code:00001877                                         ;
code:00001877                                         ; A = next character
code:00001879                 cjne    A, #0x1B, code_1883
code:0000187C
code:0000187C
code:0000187C                 acall   WaitForSerialInput ; On return:
code:0000187C                                         ;
code:0000187C                                         ; A = next character
code:0000187E                 cjne    A, #'|, WaitDirectoryItemSelection
code:00001881                 clr     A
code:00001882                 ret
code:00001883 ; ---------------------------------------------------------------------------
code:00001883
code:00001883 code_1883:                              ; CODE XREF: WaitDirectoryItemSelection+2↑j
code:00001883                 acall   LetterTest      ; On return:
code:00001883                                         ;
code:00001883                                         ; B = original value
code:00001883                                         ; A = capitalized value
code:00001883                                         ; C = set if not a letter
code:00001885                 jc      WaitDirectoryItemSelection
code:00001887
code:00001887
code:00001887                 push    ACC             ; Accumulator
code:00001889                 lcall   TypeCharAsIs
code:0000188C                 pop     ACC             ; Accumulator
code:0000188E                 clr     C
code:0000188F                 subb    A, #'@
code:00001891                 mov     TmpI, A         ; Often the phone book entry number, but can also be used as
code:00001891                                         ; settings index
code:00001893                 ret
code:00001893 ; End of function WaitDirectoryItemSelection
code:00001893
code:00001894
code:00001894 ; =============== S U B R O U T I N E =======================================
code:00001894
code:00001894 ; On return:
code:00001894 ;
code:00001894 ; B = original value
code:00001894 ; A = capitalized value
code:00001894 ; C = set if not a letter
code:00001894
code:00001894 LetterTest:                             ; CODE XREF: ConnectMenuHandler+13↑p
code:00001894                                         ; ChangeSettings:NotESC↑p ...
code:00001894                 mov     B, A            ; B-Register
code:00001896                 lcall   Capitalize      ; Translates lower-case letters to upper-case.
code:00001896                                         ;
code:00001896                                         ; A = old value
code:00001896                                         ;
code:00001896                                         ; On return:
code:00001896                                         ;
code:00001896                                         ; C = untranslated
code:00001896                                         ; A = new value
code:00001899                 cjne    A, #'A, code_189C
code:0000189C
code:0000189C code_189C:                              ; CODE XREF: LetterTest+5↑j
code:0000189C                 jc      code_18A5
code:0000189E                 cjne    A, #'[, code_18A1
code:000018A1
code:000018A1 code_18A1:                              ; CODE XREF: LetterTest+A↑j
code:000018A1                 jnc     code_18A5
code:000018A3                 clr     C
code:000018A4                 ret
code:000018A5 ; ---------------------------------------------------------------------------
code:000018A5
code:000018A5 code_18A5:                              ; CODE XREF: LetterTest:code_189C↑j
code:000018A5                                         ; LetterTest:code_18A1↑j
code:000018A5                 setb    C
code:000018A6                 ret
code:000018A6 ; End of function LetterTest
code:000018A6
code:000018A7
code:000018A7 ; =============== S U B R O U T I N E =======================================
code:000018A7
code:000018A7 ; DPTR = where on screen
code:000018A7 ; ContextFunctionPtr = final destination buffer
code:000018A7 ; R7 = limit
code:000018A7
code:000018A7 InputFormLine:                          ; CODE XREF: EraseAllEntries+C1↑p
code:000018A7                                         ; EraseAllEntries+12C↑p
code:000018A7                 mov     R6, #0          ; Here, R6 is the length of the name
code:000018A9                 push    CursorAddr
code:000018AB                 push    CursorAddr+1
code:000018AD
code:000018AD WaitNameInputLoop:                      ; CODE XREF: InputFormLine+8↓j
code:000018AD                                         ; InputFormLine+F↓j ...
code:000018AD                 acall   WaitForSerialInput ; On return:
code:000018AD                                         ;
code:000018AD                                         ; A = next character
code:000018AF                 jz      WaitNameInputLoop
code:000018B1
code:000018B1
code:000018B1                 cjne    A, #8, NotErase
code:000018B4
code:000018B4 DoBackspace:                            ; CODE XREF: InputFormLine+4F↓j
code:000018B4                 acall   EraseDialStringDigit
code:000018B6                 sjmp    WaitNameInputLoop
code:000018B8 ; ---------------------------------------------------------------------------
code:000018B8
code:000018B8 NotErase:                               ; CODE XREF: InputFormLine+A↑j
code:000018B8                 cjne    A, #9, code_18BD
code:000018BB                 sjmp    WaitNameInputLoop
code:000018BD ; ---------------------------------------------------------------------------
code:000018BD
code:000018BD code_18BD:                              ; CODE XREF: InputFormLine:NotErase↑j
code:000018BD                 cjne    A, #0xA, code_18C2
code:000018C0                 sjmp    WaitNameInputLoop
code:000018C2 ; ---------------------------------------------------------------------------
code:000018C2
code:000018C2 code_18C2:                              ; CODE XREF: InputFormLine:code_18BD↑j
code:000018C2                 cjne    A, #0xD, CheckFlowControl
code:000018C5
code:000018C5
code:000018C5                 mov     R1, ContextFunctionPtr ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000018C7                 mov     R0, ContextFunctionPtr+1 ; Often set to a deferred call address, but sometimes used for a pointer to video memory
code:000018C9
code:000018C9 ;
code:000018C9 ; First copy what's on the screen to the secoondary buffer.  Then add
code:000018C9 ; 0 terminator.
code:000018C9 ;
code:000018C9
code:000018C9 CopyFinalEntryText:                     ; CODE XREF: EditDialString+F↓j
code:000018C9                 pop     DPL             ; Data Pointer, Low Byte
code:000018CB                 pop     DPH             ; Data Pointer, High Byte
code:000018CD                 clr     CY              ; Program Status Word Register
code:000018CF                 mov     A, R7
code:000018D0                 subb    A, R6
code:000018D1                 mov     R7, A
code:000018D2                 mov     B, R6           ; B-Register
code:000018D4                 lcall   CopyBuffer      ; DPTR = Source
code:000018D4                                         ; R1:R0 = Destination
code:000018D4                                         ; B = length
code:000018D7
code:000018D7
code:000018D7                 clr     A
code:000018D8                 ajmp    j_PutCharToScreen_0 ; R1:R0 = destination
code:000018D8                                         ; A = character
code:000018D8                                         ;
code:000018D8                                         ; Auto-increments R1:R0
code:000018DA ; ---------------------------------------------------------------------------
code:000018DA
code:000018DA CheckFlowControl:                       ; CODE XREF: InputFormLine:code_18C2↑j
code:000018DA                 cjne    A, #0x11, code_18DF ; XON
code:000018DD                 sjmp    WaitNameInputLoop
code:000018DF ; ---------------------------------------------------------------------------
code:000018DF
code:000018DF code_18DF:                              ; CODE XREF: InputFormLine:CheckFlowControl↑j
code:000018DF                 cjne    A, #0x13, CheckForQuit ; XOFF
code:000018E2                 sjmp    WaitNameInputLoop
code:000018E4 ; ---------------------------------------------------------------------------
code:000018E4
code:000018E4 CheckForQuit:                           ; CODE XREF: InputFormLine:code_18DF↑j
code:000018E4                 cjne    A, #0x1B, CheckForDelete ; ESC
code:000018E7                 acall   WaitForSerialInput ; On return:
code:000018E7                                         ;
code:000018E7                                         ; A = next character
code:000018E9
code:000018E9
code:000018E9                 cjne    A, #0x7C, WaitNameInputLoop
code:000018EC                 pop     ACC             ; Accumulator
code:000018EE                 pop     ACC             ; Accumulator
code:000018F0                 mov     A, #0xFF
code:000018F2                 ret
code:000018F3 ; ---------------------------------------------------------------------------
code:000018F3
code:000018F3 CheckForDelete:                         ; CODE XREF: InputFormLine:CheckForQuit↑j
code:000018F3                 cjne    A, #0x7F, CheckForRoom
code:000018F6                 sjmp    DoBackspace
code:000018F8 ; ---------------------------------------------------------------------------
code:000018F8
code:000018F8 CheckForRoom:                           ; CODE XREF: InputFormLine:CheckForDelete↑j
code:000018F8                 push    ACC             ; Accumulator
code:000018FA                 mov     A, R7
code:000018FB                 cjne    A, B0R6, AddChar
code:000018FE
code:000018FE
code:000018FE                 pop     ACC             ; Accumulator
code:00001900                 sjmp    WaitNameInputLoop
code:00001902 ; ---------------------------------------------------------------------------
code:00001902
code:00001902 AddChar:                                ; CODE XREF: InputFormLine+54↑j
code:00001902                 pop     ACC             ; Accumulator
code:00001904                 inc     R6
code:00001905                 lcall   TypeCharAsIs
code:00001908                 sjmp    WaitNameInputLoop
code:00001908 ; End of function InputFormLine
code:00001908
code:0000190A
code:0000190A ; =============== S U B R O U T I N E =======================================
code:0000190A
code:0000190A
code:0000190A EditDialString:                         ; CODE XREF: ManualDial+6E↑p
code:0000190A                                         ; EraseAllEntries+CE↑p
code:0000190A                 mov     R6, #0
code:0000190C                 push    CursorAddr
code:0000190E                 push    CursorAddr+1
code:00001910
code:00001910 WaitDialLoop:                           ; CODE XREF: EditDialString+16↓j
code:00001910                                         ; EditDialString+2D↓j ...
code:00001910                 acall   WaitForSerialInput ; On return:
code:00001910                                         ;
code:00001910                                         ; A = next character
code:00001912                 cjne    A, #0xD, CheckForESCBar
code:00001915
code:00001915
code:00001915                 mov     R0, #(DigitsToDial & 0xFF) ; This buffer holds the digits that are currently being
code:00001915                                         ; dialed.  The dial reader marks them out one by one as
code:00001915                                         ; each digit is rendered to the phone line.
code:00001917                 mov     R1, #(DigitsToDial >> 8) ; This buffer holds the digits that are currently being
code:00001917                                         ; dialed.  The dial reader marks them out one by one as
code:00001917                                         ; each digit is rendered to the phone line.
code:00001919                 sjmp    CopyFinalEntryText
code:0000191B ; ---------------------------------------------------------------------------
code:0000191B
code:0000191B CheckForESCBar:                         ; CODE XREF: EditDialString+8↑j
code:0000191B                 cjne    A, #0x1B, CheckForDash
code:0000191E
code:0000191E
code:0000191E                 acall   WaitForSerialInput ; On return:
code:0000191E                                         ;
code:0000191E                                         ; A = next character
code:00001920                 cjne    A, #'|, WaitDialLoop
code:00001923
code:00001923
code:00001923                 pop     ACC             ; Accumulator
code:00001925                 pop     ACC             ; Accumulator
code:00001927
code:00001927
code:00001927                 ret
code:00001928 ; ---------------------------------------------------------------------------
code:00001928
code:00001928 CheckForDash:                           ; CODE XREF: EditDialString:CheckForESCBar↑j
code:00001928                 cjne    A, #'-, CheckForSlash
code:0000192B
code:0000192B
code:0000192B                 ajmp    AddDigitToDialString
code:0000192D ; ---------------------------------------------------------------------------
code:0000192D
code:0000192D CheckForSlash:                          ; CODE XREF: EditDialString:CheckForDash↑j
code:0000192D                 cjne    A, #'/, CheckForBackspace
code:00001930
code:00001930
code:00001930                 ajmp    AddDigitToDialString
code:00001932 ; ---------------------------------------------------------------------------
code:00001932
code:00001932 CheckForBackspace:                      ; CODE XREF: EditDialString:CheckForSlash↑j
code:00001932                 cjne    A, #8, CheckForDigit
code:00001935
code:00001935
code:00001935                 acall   EraseDialStringDigit
code:00001937                 sjmp    WaitDialLoop
code:00001939 ; ---------------------------------------------------------------------------
code:00001939
code:00001939 CheckForDigit:                          ; CODE XREF: EditDialString:CheckForBackspace↑j
code:00001939                 cjne    A, #'0, code_193C
code:0000193C
code:0000193C code_193C:                              ; CODE XREF: EditDialString:CheckForDigit↑j
code:0000193C                 jc      WaitDialLoop
code:0000193E
code:0000193E
code:0000193E                 cjne    A, #':, code_1941
code:00001941
code:00001941 code_1941:                              ; CODE XREF: EditDialString+34↑j
code:00001941                 jnc     WaitDialLoop
code:00001943
code:00001943 AddDigitToDialString:                   ; CODE XREF: EditDialString+21↑j
code:00001943                                         ; EditDialString+26↑j
code:00001943                 cjne    R6, #21, AddIt
code:00001946
code:00001946
code:00001946                 sjmp    WaitDialLoop
code:00001948 ; ---------------------------------------------------------------------------
code:00001948
code:00001948 AddIt:                                  ; CODE XREF: EditDialString:AddDigitToDialString↑j
code:00001948                 inc     R6
code:00001949                 lcall   TypeCharAsIs
code:0000194C                 sjmp    WaitDialLoop
code:0000194C ; End of function EditDialString
code:0000194C
code:0000194E
code:0000194E ; =============== S U B R O U T I N E =======================================
code:0000194E
code:0000194E ; Returns the char after the ESC
code:0000194E
code:0000194E WaitForSerialESCCode:                   ; CODE XREF: ManualDial:MenuLoop↑p
code:0000194E                                         ; EraseAllEntries:WaitCommandLoop↑p ...
code:0000194E                 acall   WaitForSerialInput ; On return:
code:0000194E                                         ;
code:0000194E                                         ; A = next character
code:00001950                 cjne    A, #0x1B, WaitForSerialESCCode ; Returns the char after the ESC
code:00001950 ; End of function WaitForSerialESCCode
code:00001950
code:00001953
code:00001953 ; =============== S U B R O U T I N E =======================================
code:00001953
code:00001953 ; On return:
code:00001953 ;
code:00001953 ; A = next character
code:00001953
code:00001953 WaitForSerialInput:                     ; CODE XREF: j_WaitForSerialInput↑j
code:00001953                                         ; WaitDirectoryItemSelection↑p ...
code:00001953                 push    DPL             ; Data Pointer, Low Byte
code:00001955                 push    DPH             ; Data Pointer, High Byte
code:00001957
code:00001957 code_1957:                              ; CODE XREF: WaitForSerialInput+7↓j
code:00001957                 lcall   GetNextSerialInChar ; Gets a character from the input serial buffer.  Sends XON if
code:00001957                                         ; needed.
code:00001957                                         ;
code:00001957                                         ; At return:
code:00001957                                         ;
code:00001957                                         ; A = next character
code:00001957                                         ; C = next character is valid
code:0000195A                 jnc     code_1957
code:0000195C
code:0000195C
code:0000195C                 pop     DPH             ; Data Pointer, High Byte
code:0000195E                 pop     DPL             ; Data Pointer, Low Byte
code:00001960                 ret
code:00001960 ; End of function WaitForSerialInput
code:00001960
code:00001961
code:00001961 ; =============== S U B R O U T I N E =======================================
code:00001961
code:00001961
code:00001961 EraseDialStringDigit:                   ; CODE XREF: InputFormLine:DoBackspace↑p
code:00001961                                         ; EditDialString+2B↑p
code:00001961                 cjne    R6, #0, code_1965
code:00001964                 ret
code:00001965 ; ---------------------------------------------------------------------------
code:00001965
code:00001965 code_1965:                              ; CODE XREF: EraseDialStringDigit↑j
code:00001965                 dec     R6
code:00001966                 ljmp    TypeBackspace
code:00001966 ; End of function EraseDialStringDigit
code:00001966
code:00001969
code:00001969 ; =============== S U B R O U T I N E =======================================
code:00001969
code:00001969 ; Initializes the directory if it fails its checksum and
code:00001969 ; watermark tests
code:00001969
code:00001969 CheckAndInitDirectory:                  ; CODE XREF: ConnectMenu:ConnectMenuEntry↑p
code:00001969                                         ; CheckAndInitDirectory+42↓j
code:00001969                 mov     DPTR, #DialMemoryWatermark
code:0000196C                 movx    A, @DPTR
code:0000196D                 anl     A, #0xF
code:0000196F                 inc     DPTR
code:00001970                 cjne    A, #5, RAMIsCorrupt
code:00001973
code:00001973
code:00001973                 movx    A, @DPTR
code:00001974                 anl     A, #0xF
code:00001976                 cjne    A, #10, RAMIsCorrupt
code:00001979
code:00001979
code:00001979                 lcall   CheckPhoneBookMem
code:0000197C                 jnz     RAMIsCorrupt
code:0000197E
code:0000197E
code:0000197E                 ret
code:0000197F ; ---------------------------------------------------------------------------
code:0000197F
code:0000197F RAMIsCorrupt:                           ; CODE XREF: CheckAndInitDirectory+7↑j
code:0000197F                                         ; CheckAndInitDirectory+D↑j ...
code:0000197F                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:0000197F                                         ; Bit 1 = Receive buffer is full
code:0000197F                                         ; Bit 3 = Serial send register busy
code:0000197F                                         ; Bit 4 = Busy drawing to screen
code:0000197F                                         ; Bit 5 = Steady/Blink
code:0000197F                                         ; Bit 6 = Disable keyboard
code:0000197F                                         ; Bit 7 = Standard/Graphics
code:00001981                 lcall   ExecuteBell
code:00001984                 lcall   InitLineMap     ; Sets the line numbers to 0-24 in order and clears the screen
code:00001987
code:00001987 ;
code:00001987 ; Instruct user to hold the SAVE button and hit RETURN
code:00001987 ; before we blast the RAM.
code:00001987 ; SAVE button?  What SAVE button?
code:00001987 ;
code:00001987                 mov     DPTR, #aHoldSaveButton
code:0000198A                 acall   PrintDPTRPrefixedHiBtTermStrings ; Each string begins with a DPTR and ends with 0x80.  The final
code:0000198A                                         ; string ends with 0x81
code:0000198C
code:0000198C WaitForRETURNLoop:                      ; CODE XREF: CheckAndInitDirectory+25↓j
code:0000198C                 acall   WaitForSerialInput ; On return:
code:0000198C                                         ;
code:0000198C                                         ; A = next character
code:0000198E                 cjne    A, #0xD, WaitForRETURNLoop
code:00001991
code:00001991 ;
code:00001991 ; Store watermark
code:00001991 ;
code:00001991                 mov     DPTR, #DialMemoryWatermark
code:00001994                 mov     A, #5
code:00001996                 movx    @DPTR, A
code:00001997
code:00001997
code:00001997                 inc     DPTR
code:00001998                 mov     A, #10
code:0000199A                 movx    @DPTR, A
code:0000199B
code:0000199B ;
code:0000199B ; Init serial settings
code:0000199B ;
code:0000199B                 inc     DPTR
code:0000199C                 clr     A
code:0000199D                 movx    @DPTR, A
code:0000199E
code:0000199E
code:0000199E                 inc     DPTR
code:0000199F                 movx    @DPTR, A
code:000019A0
code:000019A0 ;
code:000019A0 ; Init pause for / in dial string
code:000019A0 ;
code:000019A0                 inc     DPTR
code:000019A1                 movx    @DPTR, A
code:000019A2
code:000019A2 ;
code:000019A2 ; Init wait time for answer
code:000019A2 ;
code:000019A2                 inc     DPTR
code:000019A3                 mov     A, #2
code:000019A5                 movx    @DPTR, A
code:000019A6
code:000019A6
code:000019A6                 acall   InitializeDirectory
code:000019A8                 lcall   UpdatePhoneBookCksum
code:000019AB                 sjmp    CheckAndInitDirectory ; Initializes the directory if it fails its checksum and
code:000019AB ; End of function CheckAndInitDirectory ; watermark tests
code:000019AB
code:000019AD
code:000019AD ; =============== S U B R O U T I N E =======================================
code:000019AD
code:000019AD
code:000019AD InitializeDirectory:                    ; CODE XREF: EraseAllEntries:DoEraseAllEntries↑p
code:000019AD                                         ; CheckAndInitDirectory+3D↑p
code:000019AD                 mov     DPTR, #DirectoryStart
code:000019B0
code:000019B0 ;
code:000019B0 ; Create a full directory of empty numbers
code:000019B0 ;
code:000019B0                 mov     R0, #27
code:000019B2
code:000019B2 InitializeLoop:                         ; CODE XREF: InitializeDirectory+10↓j
code:000019B2                 mov     A, #0xF
code:000019B4                 movx    @DPTR, A
code:000019B5
code:000019B5
code:000019B5                 inc     DPTR
code:000019B6                 clr     A
code:000019B7                 movx    @DPTR, A
code:000019B8
code:000019B8
code:000019B8                 inc     DPTR
code:000019B9                 mov     A, #0xF
code:000019BB                 movx    @DPTR, A
code:000019BC
code:000019BC
code:000019BC                 inc     DPTR
code:000019BD                 djnz    R0, InitializeLoop
code:000019BF                 ret
code:000019BF ; End of function InitializeDirectory
code:000019BF
code:000019C0
code:000019C0 ; =============== S U B R O U T I N E =======================================
code:000019C0
code:000019C0
code:000019C0 PrintConnectMenu:                       ; CODE XREF: ConnectMenu+7↑p
code:000019C0                 lcall   InitLineMap     ; Sets the line numbers to 0-24 in order and clears the screen
code:000019C3
code:000019C3
code:000019C3                 acall   PrintDirectoryContents
code:000019C5                 acall   DrawFunctionKeyMenu
code:000019C7                 mov     DPTR, #aDialMenu
code:000019CA                 acall   PrintDPTRPrefixedHiBtTermStrings ; Each string begins with a DPTR and ends with 0x80.  The final
code:000019CA                                         ; string ends with 0x81
code:000019CC
code:000019CC
code:000019CC                 mov     DPTR, #VideoLine22
code:000019CF                 mov     R1, #2
code:000019D1                 acall   DrawFancyBox    ; R1 = number of lines inside of box
code:000019D1                                         ; DPTR = start of box
code:000019D3                 mov     DPTR, #aConnectMenu
code:000019D6                 ajmp    PrintDPTRPrefixedHiBtTermStrings ; Each string begins with a DPTR and ends with 0x80.  The final
code:000019D6 ; End of function PrintConnectMenu      ; string ends with 0x81
code:000019D6
code:000019D8
code:000019D8 ; =============== S U B R O U T I N E =======================================
code:000019D8
code:000019D8
code:000019D8 DrawFunctionKeyMenu:                    ; CODE XREF: ChangeSettings+8↑p
code:000019D8                                         ; ManualDial+8↑p ...
code:000019D8                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:000019D8                                         ; Bit 1 = Receive buffer is full
code:000019D8                                         ; Bit 3 = Serial send register busy
code:000019D8                                         ; Bit 4 = Busy drawing to screen
code:000019D8                                         ; Bit 5 = Steady/Blink
code:000019D8                                         ; Bit 6 = Disable keyboard
code:000019D8                                         ; Bit 7 = Standard/Graphics
code:000019DA                 mov     DPTR, #VideoLine17
code:000019DD                 mov     R2, #9
code:000019DF                 acall   j_ClearNLines
code:000019E1
code:000019E1
code:000019E1                 mov     DPTR, #VideoLine18
code:000019E4                 mov     R1, #2
code:000019E6                 acall   DrawFancyBox    ; R1 = number of lines inside of box
code:000019E6                                         ; DPTR = start of box
code:000019E8                 mov     DPTR, #FunctionKeyMenu
code:000019E8 ; End of function DrawFunctionKeyMenu
code:000019E8
code:000019EB
code:000019EB ; =============== S U B R O U T I N E =======================================
code:000019EB
code:000019EB ; Each string begins with a DPTR and ends with 0x80.  The final
code:000019EB ; string ends with 0x81
code:000019EB
code:000019EB PrintDPTRPrefixedHiBtTermStrings:       ; CODE XREF: j_PrintDPTRPrefixedHiBtTermString↑j
code:000019EB                                         ; CheckAndInitDirectory+21↑p ...
code:000019EB                 clr     A
code:000019EC                 movc    A, @A+DPTR
code:000019ED                 inc     DPTR
code:000019EE                 mov     R1, A
code:000019EF
code:000019EF
code:000019EF                 clr     A
code:000019F0                 movc    A, @A+DPTR
code:000019F1                 inc     DPTR
code:000019F2                 mov     R0, A
code:000019F3
code:000019F3 code_19F3:                              ; CODE XREF: PrintDPTRPrefixedHiBtTermStrings+10↓j
code:000019F3                 clr     A
code:000019F4                 movc    A, @A+DPTR
code:000019F5                 inc     DPTR
code:000019F6                 jb      ACC7, code_19FD ; Accumulator
code:000019F9
code:000019F9
code:000019F9                 acall   j_PutCharToScreen_0 ; R1:R0 = destination
code:000019F9                                         ; A = character
code:000019F9                                         ;
code:000019F9                                         ; Auto-increments R1:R0
code:000019FB                 ajmp    code_19F3
code:000019FD ; ---------------------------------------------------------------------------
code:000019FD
code:000019FD code_19FD:                              ; CODE XREF: PrintDPTRPrefixedHiBtTermStrings+B↑j
code:000019FD                 jnb     ACC0, PrintDPTRPrefixedHiBtTermStrings ; Each string begins with a DPTR and ends with 0x80.  The final
code:000019FD                                         ; string ends with 0x81
code:00001A00                 ret
code:00001A00 ; End of function PrintDPTRPrefixedHiBtTermStrings
code:00001A00
code:00001A01
code:00001A01 ; =============== S U B R O U T I N E =======================================
code:00001A01
code:00001A01
code:00001A01 UpdateChecksumAndPrintDirectoryContents:
code:00001A01                                         ; CODE XREF: EraseAllEntries+76↑p
code:00001A01                 lcall   UpdatePhoneBookCksum
code:00001A01 ; End of function UpdateChecksumAndPrintDirectoryContents
code:00001A01
code:00001A04
code:00001A04 ; =============== S U B R O U T I N E =======================================
code:00001A04
code:00001A04
code:00001A04 PrintDirectoryContents:                 ; CODE XREF: PrintConnectMenu+3↑p
code:00001A04                 acall   DrawLargeBox
code:00001A06                 mov     DPTR, #aDIRECTORY
code:00001A09                 acall   PrintDPTRPrefixedHiBtTermStrings ; Each string begins with a DPTR and ends with 0x80.  The final
code:00001A09                                         ; string ends with 0x81
code:00001A0B                 mov     R0, #((VideoLine3+3) & 0xFF)
code:00001A0D                 mov     R1, #((VideoLine3+3) >> 8)
code:00001A0F                 mov     R2, #1
code:00001A11                 acall   PrintDirectoryColumn ; R1:R0 = top of column
code:00001A11                                         ; R2    = starting item number
code:00001A13
code:00001A13
code:00001A13                 mov     R0, #((VideoLine3+0x2A) & 0xFF)
code:00001A15                 mov     R1, #((VideoLine3+0x2A) >> 8)
code:00001A15 ; End of function PrintDirectoryContents
code:00001A15
code:00001A17
code:00001A17 ; =============== S U B R O U T I N E =======================================
code:00001A17
code:00001A17 ; R1:R0 = top of column
code:00001A17 ; R2    = starting item number
code:00001A17
code:00001A17 PrintDirectoryColumn:                   ; CODE XREF: PrintDirectoryContents+D↑p
code:00001A17                 mov     R3, #13
code:00001A19
code:00001A19 ColumnLoop:                             ; CODE XREF: PrintDirectoryColumn+14↓j
code:00001A19                 mov     B0R6, R0
code:00001A1B                 mov     B0R7, R1
code:00001A1D                 acall   PrintNthDirectoryEntry ; R0:R1 = destination on screen
code:00001A1D                                         ; R2    = directory item number
code:00001A1F
code:00001A1F
code:00001A1F                 mov     R0, B0R6
code:00001A21                 mov     R1, B0R7
code:00001A23                 mov     A, #96
code:00001A25                 add     A, R0
code:00001A26                 mov     R0, A
code:00001A27                 jnc     code_1A2A
code:00001A29
code:00001A29
code:00001A29                 inc     R1
code:00001A2A
code:00001A2A code_1A2A:                              ; CODE XREF: PrintDirectoryColumn+10↑j
code:00001A2A                 inc     R2
code:00001A2B                 djnz    R3, ColumnLoop
code:00001A2D                 ret
code:00001A2D ; End of function PrintDirectoryColumn
code:00001A2D
code:00001A2E
code:00001A2E ; =============== S U B R O U T I N E =======================================
code:00001A2E
code:00001A2E ; R0:R1 = destination on screen
code:00001A2E ; R2    = directory item number
code:00001A2E
code:00001A2E PrintNthDirectoryEntry:                 ; CODE XREF: PrintDirectoryColumn+6↑p
code:00001A2E                 mov     A, #13
code:00001A30                 add     A, R0
code:00001A31                 mov     R0, A
code:00001A32                 jnc     code_1A35
code:00001A34
code:00001A34
code:00001A34                 inc     R1
code:00001A35
code:00001A35 code_1A35:                              ; CODE XREF: PrintNthDirectoryEntry+4↑j
code:00001A35                 mov     TmpI, R2        ; Often the phone book entry number, but can also be used as
code:00001A35                                         ; settings index
code:00001A37                 lcall   j_FindNthDirectoryEntry ; TmpI = entry number
code:00001A37                                         ;
code:00001A37                                         ; On return:
code:00001A37                                         ;
code:00001A37                                         ; A = entry type
code:00001A3A                 lcall   IndexToDirectoryType ; A = index.  Note that indices start at 7
code:00001A3D                 acall   j_PutCharToScreen_0 ; R1:R0 = destination
code:00001A3D                                         ; A = character
code:00001A3D                                         ;
code:00001A3D                                         ; Auto-increments R1:R0
code:00001A3F                 mov     A, #'
code:00001A41                 acall   j_PutCharToScreen_0 ; R1:R0 = destination
code:00001A41                                         ; A = character
code:00001A41                                         ;
code:00001A41                                         ; Auto-increments R1:R0
code:00001A43
code:00001A43 ConvertToPhoneNumberLoop:               ; CODE XREF: PrintNthDirectoryEntry+31↓j
code:00001A43                 movx    A, @DPTR
code:00001A44                 inc     DPTR
code:00001A45                 anl     A, #0xF
code:00001A47                 jz      code_1A61
code:00001A49
code:00001A49
code:00001A49                 add     A, #'0          ; 0 = end of number.  1-9 are converted directly to digits.
code:00001A49                                         ; A becomes 0.  D is a pause (/).  Everything else becomes a
code:00001A49                                         ; dash.
code:00001A4B                 cjne    A, #':, code_1A52
code:00001A4E                 mov     A, #'0
code:00001A50                 ajmp    OutputChar
code:00001A52 ; ---------------------------------------------------------------------------
code:00001A52
code:00001A52 code_1A52:                              ; CODE XREF: PrintNthDirectoryEntry+1D↑j
code:00001A52                 jc      OutputChar
code:00001A54
code:00001A54
code:00001A54                 cjne    A, #'=, code_1A5B
code:00001A57
code:00001A57
code:00001A57                 mov     A, #'/
code:00001A59                 ajmp    OutputChar
code:00001A5B ; ---------------------------------------------------------------------------
code:00001A5B
code:00001A5B code_1A5B:                              ; CODE XREF: PrintNthDirectoryEntry+26↑j
code:00001A5B                 mov     A, #'-
code:00001A5D
code:00001A5D OutputChar:                             ; CODE XREF: PrintNthDirectoryEntry+22↑j
code:00001A5D                                         ; PrintNthDirectoryEntry:code_1A52↑j ...
code:00001A5D                 acall   j_PutCharToScreen_0 ; R1:R0 = destination
code:00001A5D                                         ; A = character
code:00001A5D                                         ;
code:00001A5D                                         ; Auto-increments R1:R0
code:00001A5F                 sjmp    ConvertToPhoneNumberLoop
code:00001A61 ; ---------------------------------------------------------------------------
code:00001A61
code:00001A61 code_1A61:                              ; CODE XREF: PrintNthDirectoryEntry+19↑j
code:00001A61                 mov     R0, B0R6
code:00001A63                 mov     R1, B0R7
code:00001A65
code:00001A65 PrintNameLoop:                          ; CODE XREF: PrintNthDirectoryEntry+41↓j
code:00001A65                 movx    A, @DPTR
code:00001A66                 anl     A, #0xF
code:00001A68                 inc     DPTR
code:00001A69                 cjne    A, #0xF, ItsALetter
code:00001A6C
code:00001A6C
code:00001A6C                 ret
code:00001A6D ; ---------------------------------------------------------------------------
code:00001A6D
code:00001A6D ItsALetter:                             ; CODE XREF: PrintNthDirectoryEntry+3B↑j
code:00001A6D                 acall   CombineWithLowNibbleAndPrint ; A = high nibble
code:00001A6D                                         ; DPTR = next nibble ptr
code:00001A6D                                         ; R1:R0 = destination
code:00001A6F                 sjmp    PrintNameLoop
code:00001A6F ; End of function PrintNthDirectoryEntry
code:00001A6F
code:00001A71
code:00001A71 ; =============== S U B R O U T I N E =======================================
code:00001A71
code:00001A71 ; A = high nibble
code:00001A71 ; DPTR = next nibble ptr
code:00001A71 ; R1:R0 = destination
code:00001A71
code:00001A71 CombineWithLowNibbleAndPrint:           ; CODE XREF: PrintNthDirectoryEntry:ItsALetter↑p
code:00001A71                 swap    A
code:00001A72                 mov     R5, A
code:00001A73                 movx    A, @DPTR
code:00001A74                 inc     DPTR
code:00001A75                 anl     A, #0xF
code:00001A77                 add     A, R5
code:00001A78
code:00001A78 j_PutCharToScreen_0:                    ; CODE XREF: InputFormLine+31↑j
code:00001A78                                         ; PrintDPTRPrefixedHiBtTermStrings+E↑p ...
code:00001A78                 ljmp    PrintCharToVRAM ; R1:R0 = destination
code:00001A78 ; End of function CombineWithLowNibbleAndPrint ; A = character
code:00001A78                                         ;
code:00001A78                                         ; Auto-increments R1:R0
code:00001A7B
code:00001A7B ; =============== S U B R O U T I N E =======================================
code:00001A7B
code:00001A7B
code:00001A7B DrawLargeBox:                           ; CODE XREF: ChangeSettings↑p
code:00001A7B                                         ; PrintDirectoryContents↑p
code:00001A7B                 setb    VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001A7B                                         ; Bit 1 = Receive buffer is full
code:00001A7B                                         ; Bit 3 = Serial send register busy
code:00001A7B                                         ; Bit 4 = Busy drawing to screen
code:00001A7B                                         ; Bit 5 = Steady/Blink
code:00001A7B                                         ; Bit 6 = Disable keyboard
code:00001A7B                                         ; Bit 7 = Standard/Graphics
code:00001A7D                 mov     DPTR, #VideoLine2
code:00001A80                 mov     R2, #15
code:00001A82                 acall   j_ClearNLines
code:00001A84
code:00001A84
code:00001A84                 mov     DPTR, #VideoLine2
code:00001A87                 mov     R1, #13
code:00001A89                 acall   DrawFancyBox    ; R1 = number of lines inside of box
code:00001A89                                         ; DPTR = start of box
code:00001A8B
code:00001A8B
code:00001A8B                 mov     R1, #'A
code:00001A8D                 mov     DPTR, #(VideoLine3+1)
code:00001A90                 acall   DrawLargeBoxLetters
code:00001A92                 mov     DPTR, #(VideoLine3+0x28)
code:00001A92 ; End of function DrawLargeBox
code:00001A92
code:00001A95
code:00001A95 ; =============== S U B R O U T I N E =======================================
code:00001A95
code:00001A95
code:00001A95 DrawLargeBoxLetters:                    ; CODE XREF: DrawLargeBox+15↑p
code:00001A95                 mov     R0, #13
code:00001A97
code:00001A97 code_1A97:                              ; CODE XREF: DrawLargeBoxLetters+7↓j
code:00001A97                 mov     A, R1
code:00001A98                 inc     R1
code:00001A99                 movx    @DPTR, A
code:00001A9A                 acall   IncrementDPTRLine
code:00001A9C                 djnz    R0, code_1A97
code:00001A9E                 ret
code:00001A9E ; End of function DrawLargeBoxLetters
code:00001A9E
code:00001A9F
code:00001A9F ; =============== S U B R O U T I N E =======================================
code:00001A9F
code:00001A9F ; R1 = number of lines inside of box
code:00001A9F ; DPTR = start of box
code:00001A9F
code:00001A9F DrawFancyBox:                           ; CODE XREF: PrintConnectMenu+11↑p
code:00001A9F                                         ; DrawFunctionKeyMenu+E↑p ...
code:00001A9F                 acall   DrawHorizLine   ; Draws a horizontal line at DPTR, 78 chars starting at
code:00001A9F                                         ; position 1
code:00001AA1                 acall   DrawTopCorners
code:00001AA3
code:00001AA3 DrawMiddleBoxLoop:                      ; CODE XREF: DrawFancyBox+8↓j
code:00001AA3                 acall   IncrementDPTRLine
code:00001AA5                 acall   DrawBoxLine     ; Draws one of the lines between top and bottom
code:00001AA7                 djnz    R1, DrawMiddleBoxLoop
code:00001AA9
code:00001AA9
code:00001AA9                 acall   IncrementDPTRLine
code:00001AAB                 acall   DrawHorizLine   ; Draws a horizontal line at DPTR, 78 chars starting at
code:00001AAB                                         ; position 1
code:00001AAD                 ajmp    DrawBottomCorners
code:00001AAD ; End of function DrawFancyBox
code:00001AAD
code:00001AAF
code:00001AAF ; =============== S U B R O U T I N E =======================================
code:00001AAF
code:00001AAF
code:00001AAF DrawTopCorners:                         ; CODE XREF: DrawFancyBox+2↑p
code:00001AAF                 mov     R5, #6
code:00001AB1                 mov     R6, #19
code:00001AB3                 mov     R7, #3
code:00001AB5                 ajmp    DrawLeftCenterRight ; Places 3 characters on a line:  R5 on left, R6 at center, and
code:00001AB5 ; End of function DrawTopCorners        ; R7 at right
code:00001AB5
code:00001AB7
code:00001AB7 ; =============== S U B R O U T I N E =======================================
code:00001AB7
code:00001AB7
code:00001AB7 DrawBottomCorners:                      ; CODE XREF: DrawFancyBox+E↑j
code:00001AB7                 mov     R5, #5
code:00001AB9                 mov     R6, #21
code:00001ABB                 mov     R7, #4
code:00001ABD                 ajmp    DrawLeftCenterRight ; Places 3 characters on a line:  R5 on left, R6 at center, and
code:00001ABD ; End of function DrawBottomCorners     ; R7 at right
code:00001ABD
code:00001ABF
code:00001ABF ; =============== S U B R O U T I N E =======================================
code:00001ABF
code:00001ABF ; Draws one of the lines between top and bottom
code:00001ABF
code:00001ABF DrawBoxLine:                            ; CODE XREF: DrawFancyBox+6↑p
code:00001ABF                 mov     R5, #0
code:00001AC1                 mov     R6, #0
code:00001AC3                 mov     R7, #0
code:00001AC5
code:00001AC5 DrawLeftCenterRight:                    ; CODE XREF: DrawTopCorners+6↑j
code:00001AC5                                         ; DrawBottomCorners+6↑j
code:00001AC5                 push    DPH             ; Places 3 characters on a line:  R5 on left, R6 at center, and
code:00001AC5                                         ; R7 at right
code:00001AC7                 push    DPL             ; Data Pointer, Low Byte
code:00001AC9                 mov     A, R5
code:00001ACA                 movx    @DPTR, A
code:00001ACB
code:00001ACB
code:00001ACB                 mov     A, #39
code:00001ACD                 add     A, DPL          ; Data Pointer, Low Byte
code:00001ACF                 mov     DPL, A          ; Data Pointer, Low Byte
code:00001AD1                 jnc     code_1AD5
code:00001AD3
code:00001AD3
code:00001AD3                 inc     DPH             ; Data Pointer, High Byte
code:00001AD5
code:00001AD5 code_1AD5:                              ; CODE XREF: DrawBoxLine+12↑j
code:00001AD5                 mov     A, R6
code:00001AD6                 movx    @DPTR, A
code:00001AD7
code:00001AD7
code:00001AD7                 mov     A, #39
code:00001AD9                 add     A, DPL          ; Data Pointer, Low Byte
code:00001ADB                 mov     DPL, A          ; Data Pointer, Low Byte
code:00001ADD                 jnc     code_1AE1
code:00001ADF
code:00001ADF
code:00001ADF                 inc     DPH             ; Data Pointer, High Byte
code:00001AE1
code:00001AE1 code_1AE1:                              ; CODE XREF: DrawBoxLine+1E↑j
code:00001AE1                 mov     A, R7
code:00001AE2                 movx    @DPTR, A
code:00001AE3                 pop     DPL             ; Data Pointer, Low Byte
code:00001AE5                 pop     DPH             ; Data Pointer, High Byte
code:00001AE7                 ret
code:00001AE7 ; End of function DrawBoxLine
code:00001AE7
code:00001AE8
code:00001AE8 ; =============== S U B R O U T I N E =======================================
code:00001AE8
code:00001AE8
code:00001AE8 PrintRowColPrefixedHiBitTermString:     ; CODE XREF: DrawSettingsKeyMenu+8↑j
code:00001AE8                                         ; EraseAllEntries+A5↑p ...
code:00001AE8                 clr     A
code:00001AE9                 movc    A, @A+DPTR
code:00001AEA                 inc     DPTR
code:00001AEB                 mov     CursorColumn, A
code:00001AED                 clr     A
code:00001AEE                 movc    A, @A+DPTR
code:00001AEF                 inc     DPTR
code:00001AF0                 mov     CursorRow, A
code:00001AF0 ; End of function PrintRowColPrefixedHiBitTermString
code:00001AF0
code:00001AF2
code:00001AF2 ; =============== S U B R O U T I N E =======================================
code:00001AF2
code:00001AF2
code:00001AF2 PrintHiBitTermString:                   ; CODE XREF: EraseAllEntries:PrintEntryForm↑p
code:00001AF2                                         ; EraseEntry+9↑p ...
code:00001AF2                 acall   j_CalcCursorAddr
code:00001AF4
code:00001AF4
code:00001AF4                 mov     R0, CursorAddr+1
code:00001AF6                 mov     R1, CursorAddr
code:00001AF8
code:00001AF8 code_1AF8:                              ; CODE XREF: PrintHiBitTermString+10↓j
code:00001AF8                 clr     A
code:00001AF9                 movc    A, @A+DPTR
code:00001AFA                 inc     DPTR
code:00001AFB                 jb      ACC7, code_1B04 ; Accumulator
code:00001AFE
code:00001AFE
code:00001AFE                 inc     CursorColumn
code:00001B00                 acall   j_PutCharToScreen_0 ; R1:R0 = destination
code:00001B00                                         ; A = character
code:00001B00                                         ;
code:00001B00                                         ; Auto-increments R1:R0
code:00001B02                 sjmp    code_1AF8
code:00001B04 ; ---------------------------------------------------------------------------
code:00001B04
code:00001B04 code_1B04:                              ; CODE XREF: PrintHiBitTermString+9↑j
code:00001B04                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001B04 ; End of function PrintHiBitTermString  ; Bit 1 = Receive buffer is full
code:00001B04                                         ; Bit 3 = Serial send register busy
code:00001B04                                         ; Bit 4 = Busy drawing to screen
code:00001B04                                         ; Bit 5 = Steady/Blink
code:00001B04                                         ; Bit 6 = Disable keyboard
code:00001B04                                         ; Bit 7 = Standard/Graphics
code:00001B06 ; [00000003 BYTES: COLLAPSED FUNCTION j_CalcCursorAddr. PRESS CTRL-NUMPAD+ TO EXPAND]
code:00001B09
code:00001B09 ; =============== S U B R O U T I N E =======================================
code:00001B09
code:00001B09 ; TmpI = entry number
code:00001B09 ;
code:00001B09 ; Sets DirEntryType.
code:00001B09 ;
code:00001B09 ; Returns start of name
code:00001B09
code:00001B09 LookupNthDirectoryEntry:                ; CODE XREF: ConnectMenuHandler+1E↑p
code:00001B09                                         ; EraseAllEntries+9D↑p ...
code:00001B09                 push    TmpI            ; Often the phone book entry number, but can also be used as
code:00001B09                                         ; settings index
code:00001B0B                 lcall   j_FindNthDirectoryEntry ; TmpI = entry number
code:00001B0B                                         ;
code:00001B0B                                         ; On return:
code:00001B0B                                         ;
code:00001B0B                                         ; A = entry type
code:00001B0E                 mov     DirEntryType, A
code:00001B10                 pop     TmpI            ; Often the phone book entry number, but can also be used as
code:00001B10                                         ; settings index
code:00001B12
code:00001B12
code:00001B12                 movx    A, @DPTR
code:00001B13                 anl     A, #0xF
code:00001B15                 ret
code:00001B15 ; End of function LookupNthDirectoryEntry
code:00001B15
code:00001B16
code:00001B16 ; =============== S U B R O U T I N E =======================================
code:00001B16
code:00001B16
code:00001B16 IncrementDPTRLine:                      ; CODE XREF: DrawLargeBoxLetters+5↑p
code:00001B16                                         ; DrawFancyBox:DrawMiddleBoxLoop↑p ...
code:00001B16                 mov     A, #96
code:00001B18                 add     A, DPL          ; Data Pointer, Low Byte
code:00001B1A                 mov     DPL, A          ; Data Pointer, Low Byte
code:00001B1C                 jnc     code_1B20
code:00001B1E
code:00001B1E
code:00001B1E                 inc     DPH             ; Data Pointer, High Byte
code:00001B20
code:00001B20 code_1B20:                              ; CODE XREF: IncrementDPTRLine+6↑j
code:00001B20                 ret
code:00001B20 ; End of function IncrementDPTRLine
code:00001B20
code:00001B21
code:00001B21 ; =============== S U B R O U T I N E =======================================
code:00001B21
code:00001B21 ; Draws a horizontal line at DPTR, 78 chars starting at
code:00001B21 ; position 1
code:00001B21
code:00001B21 DrawHorizLine:                          ; CODE XREF: DrawFancyBox↑p
code:00001B21                                         ; DrawFancyBox+C↑p
code:00001B21                 push    DPL             ; Data Pointer, Low Byte
code:00001B23                 push    DPH             ; Data Pointer, High Byte
code:00001B25                 inc     DPTR
code:00001B26                 mov     B, #77          ; B-Register
code:00001B29                 mov     A, #1
code:00001B2B
code:00001B2B code_1B2B:                              ; CODE XREF: DrawHorizLine+C↓j
code:00001B2B                 movx    @DPTR, A
code:00001B2C                 inc     DPTR
code:00001B2D                 djnz    B, code_1B2B    ; B-Register
code:00001B30                 pop     DPH             ; Data Pointer, High Byte
code:00001B32                 pop     DPL             ; Data Pointer, Low Byte
code:00001B34                 ret
code:00001B34 ; End of function DrawHorizLine
code:00001B34
code:00001B35
code:00001B35 ; =============== S U B R O U T I N E =======================================
code:00001B35
code:00001B35
code:00001B35 ClearBottomHalfScreen:                  ; CODE XREF: EraseAllEntries+B↑p
code:00001B35                                         ; EraseAllEntries+53↑p ...
code:00001B35                 mov     DPTR, #VideoLine18
code:00001B38                 mov     R2, #8
code:00001B3A
code:00001B3A j_ClearNLines:                          ; CODE XREF: DrawFunctionKeyMenu+7↑p
code:00001B3A                                         ; DrawLargeBox+7↑p
code:00001B3A                 ljmp    ClearNLines
code:00001B3A ; End of function ClearBottomHalfScreen
code:00001B3A
code:00001B3D
code:00001B3D ; =============== S U B R O U T I N E =======================================
code:00001B3D
code:00001B3D
code:00001B3D PrintHoldSaveReturnMsg:                 ; CODE XREF: SettingsSaveChanges↑p
code:00001B3D                                         ; EraseAllEntries:GetDoubleConfirmation↑p ...
code:00001B3D                 mov     DPTR, #aHoldSaveButton_0 ; "Hold SAVE button, then hit RETURN "
code:00001B40                 mov     CursorColumn, #0
code:00001B43                 mov     CursorRow, #24
code:00001B46                 sjmp    PrintHiBitTermString
code:00001B46 ; End of function PrintHoldSaveReturnMsg
code:00001B46
code:00001B48
code:00001B48 ; =============== S U B R O U T I N E =======================================
code:00001B48
code:00001B48
code:00001B48 PrintOKConfirmationMsg:                 ; CODE XREF: EraseAllEntries+1D↑p
code:00001B48                                         ; EraseAllEntries+157↑p
code:00001B48                 mov     DPTR, #aOK_YN
code:00001B4B                 sjmp    PrintRowColPrefixedHiBitTermString
code:00001B4B ; End of function PrintOKConfirmationMsg
code:00001B4B
code:00001B4B ; ---------------------------------------------------------------------------
code:00001B4D aOK_YN:         .byte    0,0x17         ; DATA XREF: PrintOKConfirmationMsg↑o
code:00001B4F                 .text "OK? (Y/N) "
code:00001B59                 .byte 0x81
code:00001B5A aDIRECTORY:     .word VideoLine2+0x22   ; DATA XREF: PrintDirectoryContents+2↑o
code:00001B5C                 .text " DIRECTORY "
code:00001B67                 .byte 0x81
code:00001B68 FunctionKeyMenu:.word VideoLine18+0x23  ; DATA XREF: DrawFunctionKeyMenu+10↑o
code:00001B6A                 .text " ACTIONS "
code:00001B73                 .byte 0x80
code:00001B74                 .word VideoLine19+1
code:00001B76                 .text "F1 -"
code:00001B7A                 .byte 0x80
code:00001B7B                 .word VideoLine20+1
code:00001B7D                 .text "F2 -"
code:00001B81                 .byte 0x80
code:00001B82                 .word VideoLine19+0x28
code:00001B84                 .text "F3 -"
code:00001B88                 .byte 0x80
code:00001B89                 .word VideoLine20+0x28
code:00001B8B                 .text "F4 -"
code:00001B8F                 .byte 0x81
code:00001B90 aDialMenu:      .word VideoLine17+1     ; DATA XREF: PrintConnectMenu+7↑o
code:00001B92                 .text "Press a LETTER to dial"
code:00001BA8                 .byte 0x80
code:00001BA9                 .word VideoLine19+6
code:00001BAB                 .text "MANUAL dial"
code:00001BB6                 .byte 0x80
code:00001BB7                 .word VideoLine20+6
code:00001BB9                 .text "CHANGE directory"
code:00001BC9                 .byte 0x80
code:00001BCA                 .word VideoLine19+0x2D
code:00001BCC                 .text "SETUP"
code:00001BD1                 .byte 0x80
code:00001BD2                 .word VideoLine20+0x2D
code:00001BD4                 .text "ON LINE"
code:00001BDB                 .byte 0x81
code:00001BDC aConnectMenu:   .word VideoLine23+2     ; DATA XREF: PrintConnectMenu+13↑o
code:00001BDE                 .text "< - Connect in originate mode"
code:00001BFB                 .byte 0x80
code:00001BFC                 .word VideoLine24+2
code:00001BFE                 .text "> - Connect in answer mode"
code:00001C18                 .byte 0x80
code:00001C19                 .word VideoLine23+0x29
code:00001C1B                 .text "~ - Return to voice"
code:00001C2E                 .byte 0x80
code:00001C2F                 .word VideoLine24+0x29
code:00001C31                 .text "| - Hang up"
code:00001C3C                 .byte 0x81
code:00001C3D aSettingsKeys:  .word VideoLine19+6     ; DATA XREF: DrawSettingsKeyMenu↑o
code:00001C3F                 .text "INCREASE"
code:00001C47                 .byte 0x80
code:00001C48                 .word VideoLine20+6
code:00001C4A                 .text "DECREASE"
code:00001C52                 .byte 0x80
code:00001C53                 .word VideoLine19+0x2D
code:00001C55                 .text "SET time"
code:00001C5D                 .byte 0x80
code:00001C5E                 .word VideoLine20+0x2D
code:00001C60                 .text "SAVE changes"
code:00001C6C                 .byte 0x80
code:00001C6D                 .word VideoLine17+0x2D
code:00001C6F                 .text "* RESET restores default"
code:00001C87                 .byte 0x81
code:00001C88 aDirectoryMenu: .word VideoLine19+6     ; DATA XREF: EraseAllEntries+30↑o
code:00001C8A aAdd:           .text "ADD "            ; DATA XREF: EraseAllEntries+8D↑o
code:00001C8E                 .byte 0x80
code:00001C8F                 .word VideoLine20+6
code:00001C91 aErase:         .text "ERASE "          ; DATA XREF: EraseEntry+6↑o
code:00001C97                 .byte 0x80
code:00001C98                 .word VideoLine19+0x2D
code:00001C9A aChange:        .text "CHANGE "         ; DATA XREF: EraseAllEntries+59↑o
code:00001CA1                 .byte 0x80
code:00001CA2                 .word VideoLine20+0x2D
code:00001CA4                 .text "ERASE ALL"
code:00001CAD                 .byte 0x81
code:00001CAE aEntryMenu:     .word VideoLine19+6     ; DATA XREF: ManualDial+B↑o
code:00001CB0                 .text "Change dial #"
code:00001CBD                 .byte 0x80
code:00001CBE                 .word VideoLine20+1
code:00001CC0                 .text "     Dial # ="
code:00001CCD                 .byte 0x80
code:00001CCE                 .word VideoLine19+0x2D
code:00001CD0                 .text "Dial Data"
code:00001CD9                 .byte 0x80
code:00001CDA                 .word VideoLine20+0x2D
code:00001CDC                 .text "Dial Voice"
code:00001CE6                 .byte 0x81
code:00001CE7
code:00001CE7 ; =============== S U B R O U T I N E =======================================
code:00001CE7
code:00001CE7
code:00001CE7 PrintDialEntryForm:                     ; CODE XREF: EraseAllEntries+56↑p
code:00001CE7                                         ; EraseAllEntries+8A↑p ...
code:00001CE7                 clr     VideoSettings.4 ; Bit 0 = ONLINE=1, OFFLINE=0
code:00001CE7                                         ; Bit 1 = Receive buffer is full
code:00001CE7                                         ; Bit 3 = Serial send register busy
code:00001CE7                                         ; Bit 4 = Busy drawing to screen
code:00001CE7                                         ; Bit 5 = Steady/Blink
code:00001CE7                                         ; Bit 6 = Disable keyboard
code:00001CE7                                         ; Bit 7 = Standard/Graphics
code:00001CE9                 mov     DPTR, #aDirectoryForm
code:00001CEC                 ajmp    PrintRowColPrefixedHiBitTermString
code:00001CEC ; End of function PrintDialEntryForm
code:00001CEC
code:00001CEC ; ---------------------------------------------------------------------------
code:00001CEE aDirectoryForm: .byte    0,0x11         ; DATA XREF: PrintDialEntryForm+2↑o
code:00001CF0                 .text "Entry to "
code:00001CF9                 .byte 0x81
code:00001CFA aName:          .byte    0,0x12         ; DATA XREF: EraseAllEntries+B3↑o
code:00001CFC                 .text "Name: "
code:00001D02                 .byte 0x81
code:00001D03 aPhone:         .byte    0,0x13         ; DATA XREF: EraseAllEntries:NameSuccess↑o
code:00001D05                 .text "Phone: "
code:00001D0C                 .byte 0x81
code:00001D0D aHoldSaveButton:.word VideoLine3        ; DATA XREF: CheckAndInitDirectory+1E↑o
code:00001D0F aHoldSaveButton_0:.text "Hold SAVE button, then hit RETURN "
code:00001D0F                                         ; DATA XREF: PrintHoldSaveReturnMsg↑o
code:00001D31                 .byte 0x81
code:00001D32 aNotUsedPressRETURN:.byte    0,0x12     ; DATA XREF: EraseEntry+18↑o
code:00001D34                 .text "Not used, press RETURN"
code:00001D4A                 .byte 0x81
code:00001D4B aInUsePressRETURN:.byte    0,0x12       ; DATA XREF: EraseAllEntries+A2↑o
code:00001D4D                 .text "In use, press RETURN"
code:00001D61                 .byte 0x81
code:00001D62 aEraseAllEntries:.byte 0x90             ; DATA XREF: EraseAllEntries+12↑o
code:00001D63                 .text "Erase all entries"
code:00001D74                 .byte 0x80,   0
code:00001D76 aEraseRAM:      .byte 0x90              ; DATA XREF: EraseAllEntries+18↑o
code:00001D77                 .text "Erase RAM"
code:00001D80                 .byte 0x80,   0
code:00001D82 aSelect:        .byte    1,0x10         ; DATA XREF: DrawSettingsKeyMenu+5↑o
code:00001D84                 .text "Select:"
code:00001D8B                 .byte 0x81
code:00001D8C aLogOn:         .byte    0,0x15         ; DATA XREF: EraseAllEntries+117↑o
code:00001D8E                 .text "Log on: "
code:00001D96                 .byte 0x81
code:00001D97 aSetup:         .word VideoLine2+0x24   ; DATA XREF: ChangeSettings+3↑o
code:00001D99                 .text " SETUP "
code:00001DA0                 .byte 0x80
code:00001DA1                 .word VideoLine3+3
code:00001DA3                 .text "* Time set (00:00:00)"
code:00001DB8                 .byte 0x80
code:00001DB9                 .word VideoLine4+5
code:00001DBB                 .text "Clock display (   )"
code:00001DCE                 .byte 0x80
code:00001DCF                 .word VideoLine6+3
code:00001DD1                 .text "* Auto answer after (  ) rings"
code:00001DEF                 .byte 0x80
code:00001DF0                 .word VideoLine7+5
code:00001DF2                 .text "Wait (   ) sec. for answer"
code:00001E0C                 .byte 0x80
code:00001E0D                 .word VideoLine8+5
code:00001E0F                 .text "/ Pause (0.0) sec."
code:00001E21                 .byte 0x80
code:00001E22                 .word VideoLine10+5
code:00001E24                 .text "(    ) duplex"
code:00001E31                 .byte 0x80
code:00001E32                 .word VideoLine11+5
code:00001E34                 .text "Handshaking (        )"
code:00001E4A                 .byte 0x80
code:00001E4B                 .word VideoLine3+0x2C
code:00001E4D                 .text "Auto repeat (   )"
code:00001E5E                 .byte 0x80
code:00001E5F                 .word VideoLine4+0x2C
code:00001E61                 .text "Key click (   )"
code:00001E70                 .byte 0x80
code:00001E71                 .word VideoLine6+0x2A
code:00001E73                 .text "* Cursor (      )"
code:00001E84                 .byte 0x80
code:00001E85                 .word VideoLine10+0x2C
code:00001E87                 .text "Wrap at end of line (   )"
code:00001EA0                 .byte 0x80
code:00001EA1                 .word VideoLine11+0x2C
code:00001EA3                 .text "Auto LF on CR (   )"
code:00001EB6                 .byte 0x80
code:00001EB7                 .word VideoLine12+0x2C
code:00001EB9                 .text "Auto CR on LF (   )"
code:00001ECC                 .byte 0x80
code:00001ECD                 .byte 0x81
code:00001ECE aOn:            .text "on "             ; DATA XREF: PrintOnOffToScreen↑o
code:00001ECE                 .byte 0
code:00001ED2 aOff:           .text "off"             ; DATA XREF: PrintOnOffToScreen+5↑o
code:00001ED2                 .byte 0
code:00001ED6 aBlink:         .text "blink "          ; DATA XREF: PrintSettingsToScreen+30↑o
code:00001ED6                 .byte 0
code:00001EDD aSteady:        .text "steady"          ; DATA XREF: PrintSettingsToScreen+36↑o
code:00001EDD                 .byte 0
code:00001EE4 aFull:          .text "Full"            ; DATA XREF: PrintSettingsToScreen+4F↑o
code:00001EE4                 .byte 0
code:00001EE9 aHalf:          .text "Half"            ; DATA XREF: PrintSettingsToScreen+55↑o
code:00001EE9                 .byte 0
code:00001EEE aXonXoff:       .text "XON/XOFF"        ; DATA XREF: PrintSettingsToScreen+9D↑o
code:00001EEE                 .byte 0
code:00001EF7 aNone:          .text "none    "        ; DATA XREF: PrintSettingsToScreen+A3↑o
code:00001EF7                 .byte 0
code:00001F00 aMemoryFull:    .byte 0x90              ; DATA XREF: EraseAllEntries+190↑o
code:00001F01                 .text "Memory full"
code:00001F0C                 .byte 0x80
code:00001F0D                 .text ", press RETURN"
code:00001F0D                 .byte 0
code:00001F1C
code:00001F1C ; =============== S U B R O U T I N E =======================================
code:00001F1C
code:00001F1C ; A = index.  Note that indices start at 7
code:00001F1C
code:00001F1C IndexToDirectoryType:                   ; CODE XREF: PrintNthDirectoryEntry+C↑p
code:00001F1C                 clr     C
code:00001F1D                 subb    A, #7
code:00001F1F                 movc    A, @A+PC
code:00001F20                 ret
code:00001F20 ; End of function IndexToDirectoryType
code:00001F20
code:00001F20 ; ---------------------------------------------------------------------------
code:00001F21 aVdsyt:         .text "VDSYT   "        ; DATA XREF: TranslateCallTypeText↑o
code:00001F29 aCallType:      .text "Call type ("     ; DATA XREF: EraseAllEntries:GetCallType↑o
code:00001F34                 .byte 0x90
code:00001F35                 .text "S"
code:00001F36                 .byte 0x80
code:00001F37                 .text "ource direct, "
code:00001F45                 .byte 0x90
code:00001F46                 .text "T"
code:00001F47                 .byte 0x80
code:00001F48                 .text "elenet, t"
code:00001F51                 .byte 0x90
code:00001F52                 .byte 'Y
code:00001F53                 .byte 0x80
code:00001F54                 .text "mnet, "
code:00001F5A                 .byte 0x90
code:00001F5B                 .byte 'D
code:00001F5C                 .byte 0x80
code:00001F5D                 .text "ata, or "
code:00001F65                 .byte 0x90
code:00001F66                 .byte 'V
code:00001F67                 .byte 0x80
code:00001F68                 .text "oice):"
code:00001F68                 .byte 0
code:00001F6F VoiceDataScript:.byte 0                 ; DATA XREF: code:DirEntryTypeTable↓o
code:00001F6F                                         ; code:00001FA5↓o
code:00001F70 SourceDirectScript:.byte 5              ; DATA XREF: code:00001FA7↓o
code:00001F71                 .byte 0xF9,0x1B,0x89,   0
code:00001F75                 .byte 0xD
code:00001F76                 .byte '>
code:00001F77                 .byte 'I,'D,'
code:00001F7A                 .byte 0xD
code:00001F7B TymnetScript:   .byte 7                 ; DATA XREF: code:00001FA9↓o
code:00001F7C                 .byte 0x49,0x1F,0x89,0x1B,0x89,   0
code:00001F82                 .byte 'f,'i,'e,'r
code:00001F86                 .byte 'A
code:00001F87                 .byte ':
code:00001F88                 .byte 0xD
code:00001F89                 .byte '>
code:00001F8A                 .byte 'I,'D,'
code:00001F8D                 .byte 0xD
code:00001F8E TelenetScript:  .byte 8                 ; DATA XREF: code:00001FAB↓o
code:00001F8F                 .byte 0xF9,0xF9,0x1B,0x18,0x91,0xB8,0x90
code:00001F96                 .byte 0xD
code:00001F97                 .byte 0xD
code:00001F98                 .byte '=
code:00001F99                 .byte 'D,'1,0xD
code:00001F9C                 .byte '@
code:00001F9D                 .byte 0xD
code:00001F9E                 .byte '>
code:00001F9F                 .byte 'I,'D,'
code:00001FA2                 .byte 0xD
code:00001FA3 DirEntryTypeTable:.word VoiceDataScript ; DATA XREF: LookupDialTypeScript↑o
code:00001FA5                 .word VoiceDataScript
code:00001FA7                 .word SourceDirectScript
code:00001FA9                 .word TymnetScript
code:00001FAB                 .word TelenetScript
code:00001FAD                 .byte    0
code:00001FAE                 .byte    0
code:00001FAF                 .byte    0
code:00001FB0                 .byte    0
code:00001FB1                 .byte    0
code:00001FB2                 .byte    0
code:00001FB3                 .byte    0
code:00001FB4                 .byte    0
code:00001FB5                 .byte    0
code:00001FB6                 .byte    0
code:00001FB7                 .byte    0
code:00001FB8                 .byte    0
code:00001FB9                 .byte    0
code:00001FBA                 .byte    0
code:00001FBB                 .byte    0
code:00001FBC                 .byte    0
code:00001FBD                 .byte    0
code:00001FBE                 .byte    0
code:00001FBF                 .byte    0
code:00001FC0                 .byte    0
code:00001FC1                 .byte    0
code:00001FC2                 .byte    0
code:00001FC3                 .byte    0
code:00001FC4                 .byte    0
code:00001FC5                 .byte    0
code:00001FC6                 .byte    0
code:00001FC7                 .byte    0
code:00001FC8                 .byte    0
code:00001FC9                 .byte    0
code:00001FCA                 .byte    0
code:00001FCB                 .byte    0
code:00001FCC                 .byte    0
code:00001FCD                 .byte    0
code:00001FCE                 .byte    0
code:00001FCF                 .byte    0
code:00001FD0                 .byte    0
code:00001FD1                 .byte    0
code:00001FD2                 .byte    0
code:00001FD3                 .byte    0
code:00001FD4                 .byte    0
code:00001FD5                 .byte    0
code:00001FD6                 .byte    0
code:00001FD7                 .byte    0
code:00001FD8                 .byte    0
code:00001FD9                 .byte    0
code:00001FDA                 .byte    0
code:00001FDB                 .byte    0
code:00001FDC                 .byte    0
code:00001FDD                 .byte    0
code:00001FDE                 .byte    0
code:00001FDF                 .byte    0
code:00001FE0                 .byte    0
code:00001FE1                 .byte    0
code:00001FE2                 .byte    0
code:00001FE3                 .byte    0
code:00001FE4                 .byte    0
code:00001FE5                 .byte    0
code:00001FE6                 .byte    0
code:00001FE7                 .byte    0
code:00001FE8                 .byte    0
code:00001FE9                 .byte    0
code:00001FEA                 .byte    0
code:00001FEB                 .byte    0
code:00001FEC                 .byte    0
code:00001FED                 .byte    0
code:00001FEE                 .byte    0
code:00001FEF                 .byte    0
code:00001FF0                 .byte    0
code:00001FF1                 .byte    0
code:00001FF2                 .byte    0
code:00001FF3                 .byte    0
code:00001FF4                 .byte    0
code:00001FF5                 .byte    0
code:00001FF6                 .byte    0
code:00001FF7                 .byte    0
code:00001FF8                 .byte    0
code:00001FF9                 .byte    0
code:00001FFA                 .byte    0
code:00001FFB                 .byte    0
code:00001FFC                 .byte    0
code:00001FFD                 .byte    0
code:00001FFE                 .byte    0
code:00001FFF                 .byte    0
code:00001FFF ; end of 'code'
code:00001FFF
RAM:0000 ; ===========================================================================
RAM:0000
RAM:0000 ; Segment type: Internal processor memory & SFR
RAM:0000                 ;.segment RAM
RAM:0000 .equ B0R0,0                             ; DATA XREF: EraseAllEntries+145↑r
RAM:0001 .equ B0R1,1                             ; DATA XREF: CalcCursorEndOfLine+F↑w
RAM:0001                                         ; LookupBaudDivisor+1C↑r
RAM:0002 .equ B0R2,2                             ; DATA XREF: GetEntryMovementAmount+2↑r
RAM:0002                                         ; GetEntryMovementAmount+22↑r ...
RAM:0003 .equ B0R3,3                             ; DATA XREF: TerminalLoop+8A↑r
RAM:0003                                         ; TerminalLoop+8F↑w ...
RAM:0004 .equ B0R4,4                             ; DATA XREF: LookupFunctionByTag+4↑r
RAM:0005 .equ B0R5_MappedCursorRow,5             ; DATA XREF: TypeLF+18↑w
RAM:0005                                         ; TypeLF+24↑r ...
RAM:0006 .equ B0R6,6                             ; DATA XREF: ReadDigit09+14↑r
RAM:0006                                         ; EraseAllEntries+14B↑r ...
RAM:0007 .equ B0R7,7                             ; DATA XREF: EraseAllEntries+187↑w
RAM:0007                                         ; PrintDirectoryColumn+4↑w ...
RAM:0008 .equ B1R0,8
RAM:0009 .equ B1R1,9                             ; Initialized to 2
RAM:000A .equ B1R2_CursorLinePtr,0xA             ; DATA XREF: IE0+33↑r
RAM:000A                                         ; Initialized to 0x4000, video RAM
RAM:000C .equ B1R4,0xC
RAM:000D .equ B1R5,0xD
RAM:000E .equ B1R6,0xE
RAM:000F .equ B1R7,0xF
RAM:0010 .equ SerialInBufLen,0x10                ; DATA XREF: RESET_0+44↑o
RAM:0010                                         ; GetNextSerialInChar+6↑r ...
RAM:0011 .equ SerialInBufPtr,0x11                ; DATA XREF: GetNextSerialInChar+1F↑r
RAM:0011                                         ; GetNextSerialInChar+26↑w ...
RAM:0012 .equ SerialOutBufLen,0x12               ; DATA XREF: GetNextSerialOutChar↑r
RAM:0012                                         ; GetNextSerialOutChar:code_1DA↑w ...
RAM:0013 .equ SerialOutBufPtr,0x13               ; DATA XREF: GetNextSerialOutChar+8↑r
RAM:0013                                         ; GetNextSerialOutChar+F↑w ...
RAM:0014 .equ CursorColumn,0x14                  ; DATA XREF: TypeCharToScreen+31↑r
RAM:0014                                         ; TypeCharToScreen:PrevWasNormal↑w ...
RAM:0015 .equ CursorRow,0x15                     ; DATA XREF: RESET_0+5A↑w
RAM:0015                                         ; SendCursorPos+C↑r ...
RAM:0016 .equ CursorAddr,0x16                    ; DATA XREF: RESET_0+5E↑w
RAM:0016                                         ; TypeCharToScreen+25↑r ...
RAM:0018 .equ TerminalState,0x18                 ; DATA XREF: PerformState+3↑r
RAM:0018                                         ; PerformState+3B↑w ...
RAM:0019 .equ TmpI,0x19                          ; DATA XREF: FindNthDirectoryEntry:FindEntryNext↑w
RAM:0019                                         ; UnpackDialScript+6↑w ...
RAM:0019                                         ; Often the phone book entry number, but can also be used as
RAM:0019                                         ; settings index
RAM:001A .equ T0MultA,0x1A                       ; DATA XREF: TF0:A_Expires↑r
RAM:001A                                         ; PerformState:HandshakeDetected↑r ...
RAM:001A                                         ; Timer 0 frequency
RAM:001B .equ AutoAnswerAfter,0x1B               ; DATA XREF: PerformState:TermState0↑r
RAM:001B                                         ; ChangeSettings:AdjustAutoAnswerRings↑r ...
RAM:001B                                         ; Number of rings to wait
RAM:001C .equ RingCountdown,0x1C                 ; DATA XREF: PerformState+4F↑w
RAM:001C                                         ; PerformState+64↑w
RAM:001D .equ PulseCount,0x1D                    ; DATA XREF: PerformState:SendPulses↑w
RAM:001D                                         ; PerformState+137↑w
RAM:001E .equ T0MultB,0x1E                       ; DATA XREF: TF0+76↑w
RAM:001E                                         ; PerformState+175↑r ...
RAM:001E                                         ; Number of times T0 will expire before it is shut down
RAM:001F .equ T0MultACnt,0x1F                    ; DATA XREF: TF0+73↑w
RAM:001F                                         ; TF0:A_Expires↑w ...
RAM:001F                                         ; Counts down until it reaches 0 then decreases the duration.  Reset to T0Freq
RAM:0020
RAM:0020 ;
RAM:0020 ; The following flags were named after their first observed use.  They
RAM:0020 ; all seem more like misc flags, though some do group better than
RAM:0020 ; others do.
RAM:0020 ;
RAM:0020 .equ VideoSettings,0x20                 ; DATA XREF: IE1+46↑r
RAM:0020                                         ; RI_TI+7F↑r ...
RAM:0020                                         ; Bit 0 = ONLINE=1, OFFLINE=0
RAM:0020                                         ; Bit 1 = Receive buffer is full
RAM:0020                                         ; Bit 3 = Serial send register busy
RAM:0020                                         ; Bit 4 = Busy drawing to screen
RAM:0020                                         ; Bit 5 = Steady/Blink
RAM:0020                                         ; Bit 6 = Disable keyboard
RAM:0020                                         ; Bit 7 = Standard/Graphics
RAM:0021 .equ SerialSettings,0x21                ; DATA XREF: RESET_0+7C↑w
RAM:0021                                         ; GetNextSerialInChar↑r ...
RAM:0021                                         ; Bit 0 = Clock display off
RAM:0021                                         ; Bit 1 = Flow control.  1=None, 0=XON,XOFF
RAM:0021                                         ; Bit 2 = Half/Full duplex
RAM:0021                                         ; Bit 3 = Auto Repeat disable
RAM:0021                                         ; Bit 4 = Key click disable
RAM:0021                                         ; Bit 5 = LF->CRLF
RAM:0021                                         ; Bit 6 = CR->CRLF
RAM:0021                                         ; Bit 7 = Wrap at EOL off
RAM:0022 .equ PrinterStatus,0x22                 ; DATA XREF: RI_TI+95↑r
RAM:0022                                         ; RI_TI+98↑w ...
RAM:0022                                         ; Bit 0 = Printer
RAM:0022                                         ; Bit 1 = Need to send XOFF
RAM:0022                                         ; Bit 2 = Toggle printer state
RAM:0022                                         ; Bit 3 = No writes to status line
RAM:0022                                         ;         No update of time or print status.  Set cursor position ESC
RAM:0022                                         ;         code cannot set cursor to row 1
RAM:0022                                         ; Bit 4 = No writes to status line
RAM:0022                                         ;         Enabled by ESC code.  Saves and clears bit 3 when set.
RAM:0022                                         ;         Mutually exclusive with bit 3.  DOES allow set cursor
RAM:0022                                         ;         position to row 1
RAM:0022                                         ; Bit 5 = 1=MENU, 0=TERMINAL
RAM:0022                                         ; Bit 6 = Key pressed
RAM:0022                                         ; Bit 7 = Repeat eligible
RAM:0023 .equ TimerStatus,0x23                   ; DATA XREF: TF0+79↑w
RAM:0023                                         ; ForceStatusLineUpdate+3↑w ...
RAM:0023                                         ; Bit 0 = ESC is tracked as pressed
RAM:0023                                         ; Bit 1 = BREAK is tracked as pressed
RAM:0023                                         ; Bit 2 = Copy of ONLINE bit, used to detect change in status
RAM:0023                                         ; Bit 3 = Timer 0 is active.  This bit is set after programming.  It is
RAM:0023                                         ;         cleared by the timer ISR when it expires.  The terminal state
RAM:0023                                         ;         handler uses this to look for timeouts in each state.
RAM:0023                                         ; Bit 4 = Use immediate dial buffer
RAM:0023                                         ; Bit 5 = Dial voice
RAM:0023                                         ; Bit 6 = Disabling/Enabling a setting
RAM:0023                                         ; Bit 7 = Dial memory must expand/contract for new entry
RAM:0024 .equ FormatStatus,0x24                  ; DATA XREF: ScreenToVT52Char+1E↑r
RAM:0024                                         ; ScreenToVT52Char+21↑w ...
RAM:0024                                         ; Bit 0 = Ctrl-F1 pressed
RAM:0024                                         ; Bit 1 = Save of Disable Status Bar flag
RAM:0024                                         ; Bit 2 = In graphics mode
RAM:0025
RAM:0025
RAM:0025
RAM:0025
RAM:0025
RAM:0025
RAM:0025 .equ ShiftStatus,0x25                   ; DATA XREF: CheckKeyboard+18↑w
RAM:0025                                         ; CheckKeyboard+2F↑r ...
RAM:0025                                         ; Bit 0 = ESC
RAM:0025                                         ; Bit 1 = CAPS lock
RAM:0025                                         ; Bit 2 = Ctrl key
RAM:0025                                         ; Bit 3 = SHIFT key
RAM:0026 .equ DialScriptDataPtr,0x26             ; DATA XREF: UnpackDialScript+11↑w
RAM:0026                                         ; UnpackDialScript+5C↑r ...
RAM:0028 .equ VerifyPassCnt,0x28                 ; DATA XREF: UpdatePhoneBookCksum↑w
RAM:0028                                         ; UpdatePhoneBookCksum+11↑w
RAM:0029 .equ ContextFunctionPtr,0x29            ; DATA XREF: CallContextFunction+6↑w
RAM:0029                                         ; CallContextFunction+C↑r ...
RAM:0029                                         ; Often set to a deferred call address, but sometimes used for a pointer to video memory
RAM:002B .equ SavedCursorColumn,0x2B             ; DATA XREF: SaveCursorPosition↑w
RAM:002B                                         ; LoadCursorPosition↑r
RAM:002C .equ SavedCursorRow,0x2C                ; DATA XREF: RESET_0+5C↑w
RAM:002C                                         ; SaveCursorPosition+3↑w ...
RAM:002D .equ LineNumbers,0x2D                   ; DATA XREF: IE1:CalcOutputLine↑o
RAM:002D                                         ; InitLineMap+1↑o ...
RAM:002D                                         ; In order to make scrolling faster, the system does not
RAM:002D                                         ; actually move data around.  Instead, it uses this array of
RAM:002D                                         ; lines as a list of indices into VRAM.  To scroll the
RAM:002D                                         ; screen, just rotate these numbers so that what was once
RAM:002D                                         ; 1-25 becomes 1,3-25,2.  Clear out line "2" to complete the
RAM:002D                                         ; scroll operation.
RAM:0046 .equ PressedKeyCode,0x46                ; DATA XREF: CheckKeyboard:CodeConverted↑w
RAM:0046                                         ; CheckKeyboard+98↑r
RAM:0047 .equ SavedKeyRowValue,0x47              ; DATA XREF: CheckKeyboard+27↑w
RAM:0047                                         ; CheckKeyboard+51↑r
RAM:0048 .equ RepeatCountDown,0x48               ; DATA XREF: CheckKeyboard+44↑w
RAM:0048                                         ; CheckKeyboard+92↑w ...
RAM:0049 .equ TimeUpdateCounter,0x49             ; DATA XREF: RESET_0+66↑w
RAM:0049                                         ; TimeBasedUpdates:CheckTimeUpdateCounter↑w ...
RAM:004A .equ BellDurationCounter,0x4A           ; DATA XREF: RESET_0+8F↑w
RAM:004A                                         ; DispatchTypedValue:ExecuteBell↑w ...
RAM:004B .equ DirEntryNumber,0x4B                ; DATA XREF: UnpackDialScript+4↑r
RAM:004B                                         ; ConnectMenuHandler+1C↑w
RAM:004C .equ DialStringCursor,0x4C              ; DATA XREF: GetNextNibbleFromByteString↑r
RAM:004C                                         ; GetNextNibbleFromByteString+2↑w ...
RAM:004D .equ DirEntryType,0x4D                  ; DATA XREF: TerminalLoop+47↑r
RAM:004D                                         ; TerminalLoop:LostConnection↑w ...
RAM:004E .equ SlashPause,0x4E                    ; DATA XREF: RESET_0+82↑w
RAM:004E                                         ; PerformState+10A↑r ...
RAM:004E                                         ; Time to wait when / is seen.  Value is 3*number+12
RAM:004F .equ SecWaitForAnswer,0x4F              ; DATA XREF: RESET_0+64↑w
RAM:004F                                         ; RESET_0+87↑w ...
RAM:004F                                         ; The actual value is this value*5
RAM:0050 .equ SerialSelection,0x50               ; DATA XREF: RESET_0+69↑w
RAM:0050                                         ; UpdateStatusLine+39↑r ...
RAM:0050                                         ; This is a character representing the routing selection for
RAM:0050                                         ; serial data.
RAM:0050                                         ;   <SPC> = MCU -> MODEM
RAM:0050                                         ;   1 = MCU -> RS232 (power plug)
RAM:0050                                         ;   2 = MCU -> MODEM with the DE9 listening to the modem
RAM:0050                                         ;   3 = MODEM -> DE9 with MCU listening to the modem
RAM:0051 .equ Scratchpad,0x51                    ; DATA XREF: SetTimeByESCCode↑w
RAM:0051                                         ; SetTimeByESCCode:code_4E6↑r ...
RAM:0052 .equ SavedT0MultB,0x52                  ; DATA XREF: PerformState+175↑w
RAM:0052                                         ; PerformState+182↑r
RAM:0053 .equ CharEquivalent,0x53                ; DATA XREF: ScreenToVT52Char:SaveCode↑w
RAM:0053                                         ; SendCharUnderCursor:SendTheChar↑r ...
RAM:0054 .equ TimeDigitsINT,0x54                 ; DATA XREF: RESET_0+16↑o
RAM:0054                                         ; TimeBasedUpdates+1C↑o ...
RAM:005A .equ StackTop,0x5A                      ; DATA XREF: RESET_0+2↑o
RAM:005A                                         ; RESET_0:Reset↑o
RAM:005A ; end of 'RAM'
RAM:005A
FSR:0080 ; ===========================================================================
FSR:0080
FSR:0080 ; Segment type: Internal processor memory & SFR
FSR:0080                 ;.segment FSR
FSR:0080 ; .equ $,  0x80
FSR:0080 .equ P0,0x80                            ; Port 0
FSR:0081 .equ SP,0x81                            ; DATA XREF: RESET_0+2↑w
FSR:0081                                         ; RESET_0:Reset↑w ...
FSR:0081                                         ; Stack Pointer
FSR:0082 .equ DPL,0x82                           ; DATA XREF: IE1+33↑r
FSR:0082                                         ; IE1+4E↑w ...
FSR:0082                                         ; Data Pointer, Low Byte
FSR:0083 .equ DPH,0x83                           ; DATA XREF: IE1+35↑r
FSR:0083                                         ; IE1:RestoreDPTR↑w ...
FSR:0083                                         ; Data Pointer, High Byte
FSR:0084 .equ RESERVED0084,0x84                  ; RESERVED
FSR:0085 .equ RESERVED0085,0x85                  ; RESERVED
FSR:0086 .equ RESERVED0086,0x86                  ; RESERVED
FSR:0087 .equ PCON,0x87                          ; DATA XREF: LookupBaudDivisor+1↑w
FSR:0087                                         ; LookupBaudDivisor+7↑r ...
FSR:0087                                         ; Power Control Register
FSR:0088 .equ TCON,0x88                          ; DATA XREF: IE0:code_8↑w
FSR:0088                                         ; TF0:code_10↑w ...
FSR:0088                                         ; Timer 0/1 Control Register
FSR:0089 .equ TMOD,0x89                          ; DATA XREF: ProgramBaud+2↑w
FSR:0089                                         ; ProgramTimer0+C↑w
FSR:0089                                         ; Timer Mode Register
FSR:008A .equ TL0,0x8A                           ; DATA XREF: ProgramTimer0+F↑w
FSR:008A                                         ; Timer 0, Low Byte
FSR:008B .equ TL1,0x8B                           ; Timer 1, Low Byte
FSR:008C .equ TH0,0x8C                           ; DATA XREF: TF0:ResetT0Count↑w
FSR:008C                                         ; ProgramTimer0+12↑w
FSR:008C                                         ; Timer 0, High Byte
FSR:008D .equ TH1,0x8D                           ; DATA XREF: ProgramBaud+8↑w
FSR:008D                                         ; Timer 1, High Byte
FSR:008E .equ RESERVED008E,0x8E                  ; RESERVED
FSR:008F .equ RESERVED008F,0x8F                  ; RESERVED
FSR:0090 .equ P1,0x90                            ; DATA XREF: RESET_0+E↑w
FSR:0090                                         ; TestPrinterPresence+7↑w ...
FSR:0090                                         ; Port 1
FSR:0091 .equ RESERVED0091,0x91                  ; RESERVED
FSR:0092 .equ RESERVED0092,0x92                  ; RESERVED
FSR:0093 .equ RESERVED0093,0x93                  ; RESERVED
FSR:0094 .equ RESERVED0094,0x94                  ; RESERVED
FSR:0095 .equ RESERVED0095,0x95                  ; RESERVED
FSR:0096 .equ RESERVED0096,0x96                  ; RESERVED
FSR:0097 .equ RESERVED0097,0x97                  ; RESERVED
FSR:0098 .equ SCON,0x98                          ; DATA XREF: RI_TI+76↑r
FSR:0098                                         ; RI_TI+79↑w ...
FSR:0098                                         ; Serial Channel Control Register
FSR:0099 .equ SBUF,0x99                          ; DATA XREF: RI_TI+7B↑r
FSR:0099                                         ; RI_TI+9A↑w ...
FSR:0099                                         ; Serial Channel Buffer Register
FSR:009A .equ RESERVED009A,0x9A                  ; RESERVED
FSR:009B .equ RESERVED009B,0x9B                  ; RESERVED
FSR:009C .equ RESERVED009C,0x9C                  ; RESERVED
FSR:009D .equ RESERVED009D,0x9D                  ; RESERVED
FSR:009E .equ RESERVED009E,0x9E                  ; RESERVED
FSR:009F .equ RESERVED009F,0x9F                  ; RESERVED
FSR:00A0 .equ P2,0xA0                            ; DATA XREF: PrintCharToVRAM+4↑w
FSR:00A0                                         ; InsertCharOnLine+F↑w ...
FSR:00A0                                         ; Port 2
FSR:00A1 .equ RESERVED00A1,0xA1                  ; RESERVED
FSR:00A2 .equ RESERVED00A2,0xA2                  ; RESERVED
FSR:00A3 .equ RESERVED00A3,0xA3                  ; RESERVED
FSR:00A4 .equ RESERVED00A4,0xA4                  ; RESERVED
FSR:00A5 .equ RESERVED00A5,0xA5                  ; RESERVED
FSR:00A6 .equ RESERVED00A6,0xA6                  ; RESERVED
FSR:00A7 .equ RESERVED00A7,0xA7                  ; RESERVED
FSR:00A8 .equ IE,0xA8                            ; DATA XREF: IE0↑r
FSR:00A8                                         ; TF0↑r ...
FSR:00A8                                         ; Interrupt Enable Register
FSR:00A9 .equ RESERVED00A9,0xA9                  ; RESERVED
FSR:00AA .equ RESERVED00AA,0xAA                  ; RESERVED
FSR:00AB .equ RESERVED00AB,0xAB                  ; RESERVED
FSR:00AC .equ RESERVED00AC,0xAC                  ; RESERVED
FSR:00AD .equ RESERVED00AD,0xAD                  ; RESERVED
FSR:00AE .equ RESERVED00AE,0xAE                  ; RESERVED
FSR:00AF .equ RESERVED00AF,0xAF                  ; RESERVED
FSR:00B0 .equ P3,0xB0                            ; DATA XREF: RESET_0+11↑w
FSR:00B0                                         ; TimeBasedUpdates+4↑w ...
FSR:00B0                                         ; Port 3
FSR:00B1 .equ RESERVED00B1,0xB1                  ; RESERVED
FSR:00B2 .equ RESERVED00B2,0xB2                  ; RESERVED
FSR:00B3 .equ RESERVED00B3,0xB3                  ; RESERVED
FSR:00B4 .equ RESERVED00B4,0xB4                  ; RESERVED
FSR:00B5 .equ RESERVED00B5,0xB5                  ; RESERVED
FSR:00B6 .equ RESERVED00B6,0xB6                  ; RESERVED
FSR:00B7 .equ RESERVED00B7,0xB7                  ; RESERVED
FSR:00B8 .equ IP,0xB8                            ; DATA XREF: RESET_0:EnableHardware↑w
FSR:00B8                                         ; Interrupt Priority Register
FSR:00B9 .equ RESERVED00B9,0xB9                  ; RESERVED
FSR:00BA .equ RESERVED00BA,0xBA                  ; RESERVED
FSR:00BB .equ RESERVED00BB,0xBB                  ; RESERVED
FSR:00BC .equ RESERVED00BC,0xBC                  ; RESERVED
FSR:00BD .equ RESERVED00BD,0xBD                  ; RESERVED
FSR:00BE .equ RESERVED00BE,0xBE                  ; RESERVED
FSR:00BF .equ RESERVED00BF,0xBF                  ; RESERVED
FSR:00C0 .equ RESERVED00C0,0xC0                  ; RESERVED
FSR:00C1 .equ RESERVED00C1,0xC1                  ; RESERVED
FSR:00C2 .equ RESERVED00C2,0xC2                  ; RESERVED
FSR:00C3 .equ RESERVED00C3,0xC3                  ; RESERVED
FSR:00C4 .equ RESERVED00C4,0xC4                  ; RESERVED
FSR:00C5 .equ RESERVED00C5,0xC5                  ; RESERVED
FSR:00C6 .equ RESERVED00C6,0xC6                  ; RESERVED
FSR:00C7 .equ RESERVED00C7,0xC7                  ; RESERVED
FSR:00C8 .equ T2CON,0xC8                         ; Timer 2 Control Register
FSR:00C9 .equ T2MOD,0xC9                         ; Timer 2 Mode Register
FSR:00CA .equ RC2L,0xCA                          ; Timer 2 Reload/Capture Register, Low Byte
FSR:00CB .equ RC2H,0xCB                          ; Timer 2 Reload/Capture Register, High Byte
FSR:00CC .equ TL2,0xCC                           ; Timer 2 Low Byte
FSR:00CD .equ TH2,0xCD                           ; Timer 2 High Byte
FSR:00CE .equ RESERVED00CE,0xCE                  ; RESERVED
FSR:00CF .equ RESERVED00CF,0xCF                  ; RESERVED
FSR:00D0 .equ PSW,0xD0                           ; DATA XREF: IE0:continue_ie0↑r
FSR:00D0                                         ; IE0+31↑w ...
FSR:00D0                                         ; Program Status Word Register
FSR:00D1 .equ RESERVED00D1,0xD1                  ; RESERVED
FSR:00D2 .equ RESERVED00D2,0xD2                  ; RESERVED
FSR:00D3 .equ RESERVED00D3,0xD3                  ; RESERVED
FSR:00D4 .equ RESERVED00D4,0xD4                  ; RESERVED
FSR:00D5 .equ RESERVED00D5,0xD5                  ; RESERVED
FSR:00D6 .equ RESERVED00D6,0xD6                  ; RESERVED
FSR:00D7 .equ RESERVED00D7,0xD7                  ; RESERVED
FSR:00D8 .equ RESERVED00D8,0xD8                  ; RESERVED
FSR:00D9 .equ RESERVED00D9,0xD9                  ; RESERVED
FSR:00DA .equ RESERVED00DA,0xDA                  ; RESERVED
FSR:00DB .equ RESERVED00DB,0xDB                  ; RESERVED
FSR:00DC .equ RESERVED00DC,0xDC                  ; RESERVED
FSR:00DD .equ RESERVED00DD,0xDD                  ; RESERVED
FSR:00DE .equ RESERVED00DE,0xDE                  ; RESERVED
FSR:00DF .equ RESERVED00DF,0xDF                  ; RESERVED
FSR:00E0 .equ ACC,0xE0                           ; DATA XREF: IE0+28↑r
FSR:00E0                                         ; IE0+38↑r ...
FSR:00E0                                         ; Accumulator
FSR:00E1 .equ RESERVED00E1,0xE1                  ; RESERVED
FSR:00E2 .equ RESERVED00E2,0xE2                  ; RESERVED
FSR:00E3 .equ RESERVED00E3,0xE3                  ; RESERVED
FSR:00E4 .equ RESERVED00E4,0xE4                  ; RESERVED
FSR:00E5 .equ RESERVED00E5,0xE5                  ; RESERVED
FSR:00E6 .equ RESERVED00E6,0xE6                  ; RESERVED
FSR:00E7 .equ RESERVED00E7,0xE7                  ; RESERVED
FSR:00E8 .equ RESERVED00E8,0xE8                  ; RESERVED
FSR:00E9 .equ RESERVED00E9,0xE9                  ; RESERVED
FSR:00EA .equ RESERVED00EA,0xEA                  ; RESERVED
FSR:00EB .equ RESERVED00EB,0xEB                  ; RESERVED
FSR:00EC .equ RESERVED00EC,0xEC                  ; RESERVED
FSR:00ED .equ RESERVED00ED,0xED                  ; RESERVED
FSR:00EE .equ RESERVED00EE,0xEE                  ; RESERVED
FSR:00EF .equ RESERVED00EF,0xEF                  ; RESERVED
FSR:00F0 .equ B,0xF0                             ; DATA XREF: IE0+2A↑r
FSR:00F0                                         ; IE1+55↑w ...
FSR:00F0                                         ; B-Register
FSR:00F1 .equ RESERVED00F1,0xF1                  ; RESERVED
FSR:00F2 .equ RESERVED00F2,0xF2                  ; RESERVED
FSR:00F3 .equ RESERVED00F3,0xF3                  ; RESERVED
FSR:00F4 .equ RESERVED00F4,0xF4                  ; RESERVED
FSR:00F5 .equ RESERVED00F5,0xF5                  ; RESERVED
FSR:00F6 .equ RESERVED00F6,0xF6                  ; RESERVED
FSR:00F7 .equ RESERVED00F7,0xF7                  ; RESERVED
FSR:00F8 .equ RESERVED00F8,0xF8                  ; RESERVED
FSR:00F9 .equ RESERVED00F9,0xF9                  ; RESERVED
FSR:00FA .equ RESERVED00FA,0xFA                  ; RESERVED
FSR:00FB .equ RESERVED00FB,0xFB                  ; RESERVED
FSR:00FC .equ RESERVED00FC,0xFC                  ; RESERVED
FSR:00FD .equ RESERVED00FD,0xFD                  ; RESERVED
FSR:00FE .equ RESERVED00FE,0xFE                  ; RESERVED
FSR:00FF .equ RESERVED00FF,0xFF                  ; RESERVED
FSR:00FF ; end of 'FSR'
FSR:00FF
EXTRAM:0000 ; ===========================================================================
EXTRAM:0000
EXTRAM:0000 ; Segment type: Regular
EXTRAM:0000                 ;.segment EXTRAM
EXTRAM:0000 KeyboardGrid:   .byte 0xFF;(array 8)    ; DATA XREF: CheckKeyboard+4↑o
EXTRAM:0000                                         ; CheckKeyboard:ReadKeyboardLoop↑o ...
EXTRAM:0000                                         ; Keyboard grid
EXTRAM:0008 ; EXTRAM:0008
EXTRAM:1000 KeyboardShift:  .byte 0xFF;(array 1)    ; DATA XREF: CheckKeyboard+14↑o
EXTRAM:1000                                         ; CheckKeyboard:ProcessESCKey↑o ...
EXTRAM:1000                                         ; Bit 0 = ESC
EXTRAM:1000                                         ; Bit 1 = CAPS lock
EXTRAM:1000                                         ; Bit 2 = Ctrl key
EXTRAM:1000                                         ; Bit 3 = SHIFT key
EXTRAM:1001 ; EXTRAM:1001
EXTRAM:2000 PrinterOutPort: .byte 0xFF;(array 1)    ; DATA XREF: TestPrinterPresence+3↑o
EXTRAM:2000                                         ; SendPrinterChar+4↑o
EXTRAM:2001 ; EXTRAM:2001
EXTRAM:3000 DialMemoryCksum:.byte 0xFF;(array 2)    ; DATA XREF: CheckPhoneBookMem+2↑o
EXTRAM:3000                                         ; UpdatePhoneBookCksum+5↑o ...
EXTRAM:3002 DialMemoryWatermark:.byte 0xFF;(array 2)
EXTRAM:3002                                         ; DATA XREF: SumRAM3002↑o
EXTRAM:3002                                         ; CheckAndInitDirectory↑o ...
EXTRAM:3004 SavedSerialSettings:.byte 0xFF;(array 2)
EXTRAM:3004                                         ; DATA XREF: RESET_0+77↑o
EXTRAM:3004                                         ; SettingsSaveChanges+A↑o
EXTRAM:3006 SavedSlashPause:.byte 0xFF;(array 1)
EXTRAM:3007 SavedSecWaitForAnswer:.byte 0xFF;(array 1)
EXTRAM:3008 HexChars:       .byte 0xFF;(array 2)    ; DATA XREF: SendAsHex↑o
EXTRAM:3008                                         ; RecvAsHex:code_CD0↑o
EXTRAM:3008                                         ; This can be read and written to with ESC codes.  Seems to serve no
EXTRAM:3008                                         ; other purpose.
EXTRAM:300A                 .byte 0xFF;(array 1)
EXTRAM:300B                 .byte 0xFF;(array 1)
EXTRAM:300C                 .byte 0xFF;(array 1)
EXTRAM:300D                 .byte 0xFF;(array 1)
EXTRAM:300E                 .byte 0xFF;(array 1)
EXTRAM:300F                 .byte 0xFF;(array 1)
EXTRAM:3010                 .byte 0xFF;(array 1)
EXTRAM:3011                 .byte 0xFF;(array 1)
EXTRAM:3012                 .byte 0xFF;(array 1)
EXTRAM:3013                 .byte 0xFF;(array 1)
EXTRAM:3014                 .byte 0xFF;(array 1)
EXTRAM:3015 DirectoryStart: .byte 0xFF;(array 0x3E9)
EXTRAM:3015                                         ; DATA XREF: FindNthDirectoryEntry↑o
EXTRAM:3015                                         ; InitializeDirectory↑o
EXTRAM:33FE DialMemoryLimit:.byte 0xFF;(array 1)    ; DATA XREF: GetEntryMovementAmount+19↑o
EXTRAM:33FF                 .byte 0xFF;(array 1)
EXTRAM:3400 ; EXTRAM_3400
EXTRAM:4000 VideoLine1:     .byte 0xFF;(array 0x32) ; DATA XREF: IE1+5C↑o
EXTRAM:4000                                         ; ResetDisplay+6↑o ...
EXTRAM:4032 ModemStatusText:.byte 0xFF;(array 0xB)  ; DATA XREF: UpdateStatusLine:WriteTerminalOnlineStatus↑o
EXTRAM:4032                                         ; UpdateStatusLine+34↑o
EXTRAM:403D SerialModeText: .byte 0xFF;(array 3)    ; DATA XREF: SaveAndSendKey+79↑o
EXTRAM:4040 PrintStatus:    .byte 0xFF;(array 0xA)  ; DATA XREF: ModifySetting:code_614↑o
EXTRAM:4040                                         ; ModifySetting+58↑o
EXTRAM:404A Time:           .byte 0xFF;(array 0x16) ; DATA XREF: WriteTime↑o
EXTRAM:4060 VideoLine2:     .byte 0xFF;(array 0x60) ; DATA XREF: RESET_0+5E↑o
EXTRAM:4060                                         ; RESET_0+61↑o ...
EXTRAM:40C0 VideoLine3:     .byte 0xFF;(array 0x60) ; DATA XREF: code:aHoldSaveButton↑o
EXTRAM:40C0                                         ; DrawLargeBox+12↑o ...
EXTRAM:4120 VideoLine4:     .byte 0xFF;(array 0x60) ; DATA XREF: code:00001DB9↑o
EXTRAM:4180 VideoLine5:     .byte 0xFF;(array 0x60)
EXTRAM:41E0 VideoLine6:     .byte 0xFF;(array 0x60) ; DATA XREF: code:00001DCF↑o
EXTRAM:4240 VideoLine7:     .byte 0xFF;(array 0x60) ; DATA XREF: code:00001DF0↑o
EXTRAM:4240                                         ; PrintSettingsToScreen+77↑o
EXTRAM:42A0 VideoLine8:     .byte 0xFF;(array 0x60) ; DATA XREF: code:00001E0D↑o
EXTRAM:42A0                                         ; PrintSettingsToScreen+8D↑o
EXTRAM:4300 VideoLine9:     .byte 0xFF;(array 0x60)
EXTRAM:4360 VideoLine10:    .byte 0xFF;(array 0x60) ; DATA XREF: code:00001E22↑o
EXTRAM:4360                                         ; PrintSettingsToScreen+4B↑o ...
EXTRAM:43C0 VideoLine11:    .byte 0xFF;(array 0x60) ; DATA XREF: code:00001E32↑o
EXTRAM:4420 VideoLine12:    .byte 0xFF;(array 0x60)
EXTRAM:4480 VideoLine13:    .byte 0xFF;(array 0x60)
EXTRAM:44E0 VideoLine14:    .byte 0xFF;(array 0x60)
EXTRAM:4540 VideoLine15:    .byte 0xFF;(array 0x60)
EXTRAM:45A0 VideoLine16:    .byte 0xFF;(array 0x60)
EXTRAM:4600 VideoLine17:    .byte 0xFF;(array 0x60) ; DATA XREF: DrawFunctionKeyMenu+2↑o
EXTRAM:4600                                         ; code:aDialMenu↑o
EXTRAM:4660 VideoLine18:    .byte 0xFF;(array 0x60) ; DATA XREF: EraseAllEntries+E↑o
EXTRAM:4660                                         ; EraseAllEntries+10↑o ...
EXTRAM:46C0 VideoLine19:    .byte 0xFF;(array 0x60) ; DATA XREF: code:00001B74↑o
EXTRAM:46C0                                         ; code:00001BA9↑o ...
EXTRAM:4720 VideoLine20:    .byte 0xFF;(array 0x60) ; DATA XREF: code:00001B7B↑o
EXTRAM:4720                                         ; code:00001CBE↑o ...
EXTRAM:4780 VideoLine21:    .byte 0xFF;(array 0x60) ; DATA XREF: EraseAllEntries+DD↑o
EXTRAM:4780                                         ; EraseAllEntries+DF↑o
EXTRAM:47E0 VideoLine22:    .byte 0xFF;(array 0x60) ; DATA XREF: PrintConnectMenu+C↑o
EXTRAM:4840 VideoLine23:    .byte 0xFF;(array 0x60) ; DATA XREF: code:aConnectMenu↑o
EXTRAM:48A0 VideoLine24:    .byte 0xFF;(array 0x60) ; DATA XREF: code:00001BFC↑o
EXTRAM:4900 VideoLine25:    .byte 0xFF;(array 0x60) ; DATA XREF: EraseAllEntries+193↑o
EXTRAM:4900                                         ; EraseAllEntries+195↑o
EXTRAM:4960 PressedKeys:    .byte 0xFF;(array 8)    ; DATA XREF: RESET_0+27↑o
EXTRAM:4960                                         ; CheckKeyboard+6↑o
EXTRAM:4960                                         ; This is an array of 8x8 bits representing each key on the
EXTRAM:4960                                         ; keyboard.  The system scans from 0 to 8 and marks down
EXTRAM:4960                                         ; each key it finds turned on.  This helps to keep track
EXTRAM:4960                                         ; of which keys were last pressed.
EXTRAM:4968 DialName:       .byte 0xFF;(array 0xD)  ; DATA XREF: EraseAllEntries+B9↑o
EXTRAM:4968                                         ; EraseAllEntries+BC↑o ...
EXTRAM:4975 DigitsToDial:   .byte 0xFF;(array 0x16) ; DATA XREF: PerformState:HaveNumber↑o
EXTRAM:4975                                         ; PerformState+214↑o ...
EXTRAM:4975                                         ; This buffer holds the digits that are currently being
EXTRAM:4975                                         ; dialed.  The dial reader marks them out one by one as
EXTRAM:4975                                         ; each digit is rendered to the phone line.
EXTRAM:498B DialStringEncoded:.byte 0xFF;(array 0x16)
EXTRAM:498B                                         ; DATA XREF: RESET_0+23↑o
EXTRAM:498B                                         ; ManualDial+10↑o ...
EXTRAM:49A1 TimeDigitsEX:   .byte 0xFF;(array 6)    ; DATA XREF: RESET_0+13↑o
EXTRAM:49A1                                         ; ChangeSettings+3B↑o ...
EXTRAM:49A7 DialLoginScript:.byte 0xFF;(array 0x59) ; DATA XREF: EraseAllEntries:SelectionOk↑o
EXTRAM:49A7                                         ; EraseAllEntries+10B↑o ...
EXTRAM:4A00 SerialInBuf:    .byte 0xFF;(array 0x40) ; DATA XREF: GetNextSerialInChar+28↑o
EXTRAM:4A00                                         ; AddToSerialInBuf+32↑o
EXTRAM:4A40 SerialOutBuf:   .byte 0xFF;(array 0x10) ; DATA XREF: GetNextSerialOutChar+11↑o
EXTRAM:4A40                                         ; DispatchTypedValue+16↑o
EXTRAM:4A50 DialMiscBuffer: .byte 0xFF;(array 0x40) ; DATA XREF: PerformState+20F↑o
EXTRAM:4A50                                         ; TerminalLoop+9E↑o ...
EXTRAM:4A90 ; EXTRAM:4A90
EXTRAM:7000 CRTC_PREG:      .byte 0xFF;(array 1)    ; DATA XREF: SetVidMode+5↑o
EXTRAM:7000                                         ; SendCursorPos+6↑o
EXTRAM:7001 CRTC_CREG:      .byte 0xFF;(array 1)    ; DATA XREF: IE1+3B↑o
EXTRAM:7001                                         ; ResetDisplay+16↑o ...
EXTRAM:7002 ; EXTRAM:7002
